(function webpackUniversalModuleDefinition(A, B) {
    if (typeof exports === "object" && typeof module === "object") {
        module.exports = B()
    } else {
        if (typeof define === "function" && define.amd) {
            define([], B)
        } else {
            if (typeof exports === "object") {
                exports["echarts"] = B()
            } else {
                A["echarts"] = B()
            }
        }
    }
})(this, function() {
    return (function(A) {
        var C = {};

        function B(E) {
            if (C[E]) {
                return C[E].exports
            }
            var D = C[E] = {exports: {}, id: E, loaded: false};
            A[E].call(D.exports, D, D.exports, B);
            D.loaded = true;
            return D.exports
        }

        B.m = A;
        B.c = C;
        B.p = "";
        return B(0)
    })([function(B, C, A) {
        B.exports = A(1);
        A(113);
        A(139);
        A(146);
        A(155);
        A(159);
        A(169);
        A(193);
        A(205);
        A(226);
        A(230);
        A(234);
        A(251);
        A(257);
        A(264);
        A(270);
        A(274);
        A(283);
        A(287);
        A(290);
        A(313);
        A(319);
        A(320);
        A(321);
        A(327);
        A(298);
        A(331);
        A(344);
        A(235);
        A(291);
        A(347);
        A(358);
        A(362);
        A(363);
        A(376);
        A(391);
        A(397);
        A(400);
        A(403);
        A(412);
        A(424)
    }, function(Ah, An, Y) {
        if (false) {
            if (typeof window !== "undefined") {
                window.__DEV__ = true
            } else {
                if (typeof global !== "undefined") {
                    global.__DEV__ = true
                }
            }
            /*
	 * ECharts, a javascript interactive chart library.
	 *
	 * Copyright (c) 2015, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
	 */
        }
        var E = Y(2);
        var u = Y(3);
        var v = Y(75);
        var h = Y(76);
        var Q = Y(77);
        var I = Y(69);
        var Am = Y(78);
        var T = Y(79);
        var t = Y(80);
        var Ai = Y(18);
        var x = Y(5);
        var N = Y(81);
        var m = Y(82);
        var l = Y(4);
        var c = Y(31);
        var B = Y(25);
        var z = Y(86);
        var Aa = l.each;
        var Ae = I.parseClassType;
        var e = 1000;
        var Ag = 5000;
        var i = 1000;
        var Af = 2000;
        var w = 3000;
        var o = 4000;
        var O = 5000;
        var Ad = "__flagInMainProcess";
        var F = "__hasGradientOrPatternBg";
        var G = "__optionUpdated";
        var V = /^[a-zA-Z0-9_]+$/;

        function K(As) {
            return function(Av, Au, At) {
                Av = Av && Av.toLowerCase();
                B.prototype[As].call(this, Av, Au, At)
            }
        }

        function k() {
            B.call(this)
        }

        k.prototype.on = K("on");
        k.prototype.off = K("off");
        k.prototype.one = K("one");
        l.mixin(k, B);

        function W(As, Aw, Au) {
            Au = Au || {};
            if (typeof Aw === "string") {
                Aw = H[Aw]
            }
            this.id;
            this.group;
            this._dom = As;
            var At = this._zr = m.init(As, {
                renderer: Au.renderer || "canvas",
                devicePixelRatio: Au.devicePixelRatio,
                width: Au.width,
                height: Au.height
            });
            this._throttledZrFlush = N.throttle(l.bind(At.flush, At), 17);
            this._theme = l.clone(Aw);
            this._chartsViews = [];
            this._chartsMap = {};
            this._componentsViews = [];
            this._componentsMap = {};
            this._coordSysMgr = new h();
            this._api = y(this);
            B.call(this);
            this._messageCenter = new k();
            this._initEvents();
            this.resize = l.bind(this.resize, this);
            this._pendingActions = [];

            function Av(Ay, Ax) {
                return Ay.prio - Ax.prio
            }

            z(Ao, Av);
            z(q, Av);
            At.animation.on("frame", this._onframe, this);
            l.setAsPrimitive(this)
        }

        var D = W.prototype;
        D._onframe = function() {
            if (this[G]) {
                var As = this[G].silent;
                this[Ad] = true;
                C.prepareAndUpdate.call(this);
                this[Ad] = false;
                this[G] = false;
                a.call(this, As);
                d.call(this, As)
            }
        };
        D.getDom = function() {
            return this._dom
        };
        D.getZr = function() {
            return this._zr
        };
        D.setOption = function(At, As, Au) {
            if (true) {
                l.assert(!this[Ad], "`setOption` should not be called during main process.")
            }
            var Ay;
            if (l.isObject(As)) {
                Au = As.lazyUpdate;
                Ay = As.silent;
                As = As.notMerge
            }
            this[Ad] = true;
            if (!this._model || As) {
                var Aw = new Q(this._api);
                var Ax = this._theme;
                var Av = this._model = new u(null, null, Ax, Aw);
                Av.init(null, null, Ax, Aw)
            }
            this._model.setOption(At, Z);
            if (Au) {
                this[G] = {silent: Ay};
                this[Ad] = false
            } else {
                C.prepareAndUpdate.call(this);
                this._zr.flush();
                this[G] = false;
                this[Ad] = false;
                a.call(this, Ay);
                d.call(this, Ay)
            }
        };
        D.setTheme = function() {
            console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
        };
        D.getModel = function() {
            return this._model
        };
        D.getOption = function() {
            return this._model && this._model.getOption()
        };
        D.getWidth = function() {
            return this._zr.getWidth()
        };
        D.getHeight = function() {
            return this._zr.getHeight()
        };
        D.getDevicePixelRatio = function() {
            return this._zr.painter.dpr || window.devicePixelRatio || 1
        };
        D.getRenderedCanvas = function(At) {
            if (!E.canvasSupported) {
                return
            }
            At = At || {};
            At.pixelRatio = At.pixelRatio || 1;
            At.backgroundColor = At.backgroundColor || this._model.get("backgroundColor");
            var As = this._zr;
            var Au = As.storage.getDisplayList();
            l.each(Au, function(Av) {
                Av.stopAnimation(true)
            });
            return As.painter.getRenderedCanvas(At)
        };
        D.getDataURL = function(As) {
            As = As || {};
            var Ax = As.excludeComponents;
            var At = this._model;
            var Au = [];
            var Av = this;
            Aa(Ax, function(Ay) {
                At.eachComponent({mainType: Ay}, function(Az) {
                    var AA = Av._componentsMap[Az.__viewId];
                    if (!AA.group.ignore) {
                        Au.push(AA);
                        AA.group.ignore = true
                    }
                })
            });
            var Aw = this.getRenderedCanvas(As).toDataURL("image/" + (As && As.type || "png"));
            Aa(Au, function(Ay) {
                Ay.group.ignore = false
            });
            return Aw
        };
        D.getConnectedDataURL = function(AA) {
            if (!E.canvasSupported) {
                return
            }
            var Av = this.group;
            var At = Math.min;
            var AB = Math.max;
            var Ax = Infinity;
            if (Ar[Av]) {
                var Az = Ax;
                var Ay = Ax;
                var Au = -Ax;
                var AD = -Ax;
                var AF = [];
                var AE = (AA && AA.pixelRatio) || 1;
                l.each(S, function(AH, AK) {
                    if (AH.group === Av) {
                        var AI = AH.getRenderedCanvas(l.clone(AA));
                        var AJ = AH.getDom().getBoundingClientRect();
                        Az = At(AJ.left, Az);
                        Ay = At(AJ.top, Ay);
                        Au = AB(AJ.right, Au);
                        AD = AB(AJ.bottom, AD);
                        AF.push({dom: AI, left: AJ.left, top: AJ.top})
                    }
                });
                Az *= AE;
                Ay *= AE;
                Au *= AE;
                AD *= AE;
                var AC = Au - Az;
                var AG = AD - Ay;
                var As = l.createCanvas();
                As.width = AC;
                As.height = AG;
                var Aw = m.init(As);
                Aa(AF, function(AH) {
                    var AI = new Ai.Image({style: {x: AH.left * AE - Az, y: AH.top * AE - Ay, image: AH.dom}});
                    Aw.add(AI)
                });
                Aw.refreshImmediately();
                return As.toDataURL("image/" + (AA && AA.type || "png"))
            } else {
                return this.getDataURL(AA)
            }
        };
        D.convertToPixel = l.curry(f, "convertToPixel");
        D.convertFromPixel = l.curry(f, "convertFromPixel");

        function f(Az, Ay, Aw) {
            var At = this._model;
            var As = this._coordSysMgr.getCoordinateSystems();
            var Av;
            Ay = x.parseFinder(At, Ay);
            for (var Ax = 0; Ax < As.length; Ax++) {
                var Au = As[Ax];
                if (Au[Az] && (Av = Au[Az](At, Ay, Aw)) != null) {
                    return Av
                }
            }
            if (true) {
                console.warn("No coordinate system that supports " + Az + " found by the given finder.")
            }
        }

        D.containPixel = function(Av, Au) {
            var At = this._model;
            var As;
            Av = x.parseFinder(At, Av);
            l.each(Av, function(Ax, Aw) {
                Aw.indexOf("Models") >= 0 && l.each(Ax, function(AA) {
                    var Ay = AA.coordinateSystem;
                    if (Ay && Ay.containPoint) {
                        As |= !!Ay.containPoint(Au)
                    } else {
                        if (Aw === "seriesModels") {
                            var Az = this._chartsMap[AA.__viewId];
                            if (Az && Az.containPoint) {
                                As |= Az.containPoint(Au, AA)
                            } else {
                                if (true) {
                                    console.warn(Aw + ": " + (Az ? "The found component do not support containPoint." : "No view mapping to the found component."))
                                }
                            }
                        } else {
                            if (true) {
                                console.warn(Aw + ": containPoint is not supported")
                            }
                        }
                    }
                }, this)
            }, this);
            return !!As
        };
        D.getVisual = function(Av, At) {
            var Aw = this._model;
            Av = x.parseFinder(Aw, Av, {defaultMainType: "series"});
            var As = Av.seriesModel;
            if (true) {
                if (!As) {
                    console.warn("There is no specified seires model")
                }
            }
            var Ax = As.getData();
            var Au = Av.hasOwnProperty("dataIndexInside") ? Av.dataIndexInside : Av.hasOwnProperty("dataIndex") ? Ax.indexOfRawIndex(Av.dataIndex) : null;
            return Au != null ? Ax.getItemVisual(Au, At) : Ax.getVisual(At)
        };
        D.getViewOfComponentModel = function(As) {
            return this._componentsMap[As.__viewId]
        };
        D.getViewOfSeriesModel = function(As) {
            return this._chartsMap[As.__viewId]
        };
        var C = {
            update: function(At) {
                var As = this._model;
                var Ay = this._api;
                var Av = this._coordSysMgr;
                var Aw = this._zr;
                if (!As) {
                    return
                }
                As.restoreData();
                Av.create(this._model, this._api);
                Ab.call(this, As, Ay);
                p.call(this, As);
                Av.update(As, Ay);
                Aq.call(this, As, At);
                Ap.call(this, As, At);
                var Au = As.get("backgroundColor") || "transparent";
                var Az = Aw.painter;
                if (Az.isSingleCanvas && Az.isSingleCanvas()) {
                    Aw.configLayer(0, {clearColor: Au})
                } else {
                    if (!E.canvasSupported) {
                        var Ax = c.parse(Au);
                        Au = c.stringify(Ax, "rgb");
                        if (Ax[3] === 0) {
                            Au = "transparent"
                        }
                    }
                    if (Au.colorStops || Au.image) {
                        Aw.configLayer(0, {clearColor: Au});
                        this[F] = true;
                        this._dom.style.background = "transparent"
                    } else {
                        if (this[F]) {
                            Aw.configLayer(0, {clearColor: null})
                        }
                        this[F] = false;
                        this._dom.style.background = Au
                    }
                }
                Aa(P, function(AA) {
                    AA(As, Ay)
                })
            }, updateView: function(At) {
                var As = this._model;
                if (!As) {
                    return
                }
                As.eachSeries(function(Au) {
                    Au.getData().clearAllVisual()
                });
                Aq.call(this, As, At);
                n.call(this, "updateView", As, At)
            }, updateVisual: function(At) {
                var As = this._model;
                if (!As) {
                    return
                }
                As.eachSeries(function(Au) {
                    Au.getData().clearAllVisual()
                });
                Aq.call(this, As, At, true);
                n.call(this, "updateVisual", As, At)
            }, updateLayout: function(At) {
                var As = this._model;
                if (!As) {
                    return
                }
                Al.call(this, As, At);
                n.call(this, "updateLayout", As, At)
            }, prepareAndUpdate: function(At) {
                var As = this._model;
                Ac.call(this, "component", As);
                Ac.call(this, "chart", As);
                C.update.call(this, At)
            }
        };

        function Aj(Av, Ay, At, AA, As) {
            var Az = Av._model;
            if (!AA) {
                Aa(Av._componentsViews.concat(Av._chartsViews), Ax);
                return
            }
            var Aw = {};
            Aw[AA + "Id"] = At[AA + "Id"];
            Aw[AA + "Index"] = At[AA + "Index"];
            Aw[AA + "Name"] = At[AA + "Name"];
            var Au = {mainType: AA, query: Aw};
            As && (Au.subType = As);
            Az && Az.eachComponent(Au, function(AC, AB) {
                Ax(Av[AA === "series" ? "_chartsMap" : "_componentsMap"][AC.__viewId])
            }, Av);

            function Ax(AB) {
                AB && AB.__alive && AB[Ay] && AB[Ay](AB.__model, Az, Av._api, At)
            }
        }

        D.resize = function(As) {
            if (true) {
                l.assert(!this[Ad], "`resize` should not be called during main process.")
            }
            this[Ad] = true;
            this._zr.resize(As);
            var Au = this._model && this._model.resetOption("media");
            var At = Au ? "prepareAndUpdate" : "update";
            C[At].call(this);
            this._loadingFX && this._loadingFX.resize();
            this[Ad] = false;
            var Av = As && As.silent;
            a.call(this, Av);
            d.call(this, Av)
        };
        D.showLoading = function(Au, Av) {
            if (l.isObject(Au)) {
                Av = Au;
                Au = ""
            }
            Au = Au || "default";
            this.hideLoading();
            if (!A[Au]) {
                if (true) {
                    console.warn("Loading effects " + Au + " not exists.")
                }
                return
            }
            var As = A[Au](this._api, Av);
            var At = this._zr;
            this._loadingFX = As;
            At.add(As)
        };
        D.hideLoading = function() {
            this._loadingFX && this._zr.remove(this._loadingFX);
            this._loadingFX = null
        };
        D.makeActionFromEvent = function(As) {
            var At = l.extend({}, As);
            At.type = r[As.type];
            return At
        };
        D.dispatchAction = function(At, As) {
            if (!l.isObject(As)) {
                As = {silent: !!As}
            }
            if (!s[At.type]) {
                return
            }
            if (this[Ad]) {
                this._pendingActions.push(At);
                return
            }
            b.call(this, At, As.silent);
            if (As.flush) {
                this._zr.flush(true)
            } else {
                if (As.flush !== false && E.browser.weChat) {
                    this._throttledZrFlush()
                }
            }
            a.call(this, As.silent);
            d.call(this, As.silent)
        };

        function b(Av, AE) {
            var Ax = Av.type;
            var Az = Av.escapeConnect;
            var As = s[Ax];
            var AB = As.actionInfo;
            var Au = (AB.update || "update").split(":");
            var AC = Au.pop();
            Au = Au[0] != null && Ae(Au[0]);
            this[Ad] = true;
            var Aw = [Av];
            var AA = false;
            if (Av.batch) {
                AA = true;
                Aw = l.map(Av.batch, function(AF) {
                    AF = l.defaults(l.extend({}, AF), Av);
                    AF.batch = null;
                    return AF
                })
            }
            var Ay = [];
            var At;
            var AD = Ax === "highlight" || Ax === "downplay";
            Aa(Aw, function(AF) {
                At = As.action(AF, this._model, this._api);
                At = At || l.extend({}, AF);
                At.type = AB.event || At.type;
                Ay.push(At);
                if (AD) {
                    Aj(this, AC, AF, "series")
                } else {
                    if (Au) {
                        Aj(this, AC, AF, Au.main, Au.sub)
                    }
                }
            }, this);
            if (AC !== "none" && !AD && !Au) {
                if (this[G]) {
                    C.prepareAndUpdate.call(this, Av);
                    this[G] = false
                } else {
                    C[AC].call(this, Av)
                }
            }
            if (AA) {
                At = {type: AB.event || Ax, escapeConnect: Az, batch: Ay}
            } else {
                At = Ay[0]
            }
            this[Ad] = false;
            !AE && this._messageCenter.trigger(At.type, At)
        }

        function a(Au) {
            var As = this._pendingActions;
            while (As.length) {
                var At = As.shift();
                b.call(this, At, Au)
            }
        }

        function d(As) {
            !As && this.trigger("updated")
        }

        D.on = K("on");
        D.off = K("off");
        D.one = K("one");

        function n(At, As, Au) {
            var Av = this._api;
            Aa(this._componentsViews, function(Ax) {
                var Aw = Ax.__model;
                Ax[At](Aw, As, Av, Au);
                R(Aw, Ax)
            }, this);
            As.eachSeries(function(Ax, Ay) {
                var Aw = this._chartsMap[Ax.__viewId];
                Aw[At](Ax, As, Av, Au);
                R(Ax, Aw);
                Ak(Ax, Aw)
            }, this);
            U(this._zr, As);
            Aa(P, function(Aw) {
                Aw(As, Av)
            })
        }

        function Ac(Az, At) {
            var Av = Az === "component";
            var Aw = Av ? this._componentsViews : this._chartsViews;
            var Ay = Av ? this._componentsMap : this._chartsMap;
            var Au = this._zr;
            for (var Ax = 0; Ax < Aw.length; Ax++) {
                Aw[Ax].__alive = false
            }
            At[Av ? "eachComponent" : "eachSeries"](function(AA, AF) {
                if (Av) {
                    if (AA === "series") {
                        return
                    }
                } else {
                    AF = AA
                }
                var AD = "_ec_" + AF.id + "_" + AF.type;
                var AC = Ay[AD];
                if (!AC) {
                    var AB = Ae(AF.type);
                    var AE = Av ? T.getClass(AB.main, AB.sub) : t.getClass(AB.sub);
                    if (AE) {
                        AC = new AE();
                        AC.init(At, this._api);
                        Ay[AD] = AC;
                        Aw.push(AC);
                        Au.add(AC.group)
                    } else {
                        return
                    }
                }
                AF.__viewId = AC.__id = AD;
                AC.__alive = true;
                AC.__model = AF;
                AC.group.__ecComponentInfo = {mainType: AF.mainType, index: AF.componentIndex}
            }, this);
            for (var Ax = 0; Ax < Aw.length;) {
                var As = Aw[Ax];
                if (!As.__alive) {
                    Au.remove(As.group);
                    As.dispose(At, this._api);
                    Aw.splice(Ax, 1);
                    delete Ay[As.__id];
                    As.__id = As.group.__ecComponentInfo = null
                } else {
                    Ax++
                }
            }
        }

        function Ab(As, At) {
            Aa(q, function(Au) {
                Au.func(As, At)
            })
        }

        function p(As) {
            var At = {};
            As.eachSeries(function(Av) {
                var Au = Av.get("stack");
                var Ax = Av.getData();
                if (Au && Ax.type === "list") {
                    var Aw = At[Au];
                    if (At.hasOwnProperty(Au) && Aw) {
                        Ax.stackedOn = Aw
                    }
                    At[Au] = Ax
                }
            })
        }

        function Al(As, At) {
            var Au = this._api;
            Aa(Ao, function(Av) {
                if (Av.isLayout) {
                    Av.func(As, Au, At)
                }
            })
        }

        function Aq(As, At, Au) {
            var Av = this._api;
            As.clearColorPalette();
            As.eachSeries(function(Aw) {
                Aw.clearColorPalette()
            });
            Aa(Ao, function(Aw) {
                (!Au || !Aw.isLayout) && Aw.func(As, Av, At)
            })
        }

        function Ap(As, At) {
            var Au = this._api;
            Aa(this._componentsViews, function(Aw) {
                var Av = Aw.__model;
                Aw.render(Av, As, Au, At);
                R(Av, Aw)
            }, this);
            Aa(this._chartsViews, function(Av) {
                Av.__alive = false
            }, this);
            As.eachSeries(function(Av, Ax) {
                var Aw = this._chartsMap[Av.__viewId];
                Aw.__alive = true;
                Aw.render(Av, As, Au, At);
                Aw.group.silent = !!Av.get("silent");
                R(Av, Aw);
                Ak(Av, Aw)
            }, this);
            U(this._zr, As);
            Aa(this._chartsViews, function(Av) {
                if (!Av.__alive) {
                    Av.remove(As, Au)
                }
            }, this)
        }

        var j = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
        D._initEvents = function() {
            Aa(j, function(As) {
                this._zr.on(As, function(Au) {
                    var Av = this.getModel();
                    var At = Au.target;
                    var Ax;
                    if (As === "globalout") {
                        Ax = {}
                    } else {
                        if (At && At.dataIndex != null) {
                            var Aw = At.dataModel || Av.getSeriesByIndex(At.seriesIndex);
                            Ax = Aw && Aw.getDataParams(At.dataIndex, At.dataType) || {}
                        } else {
                            if (At && At.eventData) {
                                Ax = l.extend({}, At.eventData)
                            }
                        }
                    }
                    if (Ax) {
                        Ax.event = Au;
                        Ax.type = As;
                        this.trigger(As, Ax)
                    }
                }, this)
            }, this);
            Aa(r, function(At, As) {
                this._messageCenter.on(As, function(Au) {
                    this.trigger(As, Au)
                }, this)
            }, this)
        };
        D.isDisposed = function() {
            return this._disposed
        };
        D.clear = function() {
            this.setOption({series: []}, true)
        };
        D.dispose = function() {
            if (this._disposed) {
                if (true) {
                    console.warn("Instance " + this.id + " has been disposed")
                }
                return
            }
            this._disposed = true;
            var At = this._api;
            var As = this._model;
            Aa(this._componentsViews, function(Au) {
                Au.dispose(As, At)
            });
            Aa(this._chartsViews, function(Au) {
                Au.dispose(As, At)
            });
            this._zr.dispose();
            delete S[this.id]
        };
        l.mixin(W, B);

        function U(At, Au) {
            var As = At.storage;
            var Av = 0;
            As.traverse(function(Aw) {
                if (!Aw.isGroup) {
                    Av++
                }
            });
            if (Av > Au.get("hoverLayerThreshold") && !E.node) {
                As.traverse(function(Aw) {
                    if (!Aw.isGroup) {
                        Aw.useHoverLayer = true
                    }
                })
            }
        }

        function Ak(As, Au) {
            var At = 0;
            Au.group.traverse(function(Ay) {
                if (Ay.type !== "group" && !Ay.ignore) {
                    At++
                }
            });
            var Ax = +As.get("progressive");
            var Aw = At > As.get("progressiveThreshold") && Ax && !E.node;
            if (Aw) {
                Au.group.traverse(function(Ay) {
                    if (!Ay.isGroup) {
                        Ay.progressive = Aw ? Math.floor(At++ / Ax) : -1;
                        if (Aw) {
                            Ay.stopAnimation(true)
                        }
                    }
                })
            }
            var Av = As.get("blendMode") || null;
            if (true) {
                if (!E.canvasSupported && Av && Av !== "source-over") {
                    console.warn("Only canvas support blendMode")
                }
            }
            Au.group.traverse(function(Ay) {
                if (!Ay.isGroup) {
                    Ay.setStyle("blend", Av)
                }
            })
        }

        function R(Av, At) {
            var As = Av.get("z");
            var Au = Av.get("zlevel");
            At.group.traverse(function(Aw) {
                if (Aw.type !== "group") {
                    As != null && (Aw.z = As);
                    Au != null && (Aw.zlevel = Au)
                }
            })
        }

        function y(As) {
            var At = As._coordSysMgr;
            return l.extend(new v(As), {
                getCoordinateSystems: l.bind(At.getCoordinateSystems, At), getComponentByElement: function(Au) {
                    while (Au) {
                        var Av = Au.__ecComponentInfo;
                        if (Av != null) {
                            return As._model.getComponent(Av.mainType, Av.index)
                        }
                        Au = Au.parent
                    }
                }
            })
        }

        var s = {};
        var r = {};
        var q = [];
        var Z = [];
        var P = [];
        var Ao = [];
        var H = {};
        var A = {};
        var S = {};
        var Ar = {};
        var J = new Date() - 0;
        var g = new Date() - 0;
        var X = "_echarts_instance_";
        var L = {version: "3.6.2", dependencies: {zrender: "3.5.2"}};

        function M(As) {
            var Aw = 0;
            var Av = 1;
            var Ax = 2;
            var At = "__connectUpdateStatus";

            function Au(Ay, AB) {
                for (var Az = 0; Az < Ay.length; Az++) {
                    var AA = Ay[Az];
                    AA[At] = AB
                }
            }

            l.each(r, function(Az, Ay) {
                As._messageCenter.on(Ay, function(AC) {
                    if (Ar[As.group] && As[At] !== Aw) {
                        if (AC && AC.escapeConnect) {
                            return
                        }
                        var AA = As.makeActionFromEvent(AC);
                        var AB = [];
                        l.each(S, function(AD) {
                            if (AD !== As && AD.group === As.group) {
                                AB.push(AD)
                            }
                        });
                        Au(AB, Aw);
                        Aa(AB, function(AD) {
                            if (AD[At] !== Av) {
                                AD.dispatchAction(AA)
                            }
                        });
                        Au(AB, Ax)
                    }
                })
            })
        }

        L.init = function(As, Av, At) {
            if (true) {
                if ((m.version.replace(".", "") - 0) < (L.dependencies.zrender.replace(".", "") - 0)) {
                    throw new Error("ZRender " + m.version + " is too old for ECharts " + L.version + ". Current version need ZRender " + L.dependencies.zrender + "+")
                }
                if (!As) {
                    throw new Error("Initialize failed: invalid dom.")
                }
            }
            var Aw = L.getInstanceByDom(As);
            if (Aw) {
                if (true) {
                    console.warn("There is a chart instance already initialized on the dom.")
                }
                return Aw
            }
            if (true) {
                if (l.isDom(As) && As.nodeName.toUpperCase() !== "CANVAS" && ((!As.clientWidth && (!At || At.width == null)) || (!As.clientHeight && (!At || At.height == null)))) {
                    console.warn("Can't get dom width or height")
                }
            }
            var Au = new W(As, Av, At);
            Au.id = "ec_" + J++;
            S[Au.id] = Au;
            if (As.setAttribute) {
                As.setAttribute(X, Au.id)
            } else {
                As[X] = Au.id
            }
            M(Au);
            return Au
        };
        L.connect = function(At) {
            if (l.isArray(At)) {
                var As = At;
                At = null;
                l.each(As, function(Au) {
                    if (Au.group != null) {
                        At = Au.group
                    }
                });
                At = At || ("g_" + g++);
                l.each(As, function(Au) {
                    Au.group = At
                })
            }
            Ar[At] = true;
            return At
        };
        L.disConnect = function(As) {
            Ar[As] = false
        };
        L.disconnect = L.disConnect;
        L.dispose = function(As) {
            if (typeof As === "string") {
                As = S[As]
            } else {
                if (!(As instanceof W)) {
                    As = L.getInstanceByDom(As)
                }
            }
            if ((As instanceof W) && !As.isDisposed()) {
                As.dispose()
            }
        };
        L.getInstanceByDom = function(As) {
            var At;
            if (As.getAttribute) {
                At = As.getAttribute(X)
            } else {
                At = As[X]
            }
            return S[At]
        };
        L.getInstanceById = function(As) {
            return S[As]
        };
        L.registerTheme = function(As, At) {
            H[As] = At
        };
        L.registerPreprocessor = function(As) {
            Z.push(As)
        };
        L.registerProcessor = function(As, At) {
            if (typeof As === "function") {
                At = As;
                As = e
            }
            if (true) {
                if (isNaN(As)) {
                    throw new Error("Unkown processor priority")
                }
            }
            q.push({prio: As, func: At})
        };
        L.registerPostUpdate = function(As) {
            P.push(As)
        };
        L.registerAction = function(Av, Au, As) {
            if (typeof Au === "function") {
                As = Au;
                Au = ""
            }
            var At = l.isObject(Av) ? Av.type : ([Av, Av = {event: Au}][0]);
            Av.event = (Av.event || At).toLowerCase();
            Au = Av.event;
            l.assert(V.test(At) && V.test(Au));
            if (!s[At]) {
                s[At] = {action: As, actionInfo: Av}
            }
            r[Au] = At
        };
        L.registerCoordinateSystem = function(As, At) {
            h.register(As, At)
        };
        L.getCoordinateSystemDimensions = function(As) {
            var At = h.get(As);
            if (At) {
                return At.getDimensionsInfo ? At.getDimensionsInfo() : At.dimensions.slice()
            }
        };
        L.registerLayout = function(At, As) {
            if (typeof At === "function") {
                As = At;
                At = i
            }
            if (true) {
                if (isNaN(At)) {
                    throw new Error("Unkown layout priority")
                }
            }
            Ao.push({prio: At, func: As, isLayout: true})
        };
        L.registerVisual = function(As, At) {
            if (typeof As === "function") {
                At = As;
                As = w
            }
            if (true) {
                if (isNaN(As)) {
                    throw new Error("Unkown visual priority")
                }
            }
            Ao.push({prio: As, func: At})
        };
        L.registerLoading = function(At, As) {
            A[At] = As
        };
        L.extendComponentModel = function(As) {
            return I.extend(As)
        };
        L.extendComponentView = function(As) {
            return T.extend(As)
        };
        L.extendSeriesModel = function(As) {
            return Am.extend(As)
        };
        L.extendChartView = function(As) {
            return t.extend(As)
        };
        L.setCanvasCreator = function(As) {
            l.createCanvas = As
        };
        L.registerVisual(Af, Y(94));
        L.registerPreprocessor(Y(95));
        L.registerLoading("default", Y(97));
        L.registerAction({type: "highlight", event: "highlight", update: "highlight"}, l.noop);
        L.registerAction({type: "downplay", event: "downplay", update: "downplay"}, l.noop);
        L.zrender = m;
        L.List = Y(98);
        L.Model = Y(12);
        L.Axis = Y(100);
        L.graphic = Y(18);
        L.number = Y(7);
        L.format = Y(6);
        L.throttle = N.throttle;
        L.matrix = Y(11);
        L.vector = Y(10);
        L.color = Y(31);
        L.util = {};
        Aa(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(As) {
            L.util[As] = l[As]
        });
        L.helper = Y(108);
        L.PRIORITY = {PROCESSOR: {FILTER: e, STATISTIC: Ag}, VISUAL: {LAYOUT: i, GLOBAL: Af, CHART: w, COMPONENT: o, BRUSH: O}};
        Ah.exports = L
    }, function(C, D) {
        var A = {};
        if (typeof navigator === "undefined") {
            A = {browser: {}, os: {}, node: true, canvasSupported: true}
        } else {
            A = B(navigator.userAgent)
        }
        C.exports = A;

        function B(K) {
            var F = {};
            var E = {};
            var H = K.match(/Firefox\/([\d.]+)/);
            var J = K.match(/MSIE\s([\d.]+)/) || K.match(/Trident\/.+?rv:(([\d.]+))/);
            var G = K.match(/Edge\/([\d.]+)/);
            var I = (/micromessenger/i).test(K);
            if (H) {
                E.firefox = true;
                E.version = H[1]
            }
            if (J) {
                E.ie = true;
                E.version = J[1]
            }
            if (G) {
                E.edge = true;
                E.version = G[1]
            }
            if (I) {
                E.weChat = true
            }
            return {
                browser: E,
                os: F,
                node: false,
                canvasSupported: document.createElement("canvas").getContext ? true : false,
                touchEventsSupported: "ontouchstart" in window && !E.ie && !E.edge,
                pointerEventsSupported: "onpointerdown" in window && (E.edge || (E.ie && E.version >= 11))
            }
        }
    }, function(Q, H, S) {
        var G = S(4);
        var E = S(5);
        var V = S(12);
        var I = G.each;
        var K = G.filter;
        var N = G.map;
        var M = G.isArray;
        var U = G.indexOf;
        var P = G.isObject;
        var D = S(69);
        var J = S(73);
        var B = "\0_ec_inner";
        var T = V.extend({
            constructor: T, init: function(Y, a, X, Z) {
                X = X || {};
                this.option = null;
                this._theme = new V(X);
                this._optionManager = Z
            }, setOption: function(X, Y) {
                G.assert(!(B in X), "please use chart.getOption()");
                this._optionManager.setOption(X, Y);
                this.resetOption(null)
            }, resetOption: function(X) {
                var b = false;
                var a = this._optionManager;
                if (!X || X === "recreate") {
                    var Z = a.mountOption(X === "recreate");
                    if (!this.option || X === "recreate") {
                        W.call(this, Z)
                    } else {
                        this.restoreData();
                        this.mergeOption(Z)
                    }
                    b = true
                }
                if (X === "timeline" || X === "media") {
                    this.restoreData()
                }
                if (!X || X === "recreate" || X === "timeline") {
                    var Y = a.getTimelineOption(this);
                    Y && (this.mergeOption(Y), b = true)
                }
                if (!X || X === "recreate" || X === "media") {
                    var c = a.getMediaOption(this, this._api);
                    if (c.length) {
                        I(c, function(d) {
                            this.mergeOption(d, b = true)
                        }, this)
                    }
                }
                return b
            }, mergeOption: function(a) {
                var X = this.option;
                var b = this._componentsMap;
                var Y = [];
                I(a, function(d, c) {
                    if (d == null) {
                        return
                    }
                    if (!D.hasClass(c)) {
                        X[c] = X[c] == null ? G.clone(d) : G.merge(X[c], d, true)
                    } else {
                        Y.push(c)
                    }
                });
                D.topologicalTravel(Y, D.getAllClassMainTypes(), Z, this);
                this._seriesIndices = this._seriesIndices || [];

                function Z(f, e) {
                    var d = E.normalizeToArray(a[f]);
                    var c = E.mappingToExists(b.get(f), d);
                    E.makeIdAndName(c);
                    I(c, function(i, j) {
                        var h = i.option;
                        if (P(h)) {
                            i.keyInfo.mainType = f;
                            i.keyInfo.subType = L(f, h, i.exist)
                        }
                    });
                    var g = R(b, e);
                    X[f] = [];
                    b.set(f, []);
                    I(c, function(l, k) {
                        var j = l.exist;
                        var h = l.option;
                        G.assert(P(h) || j, "Empty component definition");
                        if (!h) {
                            j.mergeOption({}, this);
                            j.optionUpdated({}, false)
                        } else {
                            var i = D.getClass(f, l.keyInfo.subType, true);
                            if (j && j instanceof i) {
                                j.name = l.keyInfo.name;
                                j.mergeOption(h, this);
                                j.optionUpdated(h, false)
                            } else {
                                var m = G.extend({dependentModels: g, componentIndex: k}, l.keyInfo);
                                j = new i(h, this, this, m);
                                G.extend(j, m);
                                j.init(h, this, this, m);
                                j.optionUpdated(null, true)
                            }
                        }
                        b.get(f)[k] = j;
                        X[f][k] = j.option
                    }, this);
                    if (f === "series") {
                        this._seriesIndices = A(b.get("series"))
                    }
                }
            }, getOption: function() {
                var X = G.clone(this.option);
                I(X, function(Z, a) {
                    if (D.hasClass(a)) {
                        var Z = E.normalizeToArray(Z);
                        for (var Y = Z.length - 1; Y >= 0; Y--) {
                            if (E.isIdInner(Z[Y])) {
                                Z.splice(Y, 1)
                            }
                        }
                        X[a] = Z
                    }
                });
                delete X[B];
                return X
            }, getTheme: function() {
                return this._theme
            }, getComponent: function(X, Z) {
                var Y = this._componentsMap.get(X);
                if (Y) {
                    return Y[Z || 0]
                }
            }, queryComponents: function(Z) {
                var e = Z.mainType;
                if (!e) {
                    return []
                }
                var d = Z.index;
                var c = Z.id;
                var Y = Z.name;
                var b = this._componentsMap.get(e);
                if (!b || !b.length) {
                    return []
                }
                var X;
                if (d != null) {
                    if (!M(d)) {
                        d = [d]
                    }
                    X = K(N(d, function(g) {
                        return b[g]
                    }), function(g) {
                        return !!g
                    })
                } else {
                    if (c != null) {
                        var f = M(c);
                        X = K(b, function(g) {
                            return (f && U(c, g.id) >= 0) || (!f && g.id === c)
                        })
                    } else {
                        if (Y != null) {
                            var a = M(Y);
                            X = K(b, function(g) {
                                return (a && U(Y, g.name) >= 0) || (!a && g.name === Y)
                            })
                        } else {
                            X = b.slice()
                        }
                    }
                }
                return F(X, Z)
            }, findComponents: function(c) {
                var a = c.query;
                var Z = c.mainType;
                var d = X(a);
                var Y = d ? this.queryComponents(d) : this._componentsMap.get(Z);
                return b(F(Y, c));

                function X(f) {
                    var e = Z + "Index";
                    var g = Z + "Id";
                    var h = Z + "Name";
                    return f && (f[e] != null || f[g] != null || f[h] != null) ? {mainType: Z, index: f[e], id: f[g], name: f[h]} : null
                }

                function b(e) {
                    return c.filter ? K(e, c.filter) : e
                }
            }, eachComponent: function(Z, X, Y) {
                var b = this._componentsMap;
                if (typeof Z === "function") {
                    Y = X;
                    X = Z;
                    b.each(function(d, c) {
                        I(d, function(e, f) {
                            X.call(Y, c, e, f)
                        })
                    })
                } else {
                    if (G.isString(Z)) {
                        I(b.get(Z), X, Y)
                    } else {
                        if (P(Z)) {
                            var a = this.findComponents(Z);
                            I(a, X, Y)
                        }
                    }
                }
            }, getSeriesByName: function(X) {
                var Y = this._componentsMap.get("series");
                return K(Y, function(Z) {
                    return Z.name === X
                })
            }, getSeriesByIndex: function(X) {
                return this._componentsMap.get("series")[X]
            }, getSeriesByType: function(Y) {
                var X = this._componentsMap.get("series");
                return K(X, function(Z) {
                    return Z.subType === Y
                })
            }, getSeries: function() {
                return this._componentsMap.get("series").slice()
            }, eachSeries: function(X, Y) {
                C(this);
                I(this._seriesIndices, function(a) {
                    var Z = this._componentsMap.get("series")[a];
                    X.call(Y, Z, a)
                }, this)
            }, eachRawSeries: function(X, Y) {
                I(this._componentsMap.get("series"), X, Y)
            }, eachSeriesByType: function(Z, X, Y) {
                C(this);
                I(this._seriesIndices, function(b) {
                    var a = this._componentsMap.get("series")[b];
                    if (a.subType === Z) {
                        X.call(Y, a, b)
                    }
                }, this)
            }, eachRawSeriesByType: function(Z, X, Y) {
                return I(this.getSeriesByType(Z), X, Y)
            }, isSeriesFiltered: function(X) {
                C(this);
                return G.indexOf(this._seriesIndices, X.componentIndex) < 0
            }, getCurrentSeriesIndices: function() {
                return (this._seriesIndices || []).slice()
            }, filterSeries: function(X, Y) {
                C(this);
                var Z = K(this._componentsMap.get("series"), X, Y);
                this._seriesIndices = A(Z)
            }, restoreData: function() {
                var Y = this._componentsMap;
                this._seriesIndices = A(Y.get("series"));
                var X = [];
                Y.each(function(a, Z) {
                    X.push(Z)
                });
                D.topologicalTravel(X, D.getAllClassMainTypes(), function(a, Z) {
                    I(Y.get(a), function(b) {
                        b.restoreData()
                    })
                })
            }
        });

        function O(X, Y) {
            G.each(Y, function(a, Z) {
                if (!D.hasClass(Z)) {
                    if (typeof a === "object") {
                        X[Z] = !X[Z] ? G.clone(a) : G.merge(X[Z], a, false)
                    } else {
                        if (X[Z] == null) {
                            X[Z] = a
                        }
                    }
                }
            })
        }

        function W(X) {
            X = X;
            this.option = {};
            this.option[B] = 1;
            this._componentsMap = G.createHashMap({series: []});
            this._seriesIndices = null;
            O(X, this._theme.option);
            G.merge(X, J, false);
            this.mergeOption(X)
        }

        function R(Z, X) {
            if (!G.isArray(X)) {
                X = X ? [X] : []
            }
            var Y = {};
            I(X, function(a) {
                Y[a] = (Z.get(a) || []).slice()
            });
            return Y
        }

        function L(Y, X, Z) {
            var a = X.type ? X.type : Z ? Z.subType : D.determineSubType(Y, X);
            return a
        }

        function A(X) {
            return N(X, function(Y) {
                return Y.componentIndex
            }) || []
        }

        function F(X, Y) {
            return Y.hasOwnProperty("subType") ? K(X, function(Z) {
                return Z.subType === Y.subType
            }) : X
        }

        function C(X) {
            if (true) {
                if (!X._seriesIndices) {
                    throw new Error("Option should contains series.")
                }
            }
        }

        G.mixin(T, S(74));
        Q.exports = T
    }, function(m, t) {
        var v = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        };
        var s = {
            "[object Int8Array]": 1,
            "[object Uint8Array]": 1,
            "[object Uint8ClampedArray]": 1,
            "[object Int16Array]": 1,
            "[object Uint16Array]": 1,
            "[object Int32Array]": 1,
            "[object Uint32Array]": 1,
            "[object Float32Array]": 1,
            "[object Float64Array]": 1
        };
        var q = Object.prototype.toString;
        var f = Array.prototype;
        var I = f.forEach;
        var l = f.filter;
        var c = f.slice;
        var H = f.map;
        var o = f.reduce;

        function F(z) {
            if (z == null || typeof z != "object") {
                return z
            }
            var Ab = z;
            var y = q.call(z);
            if (y === "[object Array]") {
                Ab = [];
                for (var x = 0, Aa = z.length; x < Aa; x++) {
                    Ab[x] = F(z[x])
                }
            } else {
                if (s[y]) {
                    Ab = z.constructor.from(z)
                } else {
                    if (!v[y] && !T(z) && !u(z)) {
                        Ab = {};
                        for (var w in z) {
                            if (z.hasOwnProperty(w)) {
                                Ab[w] = F(z[w])
                            }
                        }
                    }
                }
            }
            return Ab
        }

        function p(z, x, y) {
            if (!W(x) || !W(z)) {
                return y ? F(x) : z
            }
            for (var w in x) {
                if (x.hasOwnProperty(w)) {
                    var Aa = z[w];
                    var Ab = x[w];
                    if (W(Ab) && W(Aa) && !b(Ab) && !b(Aa) && !u(Ab) && !u(Aa) && !L(Ab) && !L(Aa) && !T(Ab) && !T(Aa)) {
                        p(Aa, Ab, y)
                    } else {
                        if (y || !(w in z)) {
                            z[w] = F(x[w], true)
                        }
                    }
                }
            }
            return z
        }

        function A(y, Aa) {
            var x = y[0];
            for (var w = 1, z = y.length; w < z; w++) {
                x = p(x, y[w], Aa)
            }
            return x
        }

        function Z(y, x) {
            for (var w in x) {
                if (x.hasOwnProperty(w)) {
                    y[w] = x[w]
                }
            }
            return y
        }

        function P(z, x, y) {
            for (var w in x) {
                if (x.hasOwnProperty(w) && (y ? x[w] != null : z[w] == null)) {
                    z[w] = x[w]
                }
            }
            return z
        }

        function K() {
            return document.createElement("canvas")
        }

        var N;

        function j() {
            if (!N) {
                N = d.createCanvas().getContext("2d")
            }
            return N
        }

        function h(w, z) {
            if (w) {
                if (w.indexOf) {
                    return w.indexOf(z)
                }
                for (var x = 0, y = w.length; x < y; x++) {
                    if (w[x] === z) {
                        return x
                    }
                }
            }
            return -1
        }

        function e(z, y) {
            var w = z.prototype;

            function x() {
            }

            x.prototype = y.prototype;
            z.prototype = new x();
            for (var Aa in w) {
                z.prototype[Aa] = w[Aa]
            }
            z.prototype.constructor = z;
            z.superClass = y
        }

        function C(y, w, x) {
            y = "prototype" in y ? y.prototype : y;
            w = "prototype" in w ? w.prototype : w;
            P(y, w, x)
        }

        function a(w) {
            if (!w) {
                return
            }
            if (typeof w == "string") {
                return false
            }
            return typeof w.length == "number"
        }

        function Q(y, w, x) {
            if (!(y && w)) {
                return
            }
            if (y.forEach && y.forEach === I) {
                y.forEach(w, x)
            } else {
                if (y.length === +y.length) {
                    for (var z = 0, Aa = y.length; z < Aa; z++) {
                        w.call(x, y[z], z, y)
                    }
                } else {
                    for (var Ab in y) {
                        if (y.hasOwnProperty(Ab)) {
                            w.call(x, y[Ab], Ab, y)
                        }
                    }
                }
            }
        }

        function n(y, w, x) {
            if (!(y && w)) {
                return
            }
            if (y.map && y.map === H) {
                return y.map(w, x)
            } else {
                var z = [];
                for (var Aa = 0, Ab = y.length; Aa < Ab; Aa++) {
                    z.push(w.call(x, y[Aa], Aa, y))
                }
                return z
            }
        }

        function E(y, w, z, x) {
            if (!(y && w)) {
                return
            }
            if (y.reduce && y.reduce === o) {
                return y.reduce(w, z, x)
            } else {
                for (var Aa = 0, Ab = y.length; Aa < Ab; Aa++) {
                    z = w.call(x, z, y[Aa], Aa, y)
                }
                return z
            }
        }

        function X(y, w, x) {
            if (!(y && w)) {
                return
            }
            if (y.filter && y.filter === l) {
                return y.filter(w, x)
            } else {
                var z = [];
                for (var Aa = 0, Ab = y.length; Aa < Ab; Aa++) {
                    if (w.call(x, y[Aa], Aa, y)) {
                        z.push(y[Aa])
                    }
                }
                return z
            }
        }

        function Y(y, w, x) {
            if (!(y && w)) {
                return
            }
            for (var z = 0, Aa = y.length; z < Aa; z++) {
                if (w.call(x, y[z], z, y)) {
                    return y[z]
                }
            }
        }

        function R(x, w) {
            var y = c.call(arguments, 2);
            return function() {
                return x.apply(w, y.concat(c.call(arguments)))
            }
        }

        function M(w) {
            var x = c.call(arguments, 1);
            return function() {
                return w.apply(this, x.concat(c.call(arguments)))
            }
        }

        function b(w) {
            return q.call(w) === "[object Array]"
        }

        function B(w) {
            return typeof w === "function"
        }

        function U(w) {
            return q.call(w) === "[object String]"
        }

        function W(x) {
            var w = typeof x;
            return w === "function" || (!!x && w == "object")
        }

        function L(w) {
            return !!v[q.call(w)]
        }

        function u(w) {
            return typeof w === "object" && typeof w.nodeType === "number" && typeof w.ownerDocument === "object"
        }

        function O(w) {
            return w !== w
        }

        function g(y) {
            for (var w = 0, x = arguments.length; w < x; w++) {
                if (arguments[w] != null) {
                    return arguments[w]
                }
            }
        }

        function S() {
            return Function.call.apply(c, arguments)
        }

        function V(w, x) {
            if (!w) {
                throw new Error(x)
            }
        }

        var k = "__ec_primitive__";

        function i(w) {
            w[k] = true
        }

        function T(w) {
            return w[k]
        }

        function r(w) {
            w && Q(w, function(y, x) {
                this.set(x, y)
            }, this)
        }

        var G = "_ec_";
        var J = 4;
        r.prototype = {
            constructor: r, get: function(w) {
                return this[G + w]
            }, set: function(w, x) {
                this[G + w] = x;
                return x
            }, each: function(w, x) {
                x !== void 0 && (w = R(w, x));
                for (var y in this) {
                    this.hasOwnProperty(y) && w(this[y], y.slice(J))
                }
            }, removeKey: function(w) {
                delete this[w]
            }
        };

        function D(w) {
            return new r(w)
        }

        var d = {
            inherits: e,
            mixin: C,
            clone: F,
            merge: p,
            mergeAll: A,
            extend: Z,
            defaults: P,
            getContext: j,
            createCanvas: K,
            indexOf: h,
            slice: S,
            find: Y,
            isArrayLike: a,
            each: Q,
            map: n,
            reduce: E,
            filter: X,
            bind: R,
            curry: M,
            isArray: b,
            isString: U,
            isObject: W,
            isFunction: B,
            isBuiltInObject: L,
            isDom: u,
            eqNaN: O,
            retrieve: g,
            assert: V,
            setAsPrimitive: i,
            createHashMap: D,
            noop: function() {
            }
        };
        m.exports = d
    }, function(J, K, F) {
        var E = F(6);
        var C = F(7);
        var I = F(12);
        var D = F(4);
        var A = D.each;
        var B = D.isObject;
        var H = {};
        H.normalizeToArray = function(L) {
            return L instanceof Array ? L : L == null ? [] : [L]
        };
        H.defaultEmphasis = function(M, N) {
            if (M) {
                var O = M.emphasis = M.emphasis || {};
                var L = M.normal = M.normal || {};
                A(N, function(P) {
                    var Q = D.retrieve(O[P], L[P]);
                    if (Q != null) {
                        O[P] = Q
                    }
                })
            }
        };
        H.LABEL_OPTIONS = ["position", "offset", "show", "textStyle", "distance", "formatter"];
        H.getDataItemValue = function(L) {
            return L && (L.value == null ? L : L.value)
        };
        H.isDataItemOption = function(L) {
            return B(L) && !(L instanceof Array)
        };
        H.converDataValue = function(M, L) {
            var N = L && L.type;
            if (N === "ordinal") {
                return M
            }
            if (N === "time" && typeof M !== "number" && M != null && M !== "-") {
                M = +C.parseDate(M)
            }
            return (M == null || M === "") ? NaN : +M
        };
        H.createDataFormatModel = function(N, L) {
            var M = new I();
            D.mixin(M, H.dataFormatMixin);
            M.seriesIndex = L.seriesIndex;
            M.name = L.name || "";
            M.mainType = L.mainType;
            M.subType = L.subType;
            M.getData = function() {
                return N
            };
            return M
        };
        H.dataFormatMixin = {
            getDataParams: function(R, M) {
                var N = this.getData(M);
                var O = this.getRawValue(R, M);
                var P = N.getRawIndex(R);
                var S = N.getName(R, true);
                var Q = N.getRawDataItem(R);
                var L = N.getItemVisual(R, "color");
                return {
                    componentType: this.mainType,
                    componentSubType: this.subType,
                    seriesType: this.mainType === "series" ? this.subType : null,
                    seriesIndex: this.seriesIndex,
                    seriesId: this.id,
                    seriesName: this.name,
                    name: S,
                    dataIndex: P,
                    data: Q,
                    dataType: M,
                    value: O,
                    color: L,
                    marker: E.getTooltipMarker(L),
                    $vars: ["seriesName", "name", "value"]
                }
            }, getFormattedLabel: function(R, T, N, S, L) {
                T = T || "normal";
                var O = this.getData(N);
                var M = O.getItemModel(R);
                var Q = this.getDataParams(R, N);
                if (S != null && (Q.value instanceof Array)) {
                    Q.value = Q.value[S]
                }
                var P = M.get([L || "label", T, "formatter"]);
                if (typeof P === "function") {
                    Q.status = T;
                    return P(Q)
                } else {
                    if (typeof P === "string") {
                        return E.formatTpl(P, Q)
                    }
                }
            }, getRawValue: function(M, N) {
                var O = this.getData(N);
                var L = O.getRawDataItem(M);
                if (L != null) {
                    return (B(L) && !(L instanceof Array)) ? L.value : L
                }
            }, formatTooltip: D.noop
        };
        H.mappingToExists = function(M, N) {
            N = (N || []).slice();
            var L = D.map(M || [], function(O, P) {
                return {exist: O}
            });
            A(N, function(Q, P) {
                if (!B(Q)) {
                    return
                }
                for (var O = 0; O < L.length; O++) {
                    if (!L[O].option && Q.id != null && L[O].exist.id === Q.id + "") {
                        L[O].option = Q;
                        N[P] = null;
                        return
                    }
                }
                for (var O = 0; O < L.length; O++) {
                    var R = L[O].exist;
                    if (!L[O].option && (R.id == null || Q.id == null) && Q.name != null && !H.isIdInner(Q) && !H.isIdInner(R) && R.name === Q.name + "") {
                        L[O].option = Q;
                        N[P] = null;
                        return
                    }
                }
            });
            A(N, function(Q, P) {
                if (!B(Q)) {
                    return
                }
                var O = 0;
                for (; O < L.length; O++) {
                    var R = L[O].exist;
                    if (!L[O].option && !H.isIdInner(R) && Q.id == null) {
                        L[O].option = Q;
                        break
                    }
                }
                if (O >= L.length) {
                    L.push({option: Q})
                }
            });
            return L
        };
        H.makeIdAndName = function(L) {
            var M = D.createHashMap();
            A(L, function(N, O) {
                var P = N.exist;
                P && M.set(P.id, N)
            });
            A(L, function(O, P) {
                var N = O.option;
                D.assert(!N || N.id == null || !M.get(N.id) || M.get(N.id) === O, "id duplicates: " + (N && N.id));
                N && N.id != null && M.set(N.id, O);
                !O.keyInfo && (O.keyInfo = {})
            });
            A(L, function(P, R) {
                var S = P.exist;
                var O = P.option;
                var Q = P.keyInfo;
                if (!B(O)) {
                    return
                }
                Q.name = O.name != null ? O.name + "" : S ? S.name : "\0-";
                if (S) {
                    Q.id = S.id
                } else {
                    if (O.id != null) {
                        Q.id = O.id + ""
                    } else {
                        var N = 0;
                        do {
                            Q.id = "\0" + Q.name + "\0" + N++
                        } while (M.get(Q.id))
                    }
                }
                M.set(Q.id, P)
            })
        };
        H.isIdInner = function(L) {
            return B(L) && L.id && (L.id + "").indexOf("\0_ec_\0") === 0
        };
        H.compressBatches = function(N, P) {
            var Q = {};
            var O = {};
            M(N || [], Q);
            M(P || [], O, Q);
            return [L(Q), L(O)];

            function M(R, a, b) {
                for (var V = 0, Z = R.length; V < Z; V++) {
                    var T = R[V].seriesId;
                    var Y = H.normalizeToArray(R[V].dataIndex);
                    var U = b && b[T];
                    for (var W = 0, S = Y.length; W < S; W++) {
                        var X = Y[W];
                        if (U && U[X]) {
                            U[X] = null
                        } else {
                            (a[T] || (a[T] = {}))[X] = 1
                        }
                    }
                }
            }

            function L(S, R) {
                var T = [];
                for (var U in S) {
                    if (S.hasOwnProperty(U) && S[U] != null) {
                        if (R) {
                            T.push(+U)
                        } else {
                            var V = L(S[U], true);
                            V.length && T.push({seriesId: U, dataIndex: V})
                        }
                    }
                }
                return T
            }
        };
        H.queryDataIndex = function(M, L) {
            if (L.dataIndexInside != null) {
                return L.dataIndexInside
            } else {
                if (L.dataIndex != null) {
                    return D.isArray(L.dataIndex) ? D.map(L.dataIndex, function(N) {
                        return M.indexOfRawIndex(N)
                    }) : M.indexOfRawIndex(L.dataIndex)
                } else {
                    if (L.name != null) {
                        return D.isArray(L.name) ? D.map(L.name, function(N) {
                            return M.indexOfName(N)
                        }) : M.indexOfName(L.name)
                    }
                }
            }
        };
        H.makeGetter = (function() {
            var L = 0;
            return function() {
                var M = "\0__ec_prop_getter_" + L++;
                return function(N) {
                    return N[M] || (N[M] = {})
                }
            }
        })();
        H.parseFinder = function(M, Q, L) {
            if (D.isString(Q)) {
                var N = {};
                N[Q + "Index"] = 0;
                Q = N
            }
            var O = L && L.defaultMainType;
            if (O && !G(Q, O + "Index") && !G(Q, O + "Id") && !G(Q, O + "Name")) {
                Q[O + "Index"] = 0
            }
            var P = {};
            A(Q, function(X, R) {
                var X = Q[R];
                if (R === "dataIndex" || R === "dataIndexInside") {
                    P[R] = X;
                    return
                }
                var S = R.match(/^(\w+)(Index|Id|Name)$/) || [];
                var U = S[1];
                var V = (S[2] || "").toLowerCase();
                if (!U || !V || X == null || (V === "index" && X === "none") || (L && L.includeMainTypes && D.indexOf(L.includeMainTypes, U) < 0)) {
                    return
                }
                var W = {mainType: U};
                if (V !== "index" || X !== "all") {
                    W[V] = X
                }
                var T = M.queryComponents(W);
                P[U + "Models"] = T;
                P[U + "Model"] = T[0]
            });
            return P
        };
        H.dataDimToCoordDim = function(P, N) {
            var O = P.dimensions;
            N = P.getDimension(N);
            for (var L = 0; L < O.length; L++) {
                var M = P.getDimensionInfo(O[L]);
                if (M.name === N) {
                    return M.coordDim
                }
            }
        };
        H.coordDimToDataDim = function(N, M) {
            var L = [];
            A(N.dimensions, function(P) {
                var O = N.getDimensionInfo(P);
                if (O.coordDim === M) {
                    L[O.coordDimIndex] = O.name
                }
            });
            return L
        };
        H.otherDimToDataDim = function(N, M) {
            var L = [];
            A(N.dimensions, function(Q) {
                var P = N.getDimensionInfo(Q);
                var R = P.otherDims;
                var O = R[M];
                if (O != null && O !== false) {
                    L[O] = P.name
                }
            });
            return L
        };

        function G(L, M) {
            return L && L.hasOwnProperty(M)
        }

        J.exports = H
    }, function(I, K, B) {
        var A = B(4);
        var D = B(7);
        var F = B(8);
        var J = {};
        J.addCommas = function(L) {
            if (isNaN(L)) {
                return "-"
            }
            L = (L + "").split(".");
            return L[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (L.length > 1 ? ("." + L[1]) : "")
        };
        J.toCamelCase = function(M, L) {
            M = (M || "").toLowerCase().replace(/-(.)/g, function(N, O) {
                return O.toUpperCase()
            });
            if (L && M) {
                M = M.charAt(0).toUpperCase() + M.slice(1)
            }
            return M
        };
        J.normalizeCssArray = function(M) {
            var L = M.length;
            if (typeof(M) === "number") {
                return [M, M, M, M]
            } else {
                if (L === 2) {
                    return [M[0], M[1], M[0], M[1]]
                } else {
                    if (L === 3) {
                        return [M[0], M[1], M[2], M[1]]
                    }
                }
            }
            return M
        };
        var G = J.encodeHTML = function(L) {
            return String(L).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
        };
        var E = ["a", "b", "c", "d", "e", "f", "g"];
        var H = function(M, L) {
            return "{" + M + (L == null ? "" : L) + "}"
        };
        J.formatTpl = function(R, Q, M) {
            if (!A.isArray(Q)) {
                Q = [Q]
            }
            var S = Q.length;
            if (!S) {
                return ""
            }
            var T = Q[0].$vars || [];
            for (var N = 0; N < T.length; N++) {
                var U = E[N];
                var L = H(U, 0);
                R = R.replace(H(U), M ? G(L) : L)
            }
            for (var P = 0; P < S; P++) {
                for (var O = 0; O < T.length; O++) {
                    var L = Q[P][T[O]];
                    R = R.replace(H(E[O], P), M ? G(L) : L)
                }
            }
            return R
        };
        J.formatTplSimple = function(L, M, N) {
            A.each(M, function(P, O) {
                L = L.replace("{" + O + "}", N ? G(P) : P)
            });
            return L
        };
        J.getTooltipMarker = function(M, L) {
            return M ? '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + J.encodeHTML(M) + ";" + (L || "") + '"></span>' : ""
        };
        var C = function(L) {
            return L < 10 ? ("0" + L) : L
        };
        J.formatTime = function(T, P, V) {
            if (T === "week" || T === "month" || T === "quarter" || T === "half-year" || T === "year") {
                T = "MM-dd\nyyyy"
            }
            var W = D.parseDate(P);
            var R = V ? "UTC" : "";
            var U = W["get" + R + "FullYear"]();
            var O = W["get" + R + "Month"]() + 1;
            var N = W["get" + R + "Date"]();
            var Q = W["get" + R + "Hours"]();
            var S = W["get" + R + "Minutes"]();
            var L = W["get" + R + "Seconds"]();
            T = T.replace("MM", C(O)).toLowerCase().replace("yyyy", U).replace("yy", U % 100).replace("dd", C(N)).replace("d", N).replace("hh", C(Q)).replace("h", Q).replace("mm", C(S)).replace("m", S).replace("ss", C(L)).replace("s", L);
            return T
        };
        J.capitalFirst = function(L) {
            return L ? L.charAt(0).toUpperCase() + L.substr(1) : L
        };
        J.truncateText = F.truncateText;
        I.exports = J
    }, function(G, I, D) {
        var C = D(4);
        var A = {};
        var H = 0.0001;

        function B(J) {
            return J.replace(/^\s+/, "").replace(/\s+$/, "")
        }

        A.linearMap = function(M, O, N, L) {
            var K = O[1] - O[0];
            var J = N[1] - N[0];
            if (K === 0) {
                return J === 0 ? N[0] : (N[0] + N[1]) / 2
            }
            if (L) {
                if (K > 0) {
                    if (M <= O[0]) {
                        return N[0]
                    } else {
                        if (M >= O[1]) {
                            return N[1]
                        }
                    }
                } else {
                    if (M >= O[0]) {
                        return N[0]
                    } else {
                        if (M <= O[1]) {
                            return N[1]
                        }
                    }
                }
            } else {
                if (M === O[0]) {
                    return N[0]
                }
                if (M === O[1]) {
                    return N[1]
                }
            }
            return (M - O[0]) / K * J + N[0]
        };
        A.parsePercent = function(K, J) {
            switch (K) {
                case"center":
                case"middle":
                    K = "50%";
                    break;
                case"left":
                case"top":
                    K = "0%";
                    break;
                case"right":
                case"bottom":
                    K = "100%";
                    break
            }
            if (typeof K === "string") {
                if (B(K).match(/%$/)) {
                    return parseFloat(K) / 100 * J
                }
                return parseFloat(K)
            }
            return K == null ? NaN : +K
        };
        A.round = function(K, J, L) {
            if (J == null) {
                J = 10
            }
            J = Math.min(Math.max(0, J), 20);
            K = (+K).toFixed(J);
            return L ? K : +K
        };
        A.asc = function(J) {
            J.sort(function(L, K) {
                return L - K
            });
            return J
        };
        A.getPrecision = function(L) {
            L = +L;
            if (isNaN(L)) {
                return 0
            }
            var K = 1;
            var J = 0;
            while (Math.round(L * K) / K !== L) {
                K *= 10;
                J++
            }
            return J
        };
        A.getPrecisionSafe = function(N) {
            var M = N.toString();
            var L = M.indexOf("e");
            if (L > 0) {
                var J = +M.slice(L + 1);
                return J < 0 ? -J : 0
            } else {
                var K = M.indexOf(".");
                return K < 0 ? 0 : M.length - 1 - K
            }
        };
        A.getPixelPrecision = function(P, L) {
            var N = Math.log;
            var K = Math.LN10;
            var M = Math.floor(N(P[1] - P[0]) / K);
            var J = Math.round(N(Math.abs(L[1] - L[0])) / K);
            var O = Math.min(Math.max(-M + J, 0), 20);
            return !isFinite(O) ? 20 : O
        };
        A.getPercentWithPrecision = function(V, N, K) {
            if (!V[N]) {
                return 0
            }
            var P = C.reduce(V, function(Y, X) {
                return Y + (isNaN(X) ? 0 : X)
            }, 0);
            if (P === 0) {
                return 0
            }
            var O = Math.pow(10, K);
            var S = C.map(V, function(X) {
                return (isNaN(X) ? 0 : X) / P * O * 100
            });
            var R = O * 100;
            var M = C.map(S, function(X) {
                return Math.floor(X)
            });
            var U = C.reduce(M, function(Y, X) {
                return Y + X
            }, 0);
            var W = C.map(S, function(X, Y) {
                return X - M[Y]
            });
            while (U < R) {
                var L = Number.NEGATIVE_INFINITY;
                var J = null;
                for (var Q = 0, T = W.length; Q < T; ++Q) {
                    if (W[Q] > L) {
                        L = W[Q];
                        J = Q
                    }
                }
                ++M[J];
                W[J] = 0;
                ++U
            }
            return M[N] / O
        };
        A.MAX_SAFE_INTEGER = 9.00719925474099e+15;
        A.remRadian = function(K) {
            var J = Math.PI * 2;
            return (K % J + J) % J
        };
        A.isRadianAroundZero = function(J) {
            return J > -H && J < H
        };
        var F = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
        A.getTimezoneOffset = function() {
            return (new Date()).getTimezoneOffset()
        };
        A.parseDate = function(M) {
            if (M instanceof Date) {
                return M
            } else {
                if (typeof M === "string") {
                    var K = F.exec(M);
                    if (!K) {
                        return new Date(NaN)
                    }
                    var J = A.getTimezoneOffset();
                    var L = !K[8] ? 0 : K[8].toUpperCase() === "Z" ? J : +K[8].slice(0, 3) * 60 + J;
                    return new Date(+K[1], +(K[2] || 1) - 1, +K[3] || 1, +K[4] || 0, +(K[5] || 0) - L, +K[6] || 0, +K[7] || 0)
                } else {
                    if (M == null) {
                        return new Date(NaN)
                    }
                }
            }
            return new Date(Math.round(M))
        };
        A.quantity = function(J) {
            return Math.pow(10, E(J))
        };

        function E(J) {
            return Math.floor(Math.log(J) / Math.LN10)
        }

        A.nice = function(M, J) {
            var K = E(M);
            var N = Math.pow(10, K);
            var O = M / N;
            var L;
            if (J) {
                if (O < 1.5) {
                    L = 1
                } else {
                    if (O < 2.5) {
                        L = 2
                    } else {
                        if (O < 4) {
                            L = 3
                        } else {
                            if (O < 7) {
                                L = 5
                            } else {
                                L = 10
                            }
                        }
                    }
                }
            } else {
                if (O < 1) {
                    L = 1
                } else {
                    if (O < 2) {
                        L = 2
                    } else {
                        if (O < 3) {
                            L = 3
                        } else {
                            if (O < 5) {
                                L = 5
                            } else {
                                L = 10
                            }
                        }
                    }
                }
            }
            M = L * N;
            return K >= -20 ? +M.toFixed(K < 0 ? -K : 0) : M
        };
        A.reformIntervals = function(J) {
            J.sort(function(S, R) {
                return Q(S, R, 0) ? -1 : 1
            });
            var M = -Infinity;
            var P = 1;
            for (var L = 0; L < J.length;) {
                var N = J[L].interval;
                var K = J[L].close;
                for (var O = 0; O < 2; O++) {
                    if (N[O] <= M) {
                        N[O] = M;
                        K[O] = !O ? 1 - P : 1
                    }
                    M = N[O];
                    P = K[O]
                }
                if (N[0] === N[1] && K[0] * K[1] !== 1) {
                    J.splice(L, 1)
                } else {
                    L++
                }
            }
            return J;

            function Q(T, S, R) {
                return T.interval[R] < S.interval[R] || (T.interval[R] === S.interval[R] && ((T.close[R] - S.close[R] === (!R ? 1 : -1)) || (!R && Q(T, S, 1))))
            }
        };
        A.isNumeric = function(J) {
            return J - parseFloat(J) >= 0
        };
        G.exports = A
    }, function(N, O, F) {
        var G = {};
        var E = 0;
        var I = 5000;
        var M = F(4);
        var L = F(9);
        var J = M.retrieve;

        function D(T, V) {
            var P = T + ":" + V;
            if (G[P]) {
                return G[P]
            }
            var R = (T + "").split("\n");
            var Q = 0;
            for (var S = 0, U = R.length; S < U; S++) {
                Q = Math.max(K.measureText(R[S], V).width, Q)
            }
            if (E > I) {
                E = 0;
                G = {}
            }
            E++;
            G[P] = Q;
            return Q
        }

        function C(V, S, P, U) {
            var X = ((V || "") + "").split("\n").length;
            var W = D(V, S);
            var T = D("", S);
            var Q = X * T;
            var R = new L(0, 0, W, Q);
            R.lineHeight = T;
            switch (U) {
                case"bottom":
                case"alphabetic":
                    R.y -= T;
                    break;
                case"middle":
                    R.y -= T / 2;
                    break
            }
            switch (P) {
                case"end":
                case"right":
                    R.x -= R.width;
                    break;
                case"center":
                    R.x -= R.width / 2;
                    break
            }
            return R
        }

        function B(a, S, T, V) {
            var Y = S.x;
            var Z = S.y;
            var R = S.height;
            var X = S.width;
            var U = T.height;
            var W = T.lineHeight;
            var Q = R / 2 - U / 2 + W;
            var P = "left";
            switch (a) {
                case"left":
                    Y -= V;
                    Z += Q;
                    P = "right";
                    break;
                case"right":
                    Y += V + X;
                    Z += Q;
                    P = "left";
                    break;
                case"top":
                    Y += X / 2;
                    Z -= V + U - W;
                    P = "center";
                    break;
                case"bottom":
                    Y += X / 2;
                    Z += R + V + W;
                    P = "center";
                    break;
                case"inside":
                    Y += X / 2;
                    Z += Q;
                    P = "center";
                    break;
                case"insideLeft":
                    Y += V;
                    Z += Q;
                    P = "left";
                    break;
                case"insideRight":
                    Y += X - V;
                    Z += Q;
                    P = "right";
                    break;
                case"insideTop":
                    Y += X / 2;
                    Z += V + W;
                    P = "center";
                    break;
                case"insideBottom":
                    Y += X / 2;
                    Z += R - U - V + W;
                    P = "center";
                    break;
                case"insideTopLeft":
                    Y += V;
                    Z += V + W;
                    P = "left";
                    break;
                case"insideTopRight":
                    Y += X - V;
                    Z += V + W;
                    P = "right";
                    break;
                case"insideBottomLeft":
                    Y += V;
                    Z += R - U - V + W;
                    break;
                case"insideBottomRight":
                    Y += X - V;
                    Z += R - U - V + W;
                    P = "right";
                    break
            }
            return {x: Y, y: Z, textAlign: P, textBaseline: "alphabetic"}
        }

        function A(W, g, f, X, c) {
            if (!g) {
                return ""
            }
            c = c || {};
            X = J(X, "...");
            var d = J(c.maxIterations, 2);
            var Y = J(c.minChar, 0);
            var a = D("", f);
            var S = D("a", f);
            var Z = J(c.placeholder, "");
            var e = g = Math.max(0, g - 1);
            for (var T = 0; T < Y && e >= S; T++) {
                e -= S
            }
            var b = D(X);
            if (b > e) {
                X = "";
                b = 0
            }
            e = g - b;
            var h = (W + "").split("\n");
            for (var T = 0, P = h.length; T < P; T++) {
                var R = h[T];
                var U = D(R, f);
                if (U <= g) {
                    continue
                }
                for (var V = 0; ; V++) {
                    if (U <= e || V >= d) {
                        R += X;
                        break
                    }
                    var Q = V === 0 ? H(R, e, S, a) : U > 0 ? Math.floor(R.length * e / U) : 0;
                    R = R.substr(0, Q);
                    U = D(R, f)
                }
                if (R === "") {
                    R = Z
                }
                h[T] = R
            }
            return h.join("\n")
        }

        function H(T, W, P, S) {
            var U = 0;
            var R = 0;
            for (var V = T.length; R < V && U < W; R++) {
                var Q = T.charCodeAt(R);
                U += (0 <= Q && Q <= 127) ? P : S
            }
            return R
        }

        var K = {
            getWidth: D, getBoundingRect: C, adjustTextPositionOnRect: B, truncateText: A, measureText: function(P, Q) {
                var R = M.getContext();
                R.font = Q || "12px sans-serif";
                return R.measureText(P)
            }
        };
        N.exports = K
    }, function(H, I, C) {
        var D = C(10);
        var E = C(11);
        var F = D.applyTransform;
        var B = Math.min;
        var A = Math.max;

        function G(K, L, M, J) {
            if (M < 0) {
                K = K + M;
                M = -M
            }
            if (J < 0) {
                L = L + J;
                J = -J
            }
            this.x = K;
            this.y = L;
            this.width = M;
            this.height = J
        }

        G.prototype = {
            constructor: G, union: function(L) {
                var J = B(L.x, this.x);
                var K = B(L.y, this.y);
                this.width = A(L.x + L.width, this.x + this.width) - J;
                this.height = A(L.y + L.height, this.y + this.height) - K;
                this.x = J;
                this.y = K
            }, applyTransform: (function() {
                var K = [];
                var L = [];
                var M = [];
                var J = [];
                return function(P) {
                    if (!P) {
                        return
                    }
                    K[0] = M[0] = this.x;
                    K[1] = J[1] = this.y;
                    L[0] = J[0] = this.x + this.width;
                    L[1] = M[1] = this.y + this.height;
                    F(K, K, P);
                    F(L, L, P);
                    F(M, M, P);
                    F(J, J, P);
                    this.x = B(K[0], L[0], M[0], J[0]);
                    this.y = B(K[1], L[1], M[1], J[1]);
                    var O = A(K[0], L[0], M[0], J[0]);
                    var N = A(K[1], L[1], M[1], J[1]);
                    this.width = O - this.x;
                    this.height = N - this.y
                }
            })(), calculateTransform: function(K) {
                var N = this;
                var J = K.width / N.width;
                var L = K.height / N.height;
                var M = E.create();
                E.translate(M, M, [-N.x, -N.y]);
                E.scale(M, M, [J, L]);
                E.translate(M, M, [K.x, K.y]);
                return M
            }, intersect: function(P) {
                if (!P) {
                    return false
                }
                if (!(P instanceof G)) {
                    P = G.create(P)
                }
                var S = this;
                var M = S.x;
                var L = S.x + S.width;
                var K = S.y;
                var J = S.y + S.height;
                var Q = P.x;
                var R = P.x + P.width;
                var N = P.y;
                var O = P.y + P.height;
                return !(L < Q || R < M || J < N || O < K)
            }, contain: function(K, L) {
                var J = this;
                return K >= J.x && K <= (J.x + J.width) && L >= J.y && L <= (J.y + J.height)
            }, clone: function() {
                return new G(this.x, this.y, this.width, this.height)
            }, copy: function(J) {
                this.x = J.x;
                this.y = J.y;
                this.width = J.width;
                this.height = J.height
            }, plain: function() {
                return {x: this.x, y: this.y, width: this.width, height: this.height}
            }
        };
        G.create = function(J) {
            return new G(J.x, J.y, J.width, J.height)
        };
        H.exports = G
    }, function(B, D) {
        var A = typeof Float32Array === "undefined" ? Array : Float32Array;
        var C = {
            create: function(F, G) {
                var E = new A(2);
                if (F == null) {
                    F = 0
                }
                if (G == null) {
                    G = 0
                }
                E[0] = F;
                E[1] = G;
                return E
            }, copy: function(E, F) {
                E[0] = F[0];
                E[1] = F[1];
                return E
            }, clone: function(E) {
                var F = new A(2);
                F[0] = E[0];
                F[1] = E[1];
                return F
            }, set: function(E, G, F) {
                E[0] = G;
                E[1] = F;
                return E
            }, add: function(E, F, G) {
                E[0] = F[0] + G[0];
                E[1] = F[1] + G[1];
                return E
            }, scaleAndAdd: function(E, F, H, G) {
                E[0] = F[0] + H[0] * G;
                E[1] = F[1] + H[1] * G;
                return E
            }, sub: function(E, F, G) {
                E[0] = F[0] - G[0];
                E[1] = F[1] - G[1];
                return E
            }, len: function(E) {
                return Math.sqrt(this.lenSquare(E))
            }, lenSquare: function(E) {
                return E[0] * E[0] + E[1] * E[1]
            }, mul: function(E, F, G) {
                E[0] = F[0] * G[0];
                E[1] = F[1] * G[1];
                return E
            }, div: function(E, F, G) {
                E[0] = F[0] / G[0];
                E[1] = F[1] / G[1];
                return E
            }, dot: function(E, F) {
                return E[0] * F[0] + E[1] * F[1]
            }, scale: function(F, G, E) {
                F[0] = G[0] * E;
                F[1] = G[1] * E;
                return F
            }, normalize: function(F, G) {
                var E = C.len(G);
                if (E === 0) {
                    F[0] = 0;
                    F[1] = 0
                } else {
                    F[0] = G[0] / E;
                    F[1] = G[1] / E
                }
                return F
            }, distance: function(E, F) {
                return Math.sqrt((E[0] - F[0]) * (E[0] - F[0]) + (E[1] - F[1]) * (E[1] - F[1]))
            }, distanceSquare: function(E, F) {
                return (E[0] - F[0]) * (E[0] - F[0]) + (E[1] - F[1]) * (E[1] - F[1])
            }, negate: function(E, F) {
                E[0] = -F[0];
                E[1] = -F[1];
                return E
            }, lerp: function(E, F, H, G) {
                E[0] = F[0] + G * (H[0] - F[0]);
                E[1] = F[1] + G * (H[1] - F[1]);
                return E
            }, applyTransform: function(E, F, G) {
                var H = F[0];
                var I = F[1];
                E[0] = G[0] * H + G[2] * I + G[4];
                E[1] = G[1] * H + G[3] * I + G[5];
                return E
            }, min: function(E, F, G) {
                E[0] = Math.min(F[0], G[0]);
                E[1] = Math.min(F[1], G[1]);
                return E
            }, max: function(E, F, G) {
                E[0] = Math.max(F[0], G[0]);
                E[1] = Math.max(F[1], G[1]);
                return E
            }
        };
        C.length = C.len;
        C.lengthSquare = C.lenSquare;
        C.dist = C.distance;
        C.distSquare = C.distanceSquare;
        B.exports = C
    }, function(C, D) {
        var B = typeof Float32Array === "undefined" ? Array : Float32Array;
        var A = {
            create: function() {
                var E = new B(6);
                A.identity(E);
                return E
            }, identity: function(E) {
                E[0] = 1;
                E[1] = 0;
                E[2] = 0;
                E[3] = 1;
                E[4] = 0;
                E[5] = 0;
                return E
            }, copy: function(E, F) {
                E[0] = F[0];
                E[1] = F[1];
                E[2] = F[2];
                E[3] = F[3];
                E[4] = F[4];
                E[5] = F[5];
                return E
            }, mul: function(E, F, G) {
                var M = F[0] * G[0] + F[2] * G[1];
                var H = F[1] * G[0] + F[3] * G[1];
                var I = F[0] * G[2] + F[2] * G[3];
                var L = F[1] * G[2] + F[3] * G[3];
                var K = F[0] * G[4] + F[2] * G[5] + F[4];
                var J = F[1] * G[4] + F[3] * G[5] + F[5];
                E[0] = M;
                E[1] = H;
                E[2] = I;
                E[3] = L;
                E[4] = K;
                E[5] = J;
                return E
            }, translate: function(E, G, F) {
                E[0] = G[0];
                E[1] = G[1];
                E[2] = G[2];
                E[3] = G[3];
                E[4] = G[4] + F[0];
                E[5] = G[5] + F[1];
                return E
            }, rotate: function(F, M, J) {
                var G = M[0];
                var L = M[2];
                var O = M[4];
                var H = M[1];
                var E = M[3];
                var N = M[5];
                var I = Math.sin(J);
                var K = Math.cos(J);
                F[0] = G * K + H * I;
                F[1] = -G * I + H * K;
                F[2] = L * K + E * I;
                F[3] = -L * I + K * E;
                F[4] = K * O + I * N;
                F[5] = K * N - I * O;
                return F
            }, scale: function(E, H, F) {
                var G = F[0];
                var I = F[1];
                E[0] = H[0] * G;
                E[1] = H[1] * I;
                E[2] = H[2] * G;
                E[3] = H[3] * I;
                E[4] = H[4] * G;
                E[5] = H[5] * I;
                return E
            }, invert: function(F, K) {
                var G = K[0];
                var J = K[2];
                var M = K[4];
                var H = K[1];
                var E = K[3];
                var L = K[5];
                var I = G * E - H * J;
                if (!I) {
                    return null
                }
                I = 1 / I;
                F[0] = E * I;
                F[1] = -H * I;
                F[2] = -J * I;
                F[3] = G * I;
                F[4] = (J * L - E * M) * I;
                F[5] = (H * M - G * L) * I;
                return F
            }
        };
        C.exports = A
    }, function(H, J, B) {
        var A = B(4);
        var F = B(13);
        var D = B(2);

        function G(K, M, L) {
            this.parentModel = M;
            this.ecModel = L;
            this.option = K
        }

        G.prototype = {
            constructor: G, init: null, mergeOption: function(K) {
                A.merge(this.option, K, true)
            }, get: function(L, K) {
                if (L == null) {
                    return this.option
                }
                return C(this.option, this.parsePath(L), !K && I(this, L))
            }, getShallow: function(K, N) {
                var L = this.option;
                var M = L == null ? L : L[K];
                var O = !N && I(this, K);
                if (M == null && O) {
                    M = O.getShallow(K)
                }
                return M
            }, getModel: function(N, M) {
                var K = N == null ? this.option : C(this.option, N = this.parsePath(N));
                var L;
                M = M || ((L = I(this, N)) && L.getModel(N));
                return new G(K, M, this.ecModel)
            }, isEmpty: function() {
                return this.option == null
            }, restoreData: function() {
            }, clone: function() {
                var K = this.constructor;
                return new K(A.clone(this.option))
            }, setReadOnly: function(K) {
                F.setReadOnly(this, K)
            }, parsePath: function(K) {
                if (typeof K === "string") {
                    K = K.split(".")
                }
                return K
            }, customizeGetParent: function(K) {
                F.set(this, "getParent", K)
            }, isAnimationEnabled: function() {
                if (!D.node) {
                    if (this.option.animation != null) {
                        return !!this.option.animation
                    } else {
                        if (this.parentModel) {
                            return this.parentModel.isAnimationEnabled()
                        }
                    }
                }
            }
        };

        function C(L, M, N) {
            for (var K = 0; K < M.length; K++) {
                if (!M[K]) {
                    continue
                }
                L = (L && typeof L === "object") ? L[M[K]] : null;
                if (L == null) {
                    break
                }
            }
            if (L == null && N) {
                L = N.get(M)
            }
            return L
        }

        function I(L, M) {
            var K = F.get(L, "getParent");
            return K ? K.call(L, M) : L.parentModel
        }

        F.enableClassExtend(G);
        var E = A.mixin;
        E(G, B(14));
        E(G, B(16));
        E(G, B(17));
        E(G, B(68));
        H.exports = G
    }, function(K, L, E) {
        var D = E(4);
        var H = {};
        var C = ".";
        var B = "___EC__COMPONENT__CONTAINER___";
        var J = "\0ec_\0";
        H.set = function(M, N, O) {
            return (M[J + N] = O)
        };
        H.get = function(M, N) {
            return M[J + N]
        };
        H.hasOwn = function(M, N) {
            return M.hasOwnProperty(J + N)
        };
        var F = H.parseClassType = function(M) {
            var N = {main: "", sub: ""};
            if (M) {
                M = M.split(C);
                N.main = M[0] || "";
                N.sub = M[1] || ""
            }
            return N
        };

        function G(M) {
            D.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(M), 'componentType "' + M + '" illegal')
        }

        H.enableClassExtend = function(N, M) {
            N.$constructor = N;
            N.extend = function(P) {
                if (true) {
                    D.each(M, function(R) {
                        if (!P[R]) {
                            console.warn("Method `" + R + "` should be implemented" + (P.type ? " in " + P.type : "") + ".")
                        }
                    })
                }
                var O = this;
                var Q = function() {
                    if (!P.$constructor) {
                        O.apply(this, arguments)
                    } else {
                        P.$constructor.apply(this, arguments)
                    }
                };
                D.extend(Q.prototype, P);
                Q.extend = this.extend;
                Q.superCall = I;
                Q.superApply = A;
                D.inherits(Q, this);
                Q.superClass = O;
                return Q
            }
        };

        function I(M, N) {
            var O = D.slice(arguments, 2);
            return this.superClass.prototype[N].apply(M, O)
        }

        function A(M, N, O) {
            return this.superClass.prototype[N].apply(M, O)
        }

        H.enableClassManagement = function(Q, O) {
            O = O || {};
            var M = {};
            Q.registerClass = function(T, R) {
                if (R) {
                    G(R);
                    R = F(R);
                    if (!R.sub) {
                        if (true) {
                            if (M[R.main]) {
                                console.warn(R.main + " exists.")
                            }
                        }
                        M[R.main] = T
                    } else {
                        if (R.sub !== B) {
                            var S = P(R);
                            S[R.sub] = T
                        }
                    }
                }
                return T
            };
            Q.getClass = function(S, U, R) {
                var T = M[S];
                if (T && T[B]) {
                    T = U ? T[U] : null
                }
                if (R && !T) {
                    throw new Error(!U ? S + ".type should be specified." : "Component " + S + "." + (U || "") + " not exists. Load it first.")
                }
                return T
            };
            Q.getClassesByMainType = function(S) {
                S = F(S);
                var T = [];
                var R = M[S.main];
                if (R && R[B]) {
                    D.each(R, function(V, U) {
                        U !== B && T.push(V)
                    })
                } else {
                    T.push(R)
                }
                return T
            };
            Q.hasClass = function(R) {
                R = F(R);
                return !!M[R.main]
            };
            Q.getAllClassMainTypes = function() {
                var R = [];
                D.each(M, function(T, S) {
                    R.push(S)
                });
                return R
            };
            Q.hasSubTypes = function(S) {
                S = F(S);
                var R = M[S.main];
                return R && R[B]
            };
            Q.parseClassType = F;

            function P(R) {
                var S = M[R.main];
                if (!S || !S[B]) {
                    S = M[R.main] = {};
                    S[B] = true
                }
                return S
            }

            if (O.registerWhenExtend) {
                var N = Q.extend;
                if (N) {
                    Q.extend = function(R) {
                        var S = N.call(this, R);
                        return Q.registerClass(S, R.type)
                    }
                }
            }
            return Q
        };
        H.setReadOnly = function(M, N) {
        };
        K.exports = H
    }, function(C, D, B) {
        var A = B(15)([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
        C.exports = {
            getLineStyle: function(F) {
                var E = A.call(this, F);
                var G = this.getLineDash(E.lineWidth);
                G && (E.lineDash = G);
                return E
            }, getLineDash: function(H) {
                if (H == null) {
                    H = 1
                }
                var F = this.get("type");
                var G = Math.max(H, 2);
                var E = H * 4;
                return (F === "solid" || F == null) ? null : (F === "dashed" ? [E, E] : [G, G])
            }
        }
    }, function(C, D, B) {
        var A = B(4);
        C.exports = function(F) {
            for (var E = 0; E < F.length; E++) {
                if (!F[E][1]) {
                    F[E][1] = F[E][0]
                }
            }
            return function(J, H) {
                var I = {};
                for (var G = 0; G < F.length; G++) {
                    var L = F[G][1];
                    if ((J && A.indexOf(J, L) >= 0) || (H && A.indexOf(H, L) < 0)) {
                        continue
                    }
                    var K = this.getShallow(L);
                    if (K != null) {
                        I[F[G][0]] = K
                    }
                }
                return I
            }
        }
    }, function(B, C, A) {
        B.exports = {getAreaStyle: A(15)([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]])}
    }, function(C, E, B) {
        var D = B(8);
        var A = B(18);
        C.exports = {
            getTextColor: function() {
                var F = this.ecModel;
                return this.getShallow("color") || (F && F.get("textStyle.color"))
            }, getFont: function() {
                return A.getFont({
                    fontStyle: this.getShallow("fontStyle"),
                    fontWeight: this.getShallow("fontWeight"),
                    fontSize: this.getShallow("fontSize"),
                    fontFamily: this.getShallow("fontFamily")
                }, this.ecModel)
            }, getTextRect: function(F) {
                return D.getBoundingRect(F, this.getFont(), this.getShallow("align"), this.getShallow("baseline"))
            }, truncateText: function(H, G, I, F) {
                return D.truncateText(H, G, this.getFont(), I, F)
            }
        }
    }, function(T, M, W) {
        var K = W(4);
        var F = W(19);
        var Z = W(20);
        var E = W(31);
        var N = W(11);
        var R = W(10);
        var H = W(26);
        var U = W(9);
        var B = Math.round;
        var b = Math.max;
        var X = Math.min;
        var O = {};
        O.Group = W(48);
        O.Image = W(49);
        O.Text = W(50);
        O.Circle = W(51);
        O.Sector = W(52);
        O.Ring = W(53);
        O.Polygon = W(54);
        O.Polyline = W(58);
        O.Rect = W(59);
        O.Line = W(61);
        O.BezierCurve = W(62);
        O.Arc = W(63);
        O.CompoundPath = W(64);
        O.LinearGradient = W(65);
        O.RadialGradient = W(67);
        O.BoundingRect = U;
        O.extendShape = function(c) {
            return Z.extend(c)
        };
        O.extendPath = function(d, c) {
            return F.extendFromString(d, c)
        };
        O.makePath = function(i, k, d, j) {
            var l = F.createFromString(i, k);
            var g = l.getBoundingRect();
            if (d) {
                var f = g.width / g.height;
                if (j === "center") {
                    var m = d.height * f;
                    var c;
                    if (m <= d.width) {
                        c = d.height
                    } else {
                        m = d.width;
                        c = m / f
                    }
                    var e = d.x + d.width / 2;
                    var h = d.y + d.height / 2;
                    d.x = e - m / 2;
                    d.y = h - c / 2;
                    d.width = m;
                    d.height = c
                }
                O.resizePath(l, d)
            }
            return l
        };
        O.mergePath = F.mergePath, O.resizePath = function(f, c) {
            if (!f.applyTransform) {
                return
            }
            var e = f.getBoundingRect();
            var d = e.calculateTransform(c);
            f.applyTransform(d)
        };
        O.subPixelOptimizeLine = function(c) {
            var e = O.subPixelOptimize;
            var f = c.shape;
            var d = c.style.lineWidth;
            if (B(f.x1 * 2) === B(f.x2 * 2)) {
                f.x1 = f.x2 = e(f.x1, d, true)
            }
            if (B(f.y1 * 2) === B(f.y2 * 2)) {
                f.y1 = f.y2 = e(f.y1, d, true)
            }
            return c
        };
        O.subPixelOptimizeRect = function(e) {
            var j = O.subPixelOptimize;
            var d = e.shape;
            var f = e.style.lineWidth;
            var h = d.x;
            var g = d.y;
            var c = d.width;
            var i = d.height;
            d.x = j(d.x, f, true);
            d.y = j(d.y, f, true);
            d.width = Math.max(j(h + c, f, false) - d.x, c === 0 ? 0 : 1);
            d.height = Math.max(j(g + i, f, false) - d.y, i === 0 ? 0 : 1);
            return e
        };
        O.subPixelOptimize = function(d, e, f) {
            var c = B(d * 2);
            return (c + B(e)) % 2 === 0 ? c / 2 : (c + (f ? 1 : -1)) / 2
        };

        function Y(c) {
            return c != null && c != "none"
        }

        function S(c) {
            return typeof c === "string" ? E.lift(c, -0.1) : c
        }

        function V(c) {
            if (c.__hoverStlDirty) {
                var d = c.style.stroke;
                var g = c.style.fill;
                var h = c.__hoverStl;
                h.fill = h.fill || (Y(g) ? S(g) : null);
                h.stroke = h.stroke || (Y(d) ? S(d) : null);
                var f = {};
                for (var e in h) {
                    if (h.hasOwnProperty(e)) {
                        f[e] = c.style[e]
                    }
                }
                c.__normalStl = f;
                c.__hoverStlDirty = false
            }
        }

        function D(c) {
            if (c.__isHover) {
                return
            }
            V(c);
            if (c.useHoverLayer) {
                c.__zr && c.__zr.addHover(c, c.__hoverStl)
            } else {
                c.setStyle(c.__hoverStl);
                c.z2 += 1
            }
            c.__isHover = true
        }

        function a(c) {
            if (!c.__isHover) {
                return
            }
            var d = c.__normalStl;
            if (c.useHoverLayer) {
                c.__zr && c.__zr.removeHover(c)
            } else {
                d && c.setStyle(d);
                c.z2 -= 1
            }
            c.__isHover = false
        }

        function I(c) {
            c.type === "group" ? c.traverse(function(d) {
                if (d.type !== "group") {
                    D(d)
                }
            }) : D(c)
        }

        function A(c) {
            c.type === "group" ? c.traverse(function(d) {
                if (d.type !== "group") {
                    a(d)
                }
            }) : a(c)
        }

        function P(c, d) {
            c.__hoverStl = c.hoverStyle || d || {};
            c.__hoverStlDirty = true;
            if (c.__isHover) {
                V(c)
            }
        }

        function C(c) {
            if (this.__hoverSilentOnTouch && c.zrByTouch) {
                return
            }
            !this.__isEmphasis && I(this)
        }

        function G(c) {
            if (this.__hoverSilentOnTouch && c.zrByTouch) {
                return
            }
            !this.__isEmphasis && A(this)
        }

        function L() {
            this.__isEmphasis = true;
            I(this)
        }

        function J() {
            this.__isEmphasis = false;
            A(this)
        }

        O.setHoverStyle = function(c, e, d) {
            c.__hoverSilentOnTouch = d && d.hoverSilentOnTouch;
            c.type === "group" ? c.traverse(function(f) {
                if (f.type !== "group") {
                    P(f, e)
                }
            }) : P(c, e);
            c.on("mouseover", C).on("mouseout", G);
            c.on("emphasis", L).on("normal", J)
        };
        O.setText = function(g, d, h) {
            var f = d.getShallow("position") || "inside";
            var i = d.getShallow("offset");
            var e = f.indexOf("inside") >= 0 ? "white" : h;
            var c = d.getModel("textStyle");
            K.extend(g, {
                textDistance: d.getShallow("distance") || 5,
                textFont: c.getFont(),
                textPosition: f,
                textOffset: i,
                textFill: c.getTextColor() || e
            })
        };
        O.getFont = function(d, e) {
            var c = e && e.getModel("textStyle");
            return [d.fontStyle || c && c.getShallow("fontStyle") || "", d.fontWeight || c && c.getShallow("fontWeight") || "", (d.fontSize || c && c.getShallow("fontSize") || 12) + "px", d.fontFamily || c && c.getShallow("fontFamily") || "sans-serif"].join(" ")
        };

        function Q(m, k, j, i, l, f) {
            if (typeof l === "function") {
                f = l;
                l = null
            }
            var e = i && i.isAnimationEnabled();
            if (e) {
                var g = m ? "Update" : "";
                var c = i.getShallow("animationDuration" + g);
                var d = i.getShallow("animationEasing" + g);
                var h = i.getShallow("animationDelay" + g);
                if (typeof h === "function") {
                    h = h(l, i.getAnimationDelayParams ? i.getAnimationDelayParams(k, l) : null)
                }
                if (typeof c === "function") {
                    c = c(l)
                }
                c > 0 ? k.animateTo(j, c, h || 0, d, f) : (k.stopAnimation(), k.attr(j), f && f())
            } else {
                k.stopAnimation();
                k.attr(j);
                f && f()
            }
        }

        O.updateProps = function(c, f, g, d, e) {
            Q(true, c, f, g, d, e)
        };
        O.initProps = function(c, f, g, d, e) {
            Q(false, c, f, g, d, e)
        };
        O.getTransform = function(d, c) {
            var e = N.identity([]);
            while (d && d !== c) {
                N.mul(e, d.getLocalTransform(), e);
                d = d.parent
            }
            return e
        };
        O.applyTransform = function(c, e, d) {
            if (e && !K.isArrayLike(e)) {
                e = H.getLocalTransform(e)
            }
            if (d) {
                e = N.invert([], e)
            }
            return R.applyTransform([], c, e)
        };
        O.transformDirection = function(g, h, e) {
            var f = (h[4] === 0 || h[5] === 0 || h[0] === 0) ? 1 : Math.abs(2 * h[4] / h[0]);
            var c = (h[4] === 0 || h[5] === 0 || h[2] === 0) ? 1 : Math.abs(2 * h[4] / h[2]);
            var d = [g === "left" ? -f : g === "right" ? f : 0, g === "top" ? -c : g === "bottom" ? c : 0];
            d = O.applyTransform(d, h, e);
            return Math.abs(d[0]) > Math.abs(d[1]) ? (d[0] > 0 ? "right" : "left") : (d[1] > 0 ? "bottom" : "top")
        };
        O.groupTransition = function(d, f, i, c) {
            if (!d || !f) {
                return
            }

            function h(j) {
                var k = {};
                j.traverse(function(l) {
                    if (!l.isGroup && l.anid) {
                        k[l.anid] = l
                    }
                });
                return k
            }

            function e(j) {
                var k = {position: R.clone(j.position), rotation: j.rotation};
                if (j.shape) {
                    k.shape = K.extend({}, j.shape)
                }
                return k
            }

            var g = h(d);
            f.traverse(function(j) {
                if (!j.isGroup && j.anid) {
                    var l = g[j.anid];
                    if (l) {
                        var k = e(j);
                        j.attr(e(l));
                        O.updateProps(j, k, i, j.dataIndex)
                    }
                }
            })
        };
        O.clipPointsByRect = function(d, c) {
            return K.map(d, function(e) {
                var f = e[0];
                f = b(f, c.x);
                f = X(f, c.x + c.width);
                var g = e[1];
                g = b(g, c.y);
                g = X(g, c.y + c.height);
                return [f, g]
            })
        };
        O.clipRectByRect = function(g, e) {
            var f = b(g.x, e.x);
            var c = X(g.x + g.width, e.x + e.width);
            var h = b(g.y, e.y);
            var d = X(g.y + g.height, e.y + e.height);
            if (c >= f && d >= h) {
                return {x: f, y: h, width: c - f, height: d - h}
            }
        };
        T.exports = O
    }, function(L, D, O) {
        var P = O(20);
        var Q = O(36);
        var M = O(47);
        var K = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
        var A = Math.sqrt;
        var H = Math.sin;
        var N = Math.cos;
        var F = Math.PI;
        var C = function(R) {
            return Math.sqrt(R[0] * R[0] + R[1] * R[1])
        };
        var J = function(S, R) {
            return (S[0] * R[0] + S[1] * R[1]) / (C(S) * C(R))
        };
        var B = function(S, R) {
            return (S[0] * R[1] < S[1] * R[0] ? -1 : 1) * Math.acos(J(S, R))
        };

        function G(m, U, o, p, S, a, n, X, W, e, c) {
            var d = W * (F / 180);
            var Y = N(d) * (m - o) / 2 + H(d) * (U - p) / 2;
            var Z = -1 * H(d) * (m - o) / 2 + N(d) * (U - p) / 2;
            var l = (Y * Y) / (n * n) + (Z * Z) / (X * X);
            if (l > 1) {
                n *= A(l);
                X *= A(l)
            }
            var b = (S === a ? -1 : 1) * A((((n * n) * (X * X)) - ((n * n) * (Z * Z)) - ((X * X) * (Y * Y))) / ((n * n) * (Z * Z) + (X * X) * (Y * Y))) || 0;
            var h = b * n * Z / X;
            var R = b * -X * Y / n;
            var g = (m + o) / 2 + N(d) * h - H(d) * R;
            var j = (U + p) / 2 + H(d) * h + N(d) * R;
            var i = B([1, 0], [(Y - h) / n, (Z - R) / X]);
            var V = [(Y - h) / n, (Z - R) / X];
            var T = [(-1 * Y - h) / n, (-1 * Z - R) / X];
            var k = B(V, T);
            if (J(V, T) <= -1) {
                k = F
            }
            if (J(V, T) >= 1) {
                k = 0
            }
            if (a === 0 && k > 0) {
                k = k - 2 * F
            }
            if (a === 1 && k < 0) {
                k = k + 2 * F
            }
            c.addData(e, g, j, n, X, i, k, d, a)
        }

        function E(t) {
            if (!t) {
                return []
            }
            var a = t.replace(/-/g, " -").replace(/  /g, " ").replace(/ /g, ",").replace(/,,/g, ",");
            var Z;
            for (Z = 0; Z < K.length; Z++) {
                a = a.replace(new RegExp(K[Z], "g"), "|" + K[Z])
            }
            var m = a.split("|");
            var S = 0;
            var q = 0;
            var f = new Q();
            var o = Q.CMD;
            var b;
            for (Z = 1; Z < m.length; Z++) {
                var R = m[Z];
                var d = R.charAt(0);
                var h = 0;
                var T = R.slice(1).replace(/e,-/g, "e-").split(",");
                var j;
                if (T.length > 0 && T[0] === "") {
                    T.shift()
                }
                for (var Y = 0; Y < T.length; Y++) {
                    T[Y] = parseFloat(T[Y])
                }
                while (h < T.length && !isNaN(T[h])) {
                    if (isNaN(T[0])) {
                        break
                    }
                    var r;
                    var X;
                    var u;
                    var s;
                    var g;
                    var U;
                    var e;
                    var V = S;
                    var W = q;
                    switch (d) {
                        case"l":
                            S += T[h++];
                            q += T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"L":
                            S = T[h++];
                            q = T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"m":
                            S += T[h++];
                            q += T[h++];
                            j = o.M;
                            f.addData(j, S, q);
                            d = "l";
                            break;
                        case"M":
                            S = T[h++];
                            q = T[h++];
                            j = o.M;
                            f.addData(j, S, q);
                            d = "L";
                            break;
                        case"h":
                            S += T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"H":
                            S = T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"v":
                            q += T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"V":
                            q = T[h++];
                            j = o.L;
                            f.addData(j, S, q);
                            break;
                        case"C":
                            j = o.C;
                            f.addData(j, T[h++], T[h++], T[h++], T[h++], T[h++], T[h++]);
                            S = T[h - 2];
                            q = T[h - 1];
                            break;
                        case"c":
                            j = o.C;
                            f.addData(j, T[h++] + S, T[h++] + q, T[h++] + S, T[h++] + q, T[h++] + S, T[h++] + q);
                            S += T[h - 2];
                            q += T[h - 1];
                            break;
                        case"S":
                            r = S;
                            X = q;
                            var l = f.len();
                            var k = f.data;
                            if (b === o.C) {
                                r += S - k[l - 4];
                                X += q - k[l - 3]
                            }
                            j = o.C;
                            V = T[h++];
                            W = T[h++];
                            S = T[h++];
                            q = T[h++];
                            f.addData(j, r, X, V, W, S, q);
                            break;
                        case"s":
                            r = S;
                            X = q;
                            var l = f.len();
                            var k = f.data;
                            if (b === o.C) {
                                r += S - k[l - 4];
                                X += q - k[l - 3]
                            }
                            j = o.C;
                            V = S + T[h++];
                            W = q + T[h++];
                            S += T[h++];
                            q += T[h++];
                            f.addData(j, r, X, V, W, S, q);
                            break;
                        case"Q":
                            V = T[h++];
                            W = T[h++];
                            S = T[h++];
                            q = T[h++];
                            j = o.Q;
                            f.addData(j, V, W, S, q);
                            break;
                        case"q":
                            V = T[h++] + S;
                            W = T[h++] + q;
                            S += T[h++];
                            q += T[h++];
                            j = o.Q;
                            f.addData(j, V, W, S, q);
                            break;
                        case"T":
                            r = S;
                            X = q;
                            var l = f.len();
                            var k = f.data;
                            if (b === o.Q) {
                                r += S - k[l - 4];
                                X += q - k[l - 3]
                            }
                            S = T[h++];
                            q = T[h++];
                            j = o.Q;
                            f.addData(j, r, X, S, q);
                            break;
                        case"t":
                            r = S;
                            X = q;
                            var l = f.len();
                            var k = f.data;
                            if (b === o.Q) {
                                r += S - k[l - 4];
                                X += q - k[l - 3]
                            }
                            S += T[h++];
                            q += T[h++];
                            j = o.Q;
                            f.addData(j, r, X, S, q);
                            break;
                        case"A":
                            u = T[h++];
                            s = T[h++];
                            g = T[h++];
                            U = T[h++];
                            e = T[h++];
                            V = S, W = q;
                            S = T[h++];
                            q = T[h++];
                            j = o.A;
                            G(V, W, S, q, U, e, u, s, g, j, f);
                            break;
                        case"a":
                            u = T[h++];
                            s = T[h++];
                            g = T[h++];
                            U = T[h++];
                            e = T[h++];
                            V = S, W = q;
                            S += T[h++];
                            q += T[h++];
                            j = o.A;
                            G(V, W, S, q, U, e, u, s, g, j, f);
                            break
                    }
                }
                if (d === "z" || d === "Z") {
                    j = o.Z;
                    f.addData(j)
                }
                b = j
            }
            f.toStatic();
            return f
        }

        function I(T, R) {
            var S = E(T);
            R = R || {};
            R.buildPath = function(V) {
                if (V.setData) {
                    V.setData(S.data);
                    var U = V.getContext();
                    if (U) {
                        V.rebuildPath(U)
                    }
                } else {
                    var U = V;
                    S.rebuildPath(U)
                }
            };
            R.applyTransform = function(U) {
                M(S, U);
                this.dirty(true)
            };
            return R
        }

        L.exports = {
            createFromString: function(S, R) {
                return new P(I(S, R))
            }, extendFromString: function(S, R) {
                return P.extend(I(S, R))
            }, mergePath: function(U, T) {
                var R = [];
                var V = U.length;
                for (var S = 0; S < V; S++) {
                    var W = U[S];
                    if (!W.path) {
                        W.createPathProxy()
                    }
                    if (W.__dirtyPath) {
                        W.buildPath(W.path, W.shape, true)
                    }
                    R.push(W.path)
                }
                var X = new P(T);
                X.createPathProxy();
                X.buildPath = function(Z) {
                    Z.appendPath(R);
                    var Y = Z.getContext();
                    if (Y) {
                        Z.rebuildPath(Y)
                    }
                };
                return X
            }
        }
    }, function(K, L, D) {
        var F = D(21);
        var C = D(4);
        var J = D(36);
        var B = D(39);
        var A = D(46);
        var H = A.prototype.getCanvasPattern;
        var I = Math.abs;
        var G = new J(true);

        function E(M) {
            F.call(this, M);
            this.path = null
        }

        E.prototype = {
            constructor: E, type: "path", __dirtyPath: true, strokeContainThreshold: 5, brush: function(S, O) {
                var b = this.style;
                var V = this.path || G;
                var Y = b.hasStroke();
                var M = b.hasFill();
                var a = b.fill;
                var W = b.stroke;
                var N = M && !!(a.colorStops);
                var X = Y && !!(W.colorStops);
                var Q = M && !!(a.image);
                var c = Y && !!(W.image);
                b.bind(S, this, O);
                this.setTransform(S);
                if (this.__dirty) {
                    var U;
                    if (N) {
                        U = U || this.getBoundingRect();
                        this._fillGradient = b.getGradient(S, a, U)
                    }
                    if (X) {
                        U = U || this.getBoundingRect();
                        this._strokeGradient = b.getGradient(S, W, U)
                    }
                }
                if (N) {
                    S.fillStyle = this._fillGradient
                } else {
                    if (Q) {
                        S.fillStyle = H.call(a, S)
                    }
                }
                if (X) {
                    S.strokeStyle = this._strokeGradient
                } else {
                    if (c) {
                        S.strokeStyle = H.call(W, S)
                    }
                }
                var R = b.lineDash;
                var Z = b.lineDashOffset;
                var T = !!S.setLineDash;
                var P = this.getGlobalScale();
                V.setScale(P[0], P[1]);
                if (this.__dirtyPath || (R && !T && Y)) {
                    V.beginPath(S);
                    if (R && !T) {
                        V.setLineDash(R);
                        V.setLineDashOffset(Z)
                    }
                    this.buildPath(V, this.shape, false);
                    if (this.path) {
                        this.__dirtyPath = false
                    }
                } else {
                    S.beginPath();
                    this.path.rebuildPath(S)
                }
                M && V.fill(S);
                if (R && T) {
                    S.setLineDash(R);
                    S.lineDashOffset = Z
                }
                Y && V.stroke(S);
                if (R && T) {
                    S.setLineDash([])
                }
                this.restoreTransform(S);
                if (b.text != null) {
                    this.drawRectText(S, this.getBoundingRect())
                }
            }, buildPath: function(O, N, M) {
            }, createPathProxy: function() {
                this.path = new J()
            }, getBoundingRect: function() {
                var O = this._rect;
                var P = this.style;
                var M = !O;
                if (M) {
                    var S = this.path;
                    if (!S) {
                        S = this.path = new J()
                    }
                    if (this.__dirtyPath) {
                        S.beginPath();
                        this.buildPath(S, this.shape, false)
                    }
                    O = S.getBoundingRect()
                }
                this._rect = O;
                if (P.hasStroke()) {
                    var R = this._rectWithStroke || (this._rectWithStroke = O.clone());
                    if (this.__dirty || M) {
                        R.copy(O);
                        var Q = P.lineWidth;
                        var N = P.strokeNoScale ? this.getLineScale() : 1;
                        if (!P.hasFill()) {
                            Q = Math.max(Q, this.strokeContainThreshold || 4)
                        }
                        if (N > 1e-10) {
                            R.width += Q / N;
                            R.height += Q / N;
                            R.x -= Q / N / 2;
                            R.y -= Q / N / 2
                        }
                    }
                    return R
                }
                return O
            }, contain: function(R, S) {
                var T = this.transformCoordToLocal(R, S);
                var M = this.getBoundingRect();
                var P = this.style;
                R = T[0];
                S = T[1];
                if (M.contain(R, S)) {
                    var O = this.path.data;
                    if (P.hasStroke()) {
                        var Q = P.lineWidth;
                        var N = P.strokeNoScale ? this.getLineScale() : 1;
                        if (N > 1e-10) {
                            if (!P.hasFill()) {
                                Q = Math.max(Q, this.strokeContainThreshold)
                            }
                            if (B.containStroke(O, Q / N, R, S)) {
                                return true
                            }
                        }
                    }
                    if (P.hasFill()) {
                        return B.contain(O, R, S)
                    }
                }
                return false
            }, dirty: function(M) {
                if (M == null) {
                    M = true
                }
                if (M) {
                    this.__dirtyPath = M;
                    this._rect = null
                }
                this.__dirty = true;
                this.__zr && this.__zr.refresh();
                if (this.__clipTarget) {
                    this.__clipTarget.dirty()
                }
            }, animateShape: function(M) {
                return this.animate("shape", M)
            }, attrKV: function(M, N) {
                if (M === "shape") {
                    this.setShape(N);
                    this.__dirtyPath = true;
                    this._rect = null
                } else {
                    F.prototype.attrKV.call(this, M, N)
                }
            }, setShape: function(M, O) {
                var P = this.shape;
                if (P) {
                    if (C.isObject(M)) {
                        for (var N in M) {
                            if (M.hasOwnProperty(N)) {
                                P[N] = M[N]
                            }
                        }
                    } else {
                        P[M] = O
                    }
                    this.dirty(true)
                }
                return this
            }, getLineScale: function() {
                var M = this.transform;
                return M && I(M[0] - 1) > 1e-10 && I(M[3] - 1) > 1e-10 ? Math.sqrt(I(M[0] * M[3] - M[2] * M[1])) : 1
            }
        };
        E.extend = function(O) {
            var M = function(Q) {
                E.call(this, Q);
                if (O.style) {
                    this.style.extendFrom(O.style, false)
                }
                var P = O.shape;
                if (P) {
                    this.shape = this.shape || {};
                    var R = this.shape;
                    for (var S in P) {
                        if (!R.hasOwnProperty(S) && P.hasOwnProperty(S)) {
                            R[S] = P[S]
                        }
                    }
                }
                O.init && O.init.call(this, Q)
            };
            C.inherits(M, E);
            for (var N in O) {
                if (N !== "style" && N !== "shape") {
                    M.prototype[N] = O[N]
                }
            }
            return M
        };
        C.inherits(E, F);
        K.exports = E
    }, function(F, H, D) {
        var C = D(4);
        var E = D(22);
        var A = D(23);
        var B = D(35);

        function G(I) {
            I = I || {};
            A.call(this, I);
            for (var J in I) {
                if (I.hasOwnProperty(J) && J !== "style") {
                    this[J] = I[J]
                }
            }
            this.style = new E(I.style);
            this._rect = null;
            this.__clipPaths = []
        }

        G.prototype = {
            constructor: G,
            type: "displayable",
            __dirty: true,
            invisible: false,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: false,
            dragging: false,
            silent: false,
            culling: false,
            cursor: "pointer",
            rectHover: false,
            progressive: -1,
            beforeBrush: function(I) {
            },
            afterBrush: function(I) {
            },
            brush: function(I, J) {
            },
            getBoundingRect: function() {
            },
            contain: function(I, J) {
                return this.rectContain(I, J)
            },
            traverse: function(I, J) {
                I.call(J, this)
            },
            rectContain: function(J, K) {
                var L = this.transformCoordToLocal(J, K);
                var I = this.getBoundingRect();
                return I.contain(L[0], L[1])
            },
            dirty: function() {
                this.__dirty = true;
                this._rect = null;
                this.__zr && this.__zr.refresh()
            },
            animateStyle: function(I) {
                return this.animate("style", I)
            },
            attrKV: function(I, J) {
                if (I !== "style") {
                    A.prototype.attrKV.call(this, I, J)
                } else {
                    this.style.set(J)
                }
            },
            setStyle: function(I, J) {
                this.style.set(I, J);
                this.dirty(false);
                return this
            },
            useStyle: function(I) {
                this.style = new E(I);
                this.dirty(false);
                return this
            }
        };
        C.inherits(G, A);
        C.mixin(G, B);
        F.exports = G
    }, function(H, I) {
        var B = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
        var E = function(J) {
            this.extendFrom(J)
        };

        function D(N, O, J) {
            var P = O.x == null ? 0 : O.x;
            var L = O.x2 == null ? 1 : O.x2;
            var Q = O.y == null ? 0 : O.y;
            var M = O.y2 == null ? 0 : O.y2;
            if (!O.global) {
                P = P * J.width + J.x;
                L = L * J.width + J.x;
                Q = Q * J.height + J.y;
                M = M * J.height + J.y
            }
            var K = N.createLinearGradient(P, Q, L, M);
            return K
        }

        function F(N, P, L) {
            var O = L.width;
            var K = L.height;
            var S = Math.min(O, K);
            var Q = P.x == null ? 0.5 : P.x;
            var R = P.y == null ? 0.5 : P.y;
            var J = P.r == null ? 0.5 : P.r;
            if (!P.global) {
                Q = Q * O + L.x;
                R = R * K + L.y;
                J = J * S
            }
            var M = N.createRadialGradient(Q, R, 0, Q, R, J);
            return M
        }

        E.prototype = {
            constructor: E,
            fill: "#000000",
            stroke: null,
            opacity: 1,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: false,
            text: null,
            textFill: "#000",
            textStroke: null,
            textPosition: "inside",
            textPositionRect: null,
            textOffset: null,
            textBaseline: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            textTransform: false,
            textRotation: 0,
            blend: null,
            bind: function(N, R, Q) {
                var O = this;
                var M = Q && Q.style;
                var K = !M;
                for (var P = 0; P < B.length; P++) {
                    var L = B[P];
                    var J = L[0];
                    if (K || O[J] !== M[J]) {
                        N[J] = O[J] || L[1]
                    }
                }
                if ((K || O.fill !== M.fill)) {
                    N.fillStyle = O.fill
                }
                if ((K || O.stroke !== M.stroke)) {
                    N.strokeStyle = O.stroke
                }
                if ((K || O.opacity !== M.opacity)) {
                    N.globalAlpha = O.opacity == null ? 1 : O.opacity
                }
                if ((K || O.blend !== M.blend)) {
                    N.globalCompositeOperation = O.blend || "source-over"
                }
                if (this.hasStroke()) {
                    var S = O.lineWidth;
                    N.lineWidth = S / ((this.strokeNoScale && R && R.getLineScale) ? R.getLineScale() : 1)
                }
            },
            hasFill: function() {
                var J = this.fill;
                return J != null && J !== "none"
            },
            hasStroke: function() {
                var J = this.stroke;
                return J != null && J !== "none" && this.lineWidth > 0
            },
            extendFrom: function(K, J) {
                if (K) {
                    var M = this;
                    for (var L in K) {
                        if (K.hasOwnProperty(L) && (J || !M.hasOwnProperty(L))) {
                            M[L] = K[L]
                        }
                    }
                }
            },
            set: function(J, K) {
                if (typeof J === "string") {
                    this[J] = K
                } else {
                    this.extendFrom(J, true)
                }
            },
            clone: function() {
                var J = new this.constructor();
                J.extendFrom(this, true);
                return J
            },
            getGradient: function(N, K, L) {
                var M = K.type === "radial" ? F : D;
                var P = M(N, K, L);
                var O = K.colorStops;
                for (var J = 0; J < O.length; J++) {
                    P.addColorStop(O[J].offset, O[J].color)
                }
                return P
            }
        };
        var C = E.prototype;
        for (var G = 0; G < B.length; G++) {
            var A = B[G];
            if (!(A[0] in C)) {
                C[A[0]] = A[1]
            }
        }
        E.getGradient = C.getGradient;
        H.exports = E
    }, function(H, I, D) {
        var F = D(24);
        var E = D(25);
        var B = D(26);
        var G = D(27);
        var C = D(4);
        var A = function(J) {
            B.call(this, J);
            E.call(this, J);
            G.call(this, J);
            this.id = J.id || F()
        };
        A.prototype = {
            type: "element", name: "", __zr: null, ignore: false, clipPath: null, drift: function(J, L) {
                switch (this.draggable) {
                    case"horizontal":
                        L = 0;
                        break;
                    case"vertical":
                        J = 0;
                        break
                }
                var K = this.transform;
                if (!K) {
                    K = this.transform = [1, 0, 0, 1, 0, 0]
                }
                K[4] += J;
                K[5] += L;
                this.decomposeTransform();
                this.dirty(false)
            }, beforeUpdate: function() {
            }, afterUpdate: function() {
            }, update: function() {
                this.updateTransform()
            }, traverse: function(J, K) {
            }, attrKV: function(J, K) {
                if (J === "position" || J === "scale" || J === "origin") {
                    if (K) {
                        var L = this[J];
                        if (!L) {
                            L = this[J] = []
                        }
                        L[0] = K[0];
                        L[1] = K[1]
                    }
                } else {
                    this[J] = K
                }
            }, hide: function() {
                this.ignore = true;
                this.__zr && this.__zr.refresh()
            }, show: function() {
                this.ignore = false;
                this.__zr && this.__zr.refresh()
            }, attr: function(J, L) {
                if (typeof J === "string") {
                    this.attrKV(J, L)
                } else {
                    if (C.isObject(J)) {
                        for (var K in J) {
                            if (J.hasOwnProperty(K)) {
                                this.attrKV(K, J[K])
                            }
                        }
                    }
                }
                this.dirty(false);
                return this
            }, setClipPath: function(K) {
                var J = this.__zr;
                if (J) {
                    K.addSelfToZr(J)
                }
                if (this.clipPath && this.clipPath !== K) {
                    this.removeClipPath()
                }
                this.clipPath = K;
                K.__zr = J;
                K.__clipTarget = this;
                this.dirty(false)
            }, removeClipPath: function() {
                var J = this.clipPath;
                if (J) {
                    if (J.__zr) {
                        J.removeSelfFromZr(J.__zr)
                    }
                    J.__zr = null;
                    J.__clipTarget = null;
                    this.clipPath = null;
                    this.dirty(false)
                }
            }, addSelfToZr: function(J) {
                this.__zr = J;
                var L = this.animators;
                if (L) {
                    for (var K = 0; K < L.length; K++) {
                        J.animation.addAnimator(L[K])
                    }
                }
                if (this.clipPath) {
                    this.clipPath.addSelfToZr(J)
                }
            }, removeSelfFromZr: function(J) {
                this.__zr = null;
                var L = this.animators;
                if (L) {
                    for (var K = 0; K < L.length; K++) {
                        J.animation.removeAnimator(L[K])
                    }
                }
                if (this.clipPath) {
                    this.clipPath.removeSelfFromZr(J)
                }
            }
        };
        C.mixin(A, G);
        C.mixin(A, B);
        C.mixin(A, E);
        H.exports = A
    }, function(B, C) {
        var A = 2311;
        B.exports = function() {
            return A++
        }
    }, function(B, D) {
        var C = Array.prototype.slice;
        var A = function() {
            this._$handlers = {}
        };
        A.prototype = {
            constructor: A, one: function(H, G, E) {
                var I = this._$handlers;
                if (!G || !H) {
                    return this
                }
                if (!I[H]) {
                    I[H] = []
                }
                for (var F = 0; F < I[H].length; F++) {
                    if (I[H][F].h === G) {
                        return this
                    }
                }
                I[H].push({h: G, one: true, ctx: E || this});
                return this
            }, on: function(H, G, E) {
                var I = this._$handlers;
                if (!G || !H) {
                    return this
                }
                if (!I[H]) {
                    I[H] = []
                }
                for (var F = 0; F < I[H].length; F++) {
                    if (I[H][F].h === G) {
                        return this
                    }
                }
                I[H].push({h: G, one: false, ctx: E || this});
                return this
            }, isSilent: function(E) {
                var F = this._$handlers;
                return F[E] && F[E].length
            }, off: function(I, G) {
                var J = this._$handlers;
                if (!I) {
                    this._$handlers = {};
                    return this
                }
                if (G) {
                    if (J[I]) {
                        var E = [];
                        for (var F = 0, H = J[I].length; F < H; F++) {
                            if (J[I][F]["h"] != G) {
                                E.push(J[I][F])
                            }
                        }
                        J[I] = E
                    }
                    if (J[I] && J[I].length === 0) {
                        delete J[I]
                    }
                } else {
                    delete J[I]
                }
                return this
            }, trigger: function(E) {
                if (this._$handlers[E]) {
                    var J = arguments;
                    var G = J.length;
                    if (G > 3) {
                        J = C.call(J, 1)
                    }
                    var I = this._$handlers[E];
                    var H = I.length;
                    for (var F = 0; F < H;) {
                        switch (G) {
                            case 1:
                                I[F]["h"].call(I[F]["ctx"]);
                                break;
                            case 2:
                                I[F]["h"].call(I[F]["ctx"], J[1]);
                                break;
                            case 3:
                                I[F]["h"].call(I[F]["ctx"], J[1], J[2]);
                                break;
                            default:
                                I[F]["h"].apply(I[F]["ctx"], J);
                                break
                        }
                        if (I[F]["one"]) {
                            I.splice(F, 1);
                            H--
                        } else {
                            F++
                        }
                    }
                }
                return this
            }, triggerWithContext: function(E) {
                if (this._$handlers[E]) {
                    var K = arguments;
                    var G = K.length;
                    if (G > 4) {
                        K = C.call(K, 1, K.length - 1)
                    }
                    var I = K[K.length - 1];
                    var J = this._$handlers[E];
                    var H = J.length;
                    for (var F = 0; F < H;) {
                        switch (G) {
                            case 1:
                                J[F]["h"].call(I);
                                break;
                            case 2:
                                J[F]["h"].call(I, K[1]);
                                break;
                            case 3:
                                J[F]["h"].call(I, K[1], K[2]);
                                break;
                            default:
                                J[F]["h"].apply(I, K);
                                break
                        }
                        if (J[F]["one"]) {
                            J.splice(F, 1);
                            H--
                        } else {
                            F++
                        }
                    }
                }
                return this
            }
        };
        B.exports = A
    }, function(J, K, D) {
        var F = D(11);
        var C = D(10);
        var I = F.identity;
        var H = 5e-05;

        function G(L) {
            return L > H || L < -H
        }

        var B = function(L) {
            L = L || {};
            if (!L.position) {
                this.position = [0, 0]
            }
            if (L.rotation == null) {
                this.rotation = 0
            }
            if (!L.scale) {
                this.scale = [1, 1]
            }
            this.origin = this.origin || null
        };
        var E = B.prototype;
        E.transform = null;
        E.needLocalTransform = function() {
            return G(this.rotation) || G(this.position[0]) || G(this.position[1]) || G(this.scale[0] - 1) || G(this.scale[1] - 1)
        };
        E.updateTransform = function() {
            var O = this.parent;
            var L = O && O.transform;
            var M = this.needLocalTransform();
            var N = this.transform;
            if (!(M || L)) {
                N && I(N);
                return
            }
            N = N || F.create();
            if (M) {
                this.getLocalTransform(N)
            } else {
                I(N)
            }
            if (L) {
                if (M) {
                    F.mul(N, O.transform, N)
                } else {
                    F.copy(N, O.transform)
                }
            }
            this.transform = N;
            this.invTransform = this.invTransform || F.create();
            F.invert(this.invTransform, N)
        };
        E.getLocalTransform = function(L) {
            return B.getLocalTransform(this, L)
        };
        E.setTransform = function(M) {
            var L = this.transform;
            var N = M.dpr || 1;
            if (L) {
                M.setTransform(N * L[0], N * L[1], N * L[2], N * L[3], N * L[4], N * L[5])
            } else {
                M.setTransform(N, 0, 0, N, 0, 0)
            }
        };
        E.restoreTransform = function(L) {
            var M = L.dpr || 1;
            L.setTransform(M, 0, 0, M, 0, 0)
        };
        var A = [];
        E.decomposeTransform = function() {
            if (!this.transform) {
                return
            }
            var Q = this.parent;
            var O = this.transform;
            if (Q && Q.transform) {
                F.mul(A, Q.invTransform, O);
                O = A
            }
            var N = O[0] * O[0] + O[1] * O[1];
            var P = O[2] * O[2] + O[3] * O[3];
            var L = this.position;
            var M = this.scale;
            if (G(N - 1)) {
                N = Math.sqrt(N)
            }
            if (G(P - 1)) {
                P = Math.sqrt(P)
            }
            if (O[0] < 0) {
                N = -N
            }
            if (O[3] < 0) {
                P = -P
            }
            L[0] = O[4];
            L[1] = O[5];
            M[0] = N;
            M[1] = P;
            this.rotation = Math.atan2(-O[1] / P, O[0] / N)
        };
        E.getGlobalScale = function() {
            var M = this.transform;
            if (!M) {
                return [1, 1]
            }
            var L = Math.sqrt(M[0] * M[0] + M[1] * M[1]);
            var N = Math.sqrt(M[2] * M[2] + M[3] * M[3]);
            if (M[0] < 0) {
                L = -L
            }
            if (M[3] < 0) {
                N = -N
            }
            return [L, N]
        };
        E.transformCoordToLocal = function(L, M) {
            var O = [L, M];
            var N = this.invTransform;
            if (N) {
                C.applyTransform(O, O, N)
            }
            return O
        };
        E.transformCoordToGlobal = function(M, N) {
            var O = [M, N];
            var L = this.transform;
            if (L) {
                C.applyTransform(O, O, L)
            }
            return O
        };
        B.getLocalTransform = function(Q, O) {
            O = O || [];
            I(O);
            var M = Q.origin;
            var N = Q.scale || [1, 1];
            var P = Q.rotation || 0;
            var L = Q.position || [0, 0];
            if (M) {
                O[4] -= M[0];
                O[5] -= M[1]
            }
            F.scale(O, O, N);
            if (P) {
                F.rotate(O, O, P)
            }
            if (M) {
                O[4] += M[0];
                O[5] += M[1]
            }
            O[4] += L[0];
            O[5] += L[1];
            return O
        };
        J.exports = B
    }, function(I, J, D) {
        var E = D(28);
        var H = D(4);
        var F = H.isString;
        var C = H.isFunction;
        var B = H.isObject;
        var A = D(33);
        var G = function() {
            this.animators = []
        };
        G.prototype = {
            constructor: G, animate: function(S, V) {
                var T;
                var N = false;
                var P = this;
                var L = this.__zr;
                if (S) {
                    var K = S.split(".");
                    var O = P;
                    N = K[0] === "shape";
                    for (var Q = 0, R = K.length; Q < R; Q++) {
                        if (!O) {
                            continue
                        }
                        O = O[K[Q]]
                    }
                    if (O) {
                        T = O
                    }
                } else {
                    T = P
                }
                if (!T) {
                    A('Property "' + S + '" is not existed in element ' + P.id);
                    return
                }
                var M = P.animators;
                var U = new E(T, V);
                U.during(function(W) {
                    P.dirty(N)
                }).done(function() {
                    M.splice(H.indexOf(M, U), 1)
                });
                M.push(U);
                if (L) {
                    L.animation.addAnimator(U)
                }
                return U
            }, stopAnimation: function(L) {
                var M = this.animators;
                var N = M.length;
                for (var K = 0; K < N; K++) {
                    M[K].stop(L)
                }
                M.length = 0;
                return this
            }, animateTo: function(R, K, N, Q, L) {
                if (F(N)) {
                    L = Q;
                    Q = N;
                    N = 0
                } else {
                    if (C(Q)) {
                        L = Q;
                        Q = "linear";
                        N = 0
                    } else {
                        if (C(N)) {
                            L = N;
                            N = 0
                        } else {
                            if (C(K)) {
                                L = K;
                                K = 500
                            } else {
                                if (!K) {
                                    K = 500
                                }
                            }
                        }
                    }
                }
                this.stopAnimation();
                this._animateToShallow("", this, R, K, N, Q, L);
                var M = this.animators.slice();
                var S = M.length;

                function O() {
                    S--;
                    if (!S) {
                        L && L()
                    }
                }

                if (!S) {
                    L && L()
                }
                for (var P = 0; P < M.length; P++) {
                    M[P].done(O).start(Q)
                }
            }, _animateToShallow: function(P, L, Q, K, N) {
                var S = {};
                var M = 0;
                for (var R in Q) {
                    if (!Q.hasOwnProperty(R)) {
                        continue
                    }
                    if (L[R] != null) {
                        if (B(Q[R]) && !H.isArrayLike(Q[R])) {
                            this._animateToShallow(P ? P + "." + R : R, L[R], Q[R], K, N)
                        } else {
                            S[R] = Q[R];
                            M++
                        }
                    } else {
                        if (Q[R] != null) {
                            if (!P) {
                                this.attr(R, Q[R])
                            } else {
                                var O = {};
                                O[P] = {};
                                O[P][R] = Q[R];
                                this.attr(O)
                            }
                        }
                    }
                }
                if (M > 0) {
                    this.animate(P, false).when(K == null ? 500 : K, S).delay(N || 0)
                }
                return this
            }
        };
        I.exports = G
    }, function(Q, G, J) {
        var R = J(29);
        var D = J(31);
        var N = J(4);
        var V = N.isArrayLike;
        var P = Array.prototype.slice;

        function T(X, W) {
            return X[W]
        }

        function F(Y, W, X) {
            Y[W] = X
        }

        function L(X, Y, W) {
            return (Y - X) * W + X
        }

        function A(X, Y, W) {
            return W > 0.5 ? Y : X
        }

        function I(c, b, Z, X, e) {
            var d = c.length;
            if (e == 1) {
                for (var a = 0; a < d; a++) {
                    X[a] = L(c[a], b[a], Z)
                }
            } else {
                var W = d && c[0].length;
                for (var a = 0; a < d; a++) {
                    for (var Y = 0; Y < W; Y++) {
                        X[a][Y] = L(c[a][Y], b[a][Y], Z)
                    }
                }
            }
        }

        function S(d, Z, e) {
            var b = d.length;
            var a = Z.length;
            if (b !== a) {
                var c = b > a;
                if (c) {
                    d.length = a
                } else {
                    for (var Y = b; Y < a; Y++) {
                        d.push(e === 1 ? Z[Y] : P.call(Z[Y]))
                    }
                }
            }
            var X = d[0] && d[0].length;
            for (var Y = 0; Y < d.length; Y++) {
                if (e === 1) {
                    if (isNaN(d[Y])) {
                        d[Y] = Z[Y]
                    }
                } else {
                    for (var W = 0; W < X; W++) {
                        if (isNaN(d[Y][W])) {
                            d[Y][W] = Z[Y][W]
                        }
                    }
                }
            }
        }

        function M(Y, a, Z) {
            if (Y === a) {
                return true
            }
            var b = Y.length;
            if (b !== a.length) {
                return false
            }
            if (Z === 1) {
                for (var X = 0; X < b; X++) {
                    if (Y[X] !== a[X]) {
                        return false
                    }
                }
            } else {
                var W = Y[0].length;
                for (var X = 0; X < b; X++) {
                    for (var c = 0; c < W; c++) {
                        if (Y[X][c] !== a[X][c]) {
                            return false
                        }
                    }
                }
            }
            return true
        }

        function C(b, X, e, d, Z, h, f, Y, k) {
            var g = b.length;
            if (k == 1) {
                for (var c = 0; c < g; c++) {
                    Y[c] = K(b[c], X[c], e[c], d[c], Z, h, f)
                }
            } else {
                var W = b[0].length;
                for (var c = 0; c < g; c++) {
                    for (var a = 0; a < W; a++) {
                        Y[c][a] = K(b[c][a], X[c][a], e[c][a], d[c][a], Z, h, f)
                    }
                }
            }
        }

        function K(Y, W, b, Z, X, e, c) {
            var d = (b - Y) * 0.5;
            var a = (Z - W) * 0.5;
            return (2 * (W - b) + d + a) * c + (-3 * (W - b) - 2 * d - a) * e + d * X + W
        }

        function H(Y) {
            if (V(Y)) {
                var X = Y.length;
                if (V(Y[0])) {
                    var Z = [];
                    for (var W = 0; W < X; W++) {
                        Z.push(P.call(Y[W]))
                    }
                    return Z
                }
                return P.call(Y)
            }
            return Y
        }

        function E(W) {
            W[0] = Math.floor(W[0]);
            W[1] = Math.floor(W[1]);
            W[2] = Math.floor(W[2]);
            return "rgba(" + W.join(",") + ")"
        }

        function O(W) {
            var X = W[W.length - 1].value;
            return V(X && X[0]) ? 2 : 1
        }

        function B(g, c, o, z, Ae) {
            var q = g._getter;
            var d = g._setter;
            var k = c === "spline";
            var f = z.length;
            if (!f) {
                return
            }
            var n = z[0].value;
            var j = V(n);
            var Y = false;
            var l = false;
            var u = j ? O(z) : 0;
            var h;
            z.sort(function(w, i) {
                return w.time - i.time
            });
            h = z[f - 1].time;
            var Aa = [];
            var x = [];
            var Af = z[0].value;
            var y = true;
            for (var Ad = 0; Ad < f; Ad++) {
                Aa.push(z[Ad].time / h);
                var s = z[Ad].value;
                if (!((j && M(s, Af, u)) || (!j && s === Af))) {
                    y = false
                }
                Af = s;
                if (typeof s == "string") {
                    var X = D.parse(s);
                    if (X) {
                        s = X;
                        Y = true
                    } else {
                        l = true
                    }
                }
                x.push(s)
            }
            if (y) {
                return
            }
            var Z = x[f - 1];
            for (var Ad = 0; Ad < f - 1; Ad++) {
                if (j) {
                    S(x[Ad], Z, u)
                } else {
                    if (isNaN(x[Ad]) && !isNaN(Z) && !l && !Y) {
                        x[Ad] = Z
                    }
                }
            }
            j && S(q(g._target, Ae), Z, u);
            var t = 0;
            var p = 0;
            var v;
            var Ac;
            var r;
            var m;
            var a;
            var W;
            if (Y) {
                var Ab = [0, 0, 0, 0]
            }
            var b = function(Ah, w) {
                var Ag;
                if (w < 0) {
                    Ag = 0
                } else {
                    if (w < p) {
                        v = Math.min(t + 1, f - 1);
                        for (Ag = v; Ag >= 0; Ag--) {
                            if (Aa[Ag] <= w) {
                                break
                            }
                        }
                        Ag = Math.min(Ag, f - 2)
                    } else {
                        for (Ag = t; Ag < f; Ag++) {
                            if (Aa[Ag] > w) {
                                break
                            }
                        }
                        Ag = Math.min(Ag - 1, f - 2)
                    }
                }
                t = Ag;
                p = w;
                var Ai = (Aa[Ag + 1] - Aa[Ag]);
                if (Ai === 0) {
                    return
                } else {
                    Ac = (w - Aa[Ag]) / Ai
                }
                if (k) {
                    m = x[Ag];
                    r = x[Ag === 0 ? Ag : Ag - 1];
                    a = x[Ag > f - 2 ? f - 1 : Ag + 1];
                    W = x[Ag > f - 3 ? f - 1 : Ag + 2];
                    if (j) {
                        C(r, m, a, W, Ac, Ac * Ac, Ac * Ac * Ac, q(Ah, Ae), u)
                    } else {
                        var i;
                        if (Y) {
                            i = C(r, m, a, W, Ac, Ac * Ac, Ac * Ac * Ac, Ab, 1);
                            i = E(Ab)
                        } else {
                            if (l) {
                                return A(m, a, Ac)
                            } else {
                                i = K(r, m, a, W, Ac, Ac * Ac, Ac * Ac * Ac)
                            }
                        }
                        d(Ah, Ae, i)
                    }
                } else {
                    if (j) {
                        I(x[Ag], x[Ag + 1], Ac, q(Ah, Ae), u)
                    } else {
                        var i;
                        if (Y) {
                            I(x[Ag], x[Ag + 1], Ac, Ab, 1);
                            i = E(Ab)
                        } else {
                            if (l) {
                                return A(x[Ag], x[Ag + 1], Ac)
                            } else {
                                i = L(x[Ag], x[Ag + 1], Ac)
                            }
                        }
                        d(Ah, Ae, i)
                    }
                }
            };
            var e = new R({target: g._target, life: h, loop: g._loop, delay: g._delay, onframe: b, ondestroy: o});
            if (c && c !== "spline") {
                e.easing = c
            }
            return e
        }

        var U = function(Y, W, X, Z) {
            this._tracks = {};
            this._target = Y;
            this._loop = W || false;
            this._getter = X || T;
            this._setter = Z || F;
            this._clipCount = 0;
            this._delay = 0;
            this._doneList = [];
            this._onframeList = [];
            this._clipList = []
        };
        U.prototype = {
            when: function(X, Y) {
                var Z = this._tracks;
                for (var a in Y) {
                    if (!Y.hasOwnProperty(a)) {
                        continue
                    }
                    if (!Z[a]) {
                        Z[a] = [];
                        var W = this._getter(this._target, a);
                        if (W == null) {
                            continue
                        }
                        if (X !== 0) {
                            Z[a].push({time: 0, value: H(W)})
                        }
                    }
                    Z[a].push({time: X, value: Y[a]})
                }
                return this
            }, during: function(W) {
                this._onframeList.push(W);
                return this
            }, pause: function() {
                for (var W = 0; W < this._clipList.length; W++) {
                    this._clipList[W].pause()
                }
                this._paused = true
            }, resume: function() {
                for (var W = 0; W < this._clipList.length; W++) {
                    this._clipList[W].resume()
                }
                this._paused = false
            }, isPaused: function() {
                return !!this._paused
            }, _doneCallback: function() {
                this._tracks = {};
                this._clipList.length = 0;
                var X = this._doneList;
                var Y = X.length;
                for (var W = 0; W < Y; W++) {
                    X[W].call(this)
                }
            }, start: function(Z) {
                var a = this;
                var Y = 0;
                var c = function() {
                    Y--;
                    if (!Y) {
                        a._doneCallback()
                    }
                };
                var X;
                for (var W in this._tracks) {
                    if (!this._tracks.hasOwnProperty(W)) {
                        continue
                    }
                    var d = B(this, Z, c, this._tracks[W], W);
                    if (d) {
                        this._clipList.push(d);
                        Y++;
                        if (this.animation) {
                            this.animation.addClip(d)
                        }
                        X = d
                    }
                }
                if (X) {
                    var b = X.onframe;
                    X.onframe = function(g, e) {
                        b(g, e);
                        for (var f = 0; f < a._onframeList.length; f++) {
                            a._onframeList[f](g, e)
                        }
                    }
                }
                if (!Y) {
                    this._doneCallback()
                }
                return this
            }, stop: function(Z) {
                var X = this._clipList;
                var W = this.animation;
                for (var Y = 0; Y < X.length; Y++) {
                    var a = X[Y];
                    if (Z) {
                        a.onframe(this._target, 1)
                    }
                    W && W.removeClip(a)
                }
                X.length = 0
            }, delay: function(W) {
                this._delay = W;
                return this
            }, done: function(W) {
                if (W) {
                    this._doneList.push(W)
                }
                return this
            }, getClips: function() {
                return this._clipList
            }
        };
        Q.exports = U
    }, function(D, E, B) {
        var A = B(30);

        function C(F) {
            this._target = F.target;
            this._life = F.life || 1000;
            this._delay = F.delay || 0;
            this._initialized = false;
            this.loop = F.loop == null ? false : F.loop;
            this.gap = F.gap || 0;
            this.easing = F.easing || "Linear";
            this.onframe = F.onframe;
            this.ondestroy = F.ondestroy;
            this.onrestart = F.onrestart;
            this._pausedTime = 0;
            this._paused = false
        }

        C.prototype = {
            constructor: C, step: function(F, K) {
                if (!this._initialized) {
                    this._startTime = F + this._delay;
                    this._initialized = true
                }
                if (this._paused) {
                    this._pausedTime += K;
                    return
                }
                var G = (F - this._startTime - this._pausedTime) / this._life;
                if (G < 0) {
                    return
                }
                G = Math.min(G, 1);
                var H = this.easing;
                var I = typeof H == "string" ? A[H] : H;
                var J = typeof I === "function" ? I(G) : G;
                this.fire("frame", J);
                if (G == 1) {
                    if (this.loop) {
                        this.restart(F);
                        return "restart"
                    }
                    this._needsRemove = true;
                    return "destroy"
                }
                return null
            }, restart: function(F) {
                var G = (F - this._startTime - this._pausedTime) % this._life;
                this._startTime = F - G + this.gap;
                this._pausedTime = 0;
                this._needsRemove = false
            }, fire: function(F, G) {
                F = "on" + F;
                if (this[F]) {
                    this[F](this._target, G)
                }
            }, pause: function() {
                this._paused = true
            }, resume: function() {
                this._paused = false
            }
        };
        D.exports = C
    }, function(B, C) {
        var A = {
            linear: function(D) {
                return D
            }, quadraticIn: function(D) {
                return D * D
            }, quadraticOut: function(D) {
                return D * (2 - D)
            }, quadraticInOut: function(D) {
                if ((D *= 2) < 1) {
                    return 0.5 * D * D
                }
                return -0.5 * (--D * (D - 2) - 1)
            }, cubicIn: function(D) {
                return D * D * D
            }, cubicOut: function(D) {
                return --D * D * D + 1
            }, cubicInOut: function(D) {
                if ((D *= 2) < 1) {
                    return 0.5 * D * D * D
                }
                return 0.5 * ((D -= 2) * D * D + 2)
            }, quarticIn: function(D) {
                return D * D * D * D
            }, quarticOut: function(D) {
                return 1 - (--D * D * D * D)
            }, quarticInOut: function(D) {
                if ((D *= 2) < 1) {
                    return 0.5 * D * D * D * D
                }
                return -0.5 * ((D -= 2) * D * D * D - 2)
            }, quinticIn: function(D) {
                return D * D * D * D * D
            }, quinticOut: function(D) {
                return --D * D * D * D * D + 1
            }, quinticInOut: function(D) {
                if ((D *= 2) < 1) {
                    return 0.5 * D * D * D * D * D
                }
                return 0.5 * ((D -= 2) * D * D * D * D + 2)
            }, sinusoidalIn: function(D) {
                return 1 - Math.cos(D * Math.PI / 2)
            }, sinusoidalOut: function(D) {
                return Math.sin(D * Math.PI / 2)
            }, sinusoidalInOut: function(D) {
                return 0.5 * (1 - Math.cos(Math.PI * D))
            }, exponentialIn: function(D) {
                return D === 0 ? 0 : Math.pow(1024, D - 1)
            }, exponentialOut: function(D) {
                return D === 1 ? 1 : 1 - Math.pow(2, -10 * D)
            }, exponentialInOut: function(D) {
                if (D === 0) {
                    return 0
                }
                if (D === 1) {
                    return 1
                }
                if ((D *= 2) < 1) {
                    return 0.5 * Math.pow(1024, D - 1)
                }
                return 0.5 * (-Math.pow(2, -10 * (D - 1)) + 2)
            }, circularIn: function(D) {
                return 1 - Math.sqrt(1 - D * D)
            }, circularOut: function(D) {
                return Math.sqrt(1 - (--D * D))
            }, circularInOut: function(D) {
                if ((D *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - D * D) - 1)
                }
                return 0.5 * (Math.sqrt(1 - (D -= 2) * D) + 1)
            }, elasticIn: function(G) {
                var D;
                var F = 0.1;
                var E = 0.4;
                if (G === 0) {
                    return 0
                }
                if (G === 1) {
                    return 1
                }
                if (!F || F < 1) {
                    F = 1;
                    D = E / 4
                } else {
                    D = E * Math.asin(1 / F) / (2 * Math.PI)
                }
                return -(F * Math.pow(2, 10 * (G -= 1)) * Math.sin((G - D) * (2 * Math.PI) / E))
            }, elasticOut: function(G) {
                var D;
                var F = 0.1;
                var E = 0.4;
                if (G === 0) {
                    return 0
                }
                if (G === 1) {
                    return 1
                }
                if (!F || F < 1) {
                    F = 1;
                    D = E / 4
                } else {
                    D = E * Math.asin(1 / F) / (2 * Math.PI)
                }
                return (F * Math.pow(2, -10 * G) * Math.sin((G - D) * (2 * Math.PI) / E) + 1)
            }, elasticInOut: function(G) {
                var D;
                var F = 0.1;
                var E = 0.4;
                if (G === 0) {
                    return 0
                }
                if (G === 1) {
                    return 1
                }
                if (!F || F < 1) {
                    F = 1;
                    D = E / 4
                } else {
                    D = E * Math.asin(1 / F) / (2 * Math.PI)
                }
                if ((G *= 2) < 1) {
                    return -0.5 * (F * Math.pow(2, 10 * (G -= 1)) * Math.sin((G - D) * (2 * Math.PI) / E))
                }
                return F * Math.pow(2, -10 * (G -= 1)) * Math.sin((G - D) * (2 * Math.PI) / E) * 0.5 + 1
            }, backIn: function(E) {
                var D = 1.70158;
                return E * E * ((D + 1) * E - D)
            }, backOut: function(E) {
                var D = 1.70158;
                return --E * E * ((D + 1) * E + D) + 1
            }, backInOut: function(E) {
                var D = 1.70158 * 1.525;
                if ((E *= 2) < 1) {
                    return 0.5 * (E * E * ((D + 1) * E - D))
                }
                return 0.5 * ((E -= 2) * E * ((D + 1) * E + D) + 2)
            }, bounceIn: function(D) {
                return 1 - A.bounceOut(1 - D)
            }, bounceOut: function(D) {
                if (D < (1 / 2.75)) {
                    return 7.5625 * D * D
                } else {
                    if (D < (2 / 2.75)) {
                        return 7.5625 * (D -= (1.5 / 2.75)) * D + 0.75
                    } else {
                        if (D < (2.5 / 2.75)) {
                            return 7.5625 * (D -= (2.25 / 2.75)) * D + 0.9375
                        } else {
                            return 7.5625 * (D -= (2.625 / 2.75)) * D + 0.984375
                        }
                    }
                }
            }, bounceInOut: function(D) {
                if (D < 0.5) {
                    return A.bounceIn(D * 2) * 0.5
                }
                return A.bounceOut(D * 2 - 1) * 0.5 + 0.5
            }
        };
        B.exports = A
    }, function(Q, G, S) {
        var L = S(32);
        var B = {
            "transparent": [0, 0, 0, 0],
            "aliceblue": [240, 248, 255, 1],
            "antiquewhite": [250, 235, 215, 1],
            "aqua": [0, 255, 255, 1],
            "aquamarine": [127, 255, 212, 1],
            "azure": [240, 255, 255, 1],
            "beige": [245, 245, 220, 1],
            "bisque": [255, 228, 196, 1],
            "black": [0, 0, 0, 1],
            "blanchedalmond": [255, 235, 205, 1],
            "blue": [0, 0, 255, 1],
            "blueviolet": [138, 43, 226, 1],
            "brown": [165, 42, 42, 1],
            "burlywood": [222, 184, 135, 1],
            "cadetblue": [95, 158, 160, 1],
            "chartreuse": [127, 255, 0, 1],
            "chocolate": [210, 105, 30, 1],
            "coral": [255, 127, 80, 1],
            "cornflowerblue": [100, 149, 237, 1],
            "cornsilk": [255, 248, 220, 1],
            "crimson": [220, 20, 60, 1],
            "cyan": [0, 255, 255, 1],
            "darkblue": [0, 0, 139, 1],
            "darkcyan": [0, 139, 139, 1],
            "darkgoldenrod": [184, 134, 11, 1],
            "darkgray": [169, 169, 169, 1],
            "darkgreen": [0, 100, 0, 1],
            "darkgrey": [169, 169, 169, 1],
            "darkkhaki": [189, 183, 107, 1],
            "darkmagenta": [139, 0, 139, 1],
            "darkolivegreen": [85, 107, 47, 1],
            "darkorange": [255, 140, 0, 1],
            "darkorchid": [153, 50, 204, 1],
            "darkred": [139, 0, 0, 1],
            "darksalmon": [233, 150, 122, 1],
            "darkseagreen": [143, 188, 143, 1],
            "darkslateblue": [72, 61, 139, 1],
            "darkslategray": [47, 79, 79, 1],
            "darkslategrey": [47, 79, 79, 1],
            "darkturquoise": [0, 206, 209, 1],
            "darkviolet": [148, 0, 211, 1],
            "deeppink": [255, 20, 147, 1],
            "deepskyblue": [0, 191, 255, 1],
            "dimgray": [105, 105, 105, 1],
            "dimgrey": [105, 105, 105, 1],
            "dodgerblue": [30, 144, 255, 1],
            "firebrick": [178, 34, 34, 1],
            "floralwhite": [255, 250, 240, 1],
            "forestgreen": [34, 139, 34, 1],
            "fuchsia": [255, 0, 255, 1],
            "gainsboro": [220, 220, 220, 1],
            "ghostwhite": [248, 248, 255, 1],
            "gold": [255, 215, 0, 1],
            "goldenrod": [218, 165, 32, 1],
            "gray": [128, 128, 128, 1],
            "green": [0, 128, 0, 1],
            "greenyellow": [173, 255, 47, 1],
            "grey": [128, 128, 128, 1],
            "honeydew": [240, 255, 240, 1],
            "hotpink": [255, 105, 180, 1],
            "indianred": [205, 92, 92, 1],
            "indigo": [75, 0, 130, 1],
            "ivory": [255, 255, 240, 1],
            "khaki": [240, 230, 140, 1],
            "lavender": [230, 230, 250, 1],
            "lavenderblush": [255, 240, 245, 1],
            "lawngreen": [124, 252, 0, 1],
            "lemonchiffon": [255, 250, 205, 1],
            "lightblue": [173, 216, 230, 1],
            "lightcoral": [240, 128, 128, 1],
            "lightcyan": [224, 255, 255, 1],
            "lightgoldenrodyellow": [250, 250, 210, 1],
            "lightgray": [211, 211, 211, 1],
            "lightgreen": [144, 238, 144, 1],
            "lightgrey": [211, 211, 211, 1],
            "lightpink": [255, 182, 193, 1],
            "lightsalmon": [255, 160, 122, 1],
            "lightseagreen": [32, 178, 170, 1],
            "lightskyblue": [135, 206, 250, 1],
            "lightslategray": [119, 136, 153, 1],
            "lightslategrey": [119, 136, 153, 1],
            "lightsteelblue": [176, 196, 222, 1],
            "lightyellow": [255, 255, 224, 1],
            "lime": [0, 255, 0, 1],
            "limegreen": [50, 205, 50, 1],
            "linen": [250, 240, 230, 1],
            "magenta": [255, 0, 255, 1],
            "maroon": [128, 0, 0, 1],
            "mediumaquamarine": [102, 205, 170, 1],
            "mediumblue": [0, 0, 205, 1],
            "mediumorchid": [186, 85, 211, 1],
            "mediumpurple": [147, 112, 219, 1],
            "mediumseagreen": [60, 179, 113, 1],
            "mediumslateblue": [123, 104, 238, 1],
            "mediumspringgreen": [0, 250, 154, 1],
            "mediumturquoise": [72, 209, 204, 1],
            "mediumvioletred": [199, 21, 133, 1],
            "midnightblue": [25, 25, 112, 1],
            "mintcream": [245, 255, 250, 1],
            "mistyrose": [255, 228, 225, 1],
            "moccasin": [255, 228, 181, 1],
            "navajowhite": [255, 222, 173, 1],
            "navy": [0, 0, 128, 1],
            "oldlace": [253, 245, 230, 1],
            "olive": [128, 128, 0, 1],
            "olivedrab": [107, 142, 35, 1],
            "orange": [255, 165, 0, 1],
            "orangered": [255, 69, 0, 1],
            "orchid": [218, 112, 214, 1],
            "palegoldenrod": [238, 232, 170, 1],
            "palegreen": [152, 251, 152, 1],
            "paleturquoise": [175, 238, 238, 1],
            "palevioletred": [219, 112, 147, 1],
            "papayawhip": [255, 239, 213, 1],
            "peachpuff": [255, 218, 185, 1],
            "peru": [205, 133, 63, 1],
            "pink": [255, 192, 203, 1],
            "plum": [221, 160, 221, 1],
            "powderblue": [176, 224, 230, 1],
            "purple": [128, 0, 128, 1],
            "red": [255, 0, 0, 1],
            "rosybrown": [188, 143, 143, 1],
            "royalblue": [65, 105, 225, 1],
            "saddlebrown": [139, 69, 19, 1],
            "salmon": [250, 128, 114, 1],
            "sandybrown": [244, 164, 96, 1],
            "seagreen": [46, 139, 87, 1],
            "seashell": [255, 245, 238, 1],
            "sienna": [160, 82, 45, 1],
            "silver": [192, 192, 192, 1],
            "skyblue": [135, 206, 235, 1],
            "slateblue": [106, 90, 205, 1],
            "slategray": [112, 128, 144, 1],
            "slategrey": [112, 128, 144, 1],
            "snow": [255, 250, 250, 1],
            "springgreen": [0, 255, 127, 1],
            "steelblue": [70, 130, 180, 1],
            "tan": [210, 180, 140, 1],
            "teal": [0, 128, 128, 1],
            "thistle": [216, 191, 216, 1],
            "tomato": [255, 99, 71, 1],
            "turquoise": [64, 224, 208, 1],
            "violet": [238, 130, 238, 1],
            "wheat": [245, 222, 179, 1],
            "white": [255, 255, 255, 1],
            "whitesmoke": [245, 245, 245, 1],
            "yellow": [255, 255, 0, 1],
            "yellowgreen": [154, 205, 50, 1]
        };

        function D(b) {
            b = Math.round(b);
            return b < 0 ? 0 : b > 255 ? 255 : b
        }

        function F(b) {
            b = Math.round(b);
            return b < 0 ? 0 : b > 360 ? 360 : b
        }

        function O(b) {
            return b < 0 ? 0 : b > 1 ? 1 : b
        }

        function I(b) {
            if (b.length && b.charAt(b.length - 1) === "%") {
                return D(parseFloat(b) / 100 * 255)
            }
            return D(parseInt(b, 10))
        }

        function T(b) {
            if (b.length && b.charAt(b.length - 1) === "%") {
                return O(parseFloat(b) / 100)
            }
            return O(parseFloat(b))
        }

        function a(c, d, b) {
            if (b < 0) {
                b += 1
            } else {
                if (b > 1) {
                    b -= 1
                }
            }
            if (b * 6 < 1) {
                return c + (d - c) * b * 6
            }
            if (b * 2 < 1) {
                return d
            }
            if (b * 3 < 2) {
                return c + (d - c) * (2 / 3 - b) * 6
            }
            return c
        }

        function U(e, d, c) {
            return e + (d - e) * c
        }

        function N(e, d, c, f, h) {
            e[0] = d;
            e[1] = c;
            e[2] = f;
            e[3] = h;
            return e
        }

        function H(b, c) {
            b[0] = c[0];
            b[1] = c[1];
            b[2] = c[2];
            b[3] = c[3];
            return b
        }

        var J = new L(20);
        var V = null;

        function Y(c, b) {
            if (V) {
                H(V, b)
            }
            V = J.put(c, V || (b.slice()))
        }

        function C(b, g) {
            if (!b) {
                return
            }
            g = g || [];
            var j = J.get(b);
            if (j) {
                return H(g, j)
            }
            b = b + "";
            var e = b.replace(/ /g, "").toLowerCase();
            if (e in B) {
                H(g, B[e]);
                Y(b, g);
                return g
            }
            if (e.charAt(0) === "#") {
                if (e.length === 4) {
                    var i = parseInt(e.substr(1), 16);
                    if (!(i >= 0 && i <= 4095)) {
                        N(g, 0, 0, 0, 1);
                        return
                    }
                    N(g, ((i & 3840) >> 4) | ((i & 3840) >> 8), (i & 240) | ((i & 240) >> 4), (i & 15) | ((i & 15) << 4), 1);
                    Y(b, g);
                    return g
                } else {
                    if (e.length === 7) {
                        var i = parseInt(e.substr(1), 16);
                        if (!(i >= 0 && i <= 16777215)) {
                            N(g, 0, 0, 0, 1);
                            return
                        }
                        N(g, (i & 16711680) >> 16, (i & 65280) >> 8, i & 255, 1);
                        Y(b, g);
                        return g
                    }
                }
                return
            }
            var h = e.indexOf("("), d = e.indexOf(")");
            if (h !== -1 && d + 1 === e.length) {
                var f = e.substr(0, h);
                var k = e.substr(h + 1, d - (h + 1)).split(",");
                var c = 1;
                switch (f) {
                    case"rgba":
                        if (k.length !== 4) {
                            N(g, 0, 0, 0, 1);
                            return
                        }
                        c = T(k.pop());
                    case"rgb":
                        if (k.length !== 3) {
                            N(g, 0, 0, 0, 1);
                            return
                        }
                        N(g, I(k[0]), I(k[1]), I(k[2]), c);
                        Y(b, g);
                        return g;
                    case"hsla":
                        if (k.length !== 4) {
                            N(g, 0, 0, 0, 1);
                            return
                        }
                        k[3] = T(k[3]);
                        K(k, g);
                        Y(b, g);
                        return g;
                    case"hsl":
                        if (k.length !== 3) {
                            N(g, 0, 0, 0, 1);
                            return
                        }
                        K(k, g);
                        Y(b, g);
                        return g;
                    default:
                        return
                }
            }
            N(g, 0, 0, 0, 1);
            return
        }

        function K(i, c) {
            var b = (((parseFloat(i[0]) % 360) + 360) % 360) / 360;
            var d = T(i[1]);
            var e = T(i[2]);
            var f = e <= 0.5 ? e * (d + 1) : e + d - e * d;
            var g = e * 2 - f;
            c = c || [];
            N(c, D(a(g, f, b + 1 / 3) * 255), D(a(g, f, b) * 255), D(a(g, f, b - 1 / 3) * 255), 1);
            if (i.length === 4) {
                c[3] = i[3]
            }
            return c
        }

        function P(k) {
            if (!k) {
                return
            }
            var i = k[0] / 255;
            var h = k[1] / 255;
            var f = k[2] / 255;
            var n = Math.min(i, h, f);
            var d = Math.max(i, h, f);
            var l = d - n;
            var e = (d + n) / 2;
            var c;
            var j;
            if (l === 0) {
                c = 0;
                j = 0
            } else {
                if (e < 0.5) {
                    j = l / (d + n)
                } else {
                    j = l / (2 - d - n)
                }
                var g = (((d - i) / 6) + (l / 2)) / l;
                var m = (((d - h) / 6) + (l / 2)) / l;
                var b = (((d - f) / 6) + (l / 2)) / l;
                if (i === d) {
                    c = b - m
                } else {
                    if (h === d) {
                        c = (1 / 3) + g - b
                    } else {
                        if (f === d) {
                            c = (2 / 3) + m - g
                        }
                    }
                }
                if (c < 0) {
                    c += 1
                }
                if (c > 1) {
                    c -= 1
                }
            }
            var o = [c * 360, j, e];
            if (k[3] != null) {
                o.push(k[3])
            }
            return o
        }

        function E(e, c) {
            var d = C(e);
            if (d) {
                for (var b = 0; b < 3; b++) {
                    if (c < 0) {
                        d[b] = d[b] * (1 - c) | 0
                    } else {
                        d[b] = ((255 - d[b]) * c + d[b]) | 0
                    }
                }
                return A(d, d.length === 4 ? "rgba" : "rgb")
            }
        }

        function X(d, b) {
            var c = C(d);
            if (c) {
                return ((1 << 24) + (c[0] << 16) + (c[1] << 8) + (+c[2])).toString(16).slice(1)
            }
        }

        function Z(c, h, b) {
            if (!(h && h.length) || !(c >= 0 && c <= 1)) {
                return
            }
            b = b || [];
            var g = c * (h.length - 1);
            var f = Math.floor(g);
            var i = Math.ceil(g);
            var j = h[f];
            var d = h[i];
            var e = g - f;
            b[0] = D(U(j[0], d[0], e));
            b[1] = D(U(j[1], d[1], e));
            b[2] = D(U(j[2], d[2], e));
            b[3] = O(U(j[3], d[3], e));
            return b
        }

        function R(b, h, j) {
            if (!(h && h.length) || !(b >= 0 && b <= 1)) {
                return
            }
            var g = b * (h.length - 1);
            var f = Math.floor(g);
            var i = Math.ceil(g);
            var k = C(h[f]);
            var c = C(h[i]);
            var d = g - f;
            var e = A([D(U(k[0], c[0], d)), D(U(k[1], c[1], d)), D(U(k[2], c[2], d)), O(U(k[3], c[3], d))], "rgba");
            return j ? {color: e, leftIndex: f, rightIndex: i, value: g} : e
        }

        function M(e, b, c, d) {
            e = C(e);
            if (e) {
                e = P(e);
                b != null && (e[0] = F(b));
                c != null && (e[1] = T(c));
                d != null && (e[2] = T(d));
                return A(K(e), "rgba")
            }
        }

        function W(c, b) {
            c = C(c);
            if (c && b != null) {
                c[3] = O(b);
                return A(c, "rgba")
            }
        }

        function A(c, b) {
            if (!c || !c.length) {
                return
            }
            var d = c[0] + "," + c[1] + "," + c[2];
            if (b === "rgba" || b === "hsva" || b === "hsla") {
                d += "," + c[3]
            }
            return b + "(" + d + ")"
        }

        Q.exports = {parse: C, lift: E, toHex: X, fastMapToColor: Z, mapToColor: R, modifyHSL: M, modifyAlpha: W, stringify: A}
    }, function(D, F) {
        var E = function() {
            this.head = null;
            this.tail = null;
            this._len = 0
        };
        var B = E.prototype;
        B.insert = function(I) {
            var H = new G(I);
            this.insertEntry(H);
            return H
        };
        B.insertEntry = function(H) {
            if (!this.head) {
                this.head = this.tail = H
            } else {
                this.tail.next = H;
                H.prev = this.tail;
                H.next = null;
                this.tail = H
            }
            this._len++
        };
        B.remove = function(I) {
            var J = I.prev;
            var H = I.next;
            if (J) {
                J.next = H
            } else {
                this.head = H
            }
            if (H) {
                H.prev = J
            } else {
                this.tail = J
            }
            I.next = I.prev = null;
            this._len--
        };
        B.len = function() {
            return this._len
        };
        B.clear = function() {
            this.head = this.tail = null;
            this._len = 0
        };
        var G = function(H) {
            this.value = H;
            this.next;
            this.prev
        };
        var C = function(H) {
            this._list = new E();
            this._map = {};
            this._maxSize = H || 10;
            this._lastRemovedEntry = null
        };
        var A = C.prototype;
        A.put = function(L, K) {
            var H = this._list;
            var O = this._map;
            var J = null;
            if (O[L] == null) {
                var N = H.len();
                var I = this._lastRemovedEntry;
                if (N >= this._maxSize && N > 0) {
                    var M = H.head;
                    H.remove(M);
                    delete O[M.key];
                    J = M.value;
                    this._lastRemovedEntry = M
                }
                if (I) {
                    I.value = K
                } else {
                    I = new G(K)
                }
                I.key = L;
                H.insertEntry(I);
                O[L] = I
            }
            return J
        };
        A.get = function(H) {
            var I = this._map[H];
            var J = this._list;
            if (I != null) {
                if (I !== J.tail) {
                    J.remove(I);
                    J.insertEntry(I)
                }
                return I.value
            }
        };
        A.clear = function() {
            this._list.clear();
            this._map = {}
        };
        D.exports = C
    }, function(C, D, A) {
        var B = A(34);
        C.exports = function() {
            if (B.debugMode === 0) {
                return
            } else {
                if (B.debugMode == 1) {
                    for (var E in arguments) {
                        throw new Error(arguments[E])
                    }
                } else {
                    if (B.debugMode > 1) {
                        for (var E in arguments) {
                            console.log(arguments[E])
                        }
                    }
                }
            }
        }
    }, function(C, D) {
        var A = 1;
        if (typeof window !== "undefined") {
            A = Math.max(window.devicePixelRatio || 1, 1)
        }
        var B = {debugMode: 0, devicePixelRatio: A};
        C.exports = B
    }, function(G, H, B) {
        var E = B(8);
        var C = B(9);
        var F = new C();
        var A = function() {
        };

        function D(I, J) {
            if (typeof I === "string") {
                if (I.lastIndexOf("%") >= 0) {
                    return parseFloat(I) / 100 * J
                }
                return parseFloat(I)
            }
            return I
        }

        A.prototype = {
            constructor: A, drawRectText: function(Z, O, b) {
                var a = this.style;
                var P = a.text;
                P != null && (P += "");
                if (!P) {
                    return
                }
                Z.save();
                var X;
                var Y;
                var V = a.textPosition;
                var M = a.textOffset;
                var W = a.textDistance;
                var J = a.textAlign;
                var N = a.textFont || a.font;
                var Q = a.textBaseline;
                var U = a.textVerticalAlign;
                O = a.textPositionRect || O;
                b = b || E.getBoundingRect(P, N, J, Q);
                var L = this.transform;
                if (!a.textTransform) {
                    if (L) {
                        F.copy(O);
                        F.applyTransform(L);
                        O = F
                    }
                } else {
                    this.setTransform(Z)
                }
                if (V instanceof Array) {
                    X = O.x + D(V[0], O.width);
                    Y = O.y + D(V[1], O.height);
                    J = J || "left";
                    Q = Q || "top";
                    if (U) {
                        switch (U) {
                            case"middle":
                                Y -= b.height / 2 - b.lineHeight / 2;
                                break;
                            case"bottom":
                                Y -= b.height - b.lineHeight / 2;
                                break;
                            default:
                                Y += b.lineHeight / 2
                        }
                        Q = "middle"
                    }
                } else {
                    var R = E.adjustTextPositionOnRect(V, O, b, W);
                    X = R.x;
                    Y = R.y;
                    J = J || R.textAlign;
                    Q = Q || R.textBaseline
                }
                if (M) {
                    X += M[0];
                    Y += M[1]
                }
                Z.textAlign = J || "left";
                Z.textBaseline = Q || "alphabetic";
                var K = a.textFill;
                var S = a.textStroke;
                K && (Z.fillStyle = K);
                S && (Z.strokeStyle = S);
                Z.font = N || "12px sans-serif";
                Z.shadowBlur = a.textShadowBlur;
                Z.shadowColor = a.textShadowColor || "transparent";
                Z.shadowOffsetX = a.textShadowOffsetX;
                Z.shadowOffsetY = a.textShadowOffsetY;
                var T = P.split("\n");
                if (a.textRotation) {
                    L && Z.translate(L[4], L[5]);
                    Z.rotate(a.textRotation);
                    L && Z.translate(-L[4], -L[5])
                }
                for (var I = 0; I < T.length; I++) {
                    S && Z.strokeText(T[I], X, Y);
                    K && Z.fillText(T[I], X, Y);
                    Y += b.lineHeight
                }
                Z.restore()
            }
        };
        G.exports = A
    }, function(N, D, P) {
        var E = P(37);
        var L = P(10);
        var F = P(38);
        var R = P(9);
        var O = P(34).devicePixelRatio;
        var U = {M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7};
        var G = [];
        var S = [];
        var I = [];
        var B = [];
        var Q = Math.min;
        var K = Math.max;
        var M = Math.cos;
        var H = Math.sin;
        var A = Math.sqrt;
        var J = Math.abs;
        var T = typeof Float32Array != "undefined";
        var C = function(V) {
            this._saveData = !(V || false);
            if (this._saveData) {
                this.data = []
            }
            this._ctx = null
        };
        C.prototype = {
            constructor: C,
            _xi: 0,
            _yi: 0,
            _x0: 0,
            _y0: 0,
            _ux: 0,
            _uy: 0,
            _len: 0,
            _lineDash: null,
            _dashOffset: 0,
            _dashIdx: 0,
            _dashSum: 0,
            setScale: function(V, W) {
                this._ux = J(1 / O / V) || 0;
                this._uy = J(1 / O / W) || 0
            },
            getContext: function() {
                return this._ctx
            },
            beginPath: function(V) {
                this._ctx = V;
                V && V.beginPath();
                V && (this.dpr = V.dpr);
                if (this._saveData) {
                    this._len = 0
                }
                if (this._lineDash) {
                    this._lineDash = null;
                    this._dashOffset = 0
                }
                return this
            },
            moveTo: function(V, W) {
                this.addData(U.M, V, W);
                this._ctx && this._ctx.moveTo(V, W);
                this._x0 = V;
                this._y0 = W;
                this._xi = V;
                this._yi = W;
                return this
            },
            lineTo: function(W, X) {
                var V = J(W - this._xi) > this._ux || J(X - this._yi) > this._uy || this._len < 5;
                this.addData(U.L, W, X);
                if (this._ctx && V) {
                    this._needsDash() ? this._dashedLineTo(W, X) : this._ctx.lineTo(W, X)
                }
                if (V) {
                    this._xi = W;
                    this._yi = X
                }
                return this
            },
            bezierCurveTo: function(Z, a, V, W, X, Y) {
                this.addData(U.C, Z, a, V, W, X, Y);
                if (this._ctx) {
                    this._needsDash() ? this._dashedBezierTo(Z, a, V, W, X, Y) : this._ctx.bezierCurveTo(Z, a, V, W, X, Y)
                }
                this._xi = X;
                this._yi = Y;
                return this
            },
            quadraticCurveTo: function(X, Y, V, W) {
                this.addData(U.Q, X, Y, V, W);
                if (this._ctx) {
                    this._needsDash() ? this._dashedQuadraticTo(X, Y, V, W) : this._ctx.quadraticCurveTo(X, Y, V, W)
                }
                this._xi = V;
                this._yi = W;
                return this
            },
            arc: function(a, V, W, Z, X, Y) {
                this.addData(U.A, a, V, W, W, Z, X - Z, 0, Y ? 0 : 1);
                this._ctx && this._ctx.arc(a, V, W, Z, X, Y);
                this._xi = M(X) * W + a;
                this._yi = H(X) * W + a;
                return this
            },
            arcTo: function(Y, Z, V, W, X) {
                if (this._ctx) {
                    this._ctx.arcTo(Y, Z, V, W, X)
                }
                return this
            },
            rect: function(W, X, Y, V) {
                this._ctx && this._ctx.rect(W, X, Y, V);
                this.addData(U.R, W, X, Y, V);
                return this
            },
            closePath: function() {
                this.addData(U.Z);
                var X = this._ctx;
                var V = this._x0;
                var W = this._y0;
                if (X) {
                    this._needsDash() && this._dashedLineTo(V, W);
                    X.closePath()
                }
                this._xi = V;
                this._yi = W;
                return this
            },
            fill: function(V) {
                V && V.fill();
                this.toStatic()
            },
            stroke: function(V) {
                V && V.stroke();
                this.toStatic()
            },
            setLineDash: function(X) {
                if (X instanceof Array) {
                    this._lineDash = X;
                    this._dashIdx = 0;
                    var W = 0;
                    for (var V = 0; V < X.length; V++) {
                        W += X[V]
                    }
                    this._dashSum = W
                }
                return this
            },
            setLineDashOffset: function(V) {
                this._dashOffset = V;
                return this
            },
            len: function() {
                return this._len
            },
            setData: function(X) {
                var W = X.length;
                if (!(this.data && this.data.length == W) && T) {
                    this.data = new Float32Array(W)
                }
                for (var V = 0; V < W; V++) {
                    this.data[V] = X[V]
                }
                this._len = W
            },
            appendPath: function(b) {
                if (!(b instanceof Array)) {
                    b = [b]
                }
                var Z = b.length;
                var a = 0;
                var W = this._len;
                for (var X = 0; X < Z; X++) {
                    a += b[X].len()
                }
                if (T && (this.data instanceof Float32Array)) {
                    this.data = new Float32Array(W + a)
                }
                for (var X = 0; X < Z; X++) {
                    var Y = b[X].data;
                    for (var V = 0; V < Y.length; V++) {
                        this.data[W++] = Y[V]
                    }
                }
                this._len = W
            },
            addData: function(W) {
                if (!this._saveData) {
                    return
                }
                var X = this.data;
                if (this._len + arguments.length > X.length) {
                    this._expandData();
                    X = this.data
                }
                for (var V = 0; V < arguments.length; V++) {
                    X[this._len++] = arguments[V]
                }
                this._prevCmd = W
            },
            _expandData: function() {
                if (!(this.data instanceof Array)) {
                    var V = [];
                    for (var W = 0; W < this._len; W++) {
                        V[W] = this.data[W]
                    }
                    this.data = V
                }
            },
            _needsDash: function() {
                return this._lineDash
            },
            _dashedLineTo: function(X, Y) {
                var j = this._dashSum;
                var W = this._dashOffset;
                var Z = this._lineDash;
                var c = this._ctx;
                var a = this._xi;
                var b = this._yi;
                var g = X - a;
                var d = Y - b;
                var f = A(g * g + d * d);
                var h = a;
                var i = b;
                var e;
                var k = Z.length;
                var V;
                g /= f;
                d /= f;
                if (W < 0) {
                    W = j + W
                }
                W %= j;
                h -= W * g;
                i -= W * d;
                while ((g > 0 && h <= X) || (g < 0 && h >= X) || (g == 0 && ((d > 0 && i <= Y) || (d < 0 && i >= Y)))) {
                    V = this._dashIdx;
                    e = Z[V];
                    h += g * e;
                    i += d * e;
                    this._dashIdx = (V + 1) % k;
                    if ((g > 0 && h < a) || (g < 0 && h > a) || (d > 0 && i < b) || (d < 0 && i > b)) {
                        continue
                    }
                    c[V % 2 ? "moveTo" : "lineTo"](g >= 0 ? Q(h, X) : K(h, X), d >= 0 ? Q(i, Y) : K(i, Y))
                }
                g = h - X;
                d = i - Y;
                this._dashOffset = -A(g * g + d * d)
            },
            _dashedBezierTo: function(V, l, k, q, h, e) {
                var d = this._dashSum;
                var f = this._dashOffset;
                var a = this._lineDash;
                var p = this._ctx;
                var Y = this._xi;
                var b = this._yi;
                var W;
                var Z;
                var j;
                var i = E.cubicAt;
                var g = 0;
                var o = this._dashIdx;
                var c = a.length;
                var m;
                var n;
                var X = 0;
                if (f < 0) {
                    f = d + f
                }
                f %= d;
                for (W = 0; W < 1; W += 0.1) {
                    Z = i(Y, V, k, h, W + 0.1) - i(Y, V, k, h, W);
                    j = i(b, l, q, e, W + 0.1) - i(b, l, q, e, W);
                    g += A(Z * Z + j * j)
                }
                for (; o < c; o++) {
                    X += a[o];
                    if (X > f) {
                        break
                    }
                }
                W = (X - f) / g;
                while (W <= 1) {
                    m = i(Y, V, k, h, W);
                    n = i(b, l, q, e, W);
                    o % 2 ? p.moveTo(m, n) : p.lineTo(m, n);
                    W += a[o] / g;
                    o = (o + 1) % c
                }
                (o % 2 !== 0) && p.lineTo(h, e);
                Z = h - m;
                j = e - n;
                this._dashOffset = -A(Z * Z + j * j)
            },
            _dashedQuadraticTo: function(Z, a, V, W) {
                var X = V;
                var Y = W;
                V = (V + 2 * Z) / 3;
                W = (W + 2 * a) / 3;
                Z = (this._xi + 2 * Z) / 3;
                a = (this._yi + 2 * a) / 3;
                this._dashedBezierTo(Z, a, V, W, X, Y)
            },
            toStatic: function() {
                var V = this.data;
                if (V instanceof Array) {
                    V.length = this._len;
                    if (T) {
                        this.data = new Float32Array(V)
                    }
                }
            },
            getBoundingRect: function() {
                G[0] = G[1] = I[0] = I[1] = Number.MAX_VALUE;
                S[0] = S[1] = B[0] = B[1] = -Number.MAX_VALUE;
                var c = this.data;
                var V = 0;
                var l = 0;
                var Z = 0;
                var a = 0;
                for (var X = 0; X < c.length;) {
                    var e = c[X++];
                    if (X == 1) {
                        V = c[X];
                        l = c[X + 1];
                        Z = V;
                        a = l
                    }
                    switch (e) {
                        case U.M:
                            Z = c[X++];
                            a = c[X++];
                            V = Z;
                            l = a;
                            I[0] = Z;
                            I[1] = a;
                            B[0] = Z;
                            B[1] = a;
                            break;
                        case U.L:
                            F.fromLine(V, l, c[X], c[X + 1], I, B);
                            V = c[X++];
                            l = c[X++];
                            break;
                        case U.C:
                            F.fromCubic(V, l, c[X++], c[X++], c[X++], c[X++], c[X], c[X + 1], I, B);
                            V = c[X++];
                            l = c[X++];
                            break;
                        case U.Q:
                            F.fromQuadratic(V, l, c[X++], c[X++], c[X], c[X + 1], I, B);
                            V = c[X++];
                            l = c[X++];
                            break;
                        case U.A:
                            var W = c[X++];
                            var h = c[X++];
                            var j = c[X++];
                            var Y = c[X++];
                            var b = c[X++];
                            var f = c[X++] + b;
                            var d = c[X++];
                            var k = 1 - c[X++];
                            if (X == 1) {
                                Z = M(b) * j + W;
                                a = H(b) * Y + h
                            }
                            F.fromArc(W, h, j, Y, b, f, k, I, B);
                            V = M(f) * j + W;
                            l = H(f) * Y + h;
                            break;
                        case U.R:
                            Z = V = c[X++];
                            a = l = c[X++];
                            var g = c[X++];
                            var m = c[X++];
                            F.fromLine(Z, a, Z + g, a + m, I, B);
                            break;
                        case U.Z:
                            V = Z;
                            l = a;
                            break
                    }
                    L.min(G, G, I);
                    L.max(S, S, B)
                }
                if (X === 0) {
                    G[0] = G[1] = S[0] = S[1] = 0
                }
                return new R(G[0], G[1], S[0] - G[0], S[1] - G[1])
            },
            rebuildPath: function(e) {
                var h = this.data;
                var c, b;
                var X, Y;
                var u, v;
                var z = this._ux;
                var g = this._uy;
                var W = this._len;
                for (var a = 0; a < W;) {
                    var j = h[a++];
                    if (a == 1) {
                        X = h[a];
                        Y = h[a + 1];
                        c = X;
                        b = Y
                    }
                    switch (j) {
                        case U.M:
                            c = X = h[a++];
                            b = Y = h[a++];
                            e.moveTo(X, Y);
                            break;
                        case U.L:
                            u = h[a++];
                            v = h[a++];
                            if (J(u - X) > z || J(v - Y) > g || a === W - 1) {
                                e.lineTo(u, v);
                                X = u;
                                Y = v
                            }
                            break;
                        case U.C:
                            e.bezierCurveTo(h[a++], h[a++], h[a++], h[a++], h[a++], h[a++]);
                            X = h[a - 2];
                            Y = h[a - 1];
                            break;
                        case U.Q:
                            e.quadraticCurveTo(h[a++], h[a++], h[a++], h[a++]);
                            X = h[a - 2];
                            Y = h[a - 1];
                            break;
                        case U.A:
                            var Z = h[a++];
                            var o = h[a++];
                            var t = h[a++];
                            var s = h[a++];
                            var n = h[a++];
                            var q = h[a++];
                            var p = h[a++];
                            var f = h[a++];
                            var V = (t > s) ? t : s;
                            var w = (t > s) ? 1 : t / s;
                            var m = (t > s) ? s / t : 1;
                            var l = Math.abs(t - s) > 0.001;
                            var k = n + q;
                            if (l) {
                                e.translate(Z, o);
                                e.rotate(p);
                                e.scale(w, m);
                                e.arc(0, 0, V, n, k, 1 - f);
                                e.scale(1 / w, 1 / m);
                                e.rotate(-p);
                                e.translate(-Z, -o)
                            } else {
                                e.arc(Z, o, V, n, k, 1 - f)
                            }
                            if (a == 1) {
                                c = M(n) * t + Z;
                                b = H(n) * s + o
                            }
                            X = M(k) * t + Z;
                            Y = H(k) * s + o;
                            break;
                        case U.R:
                            c = X = h[a];
                            b = Y = h[a + 1];
                            e.rect(h[a++], h[a++], h[a++], h[a++]);
                            break;
                        case U.Z:
                            e.closePath();
                            X = c;
                            Y = b
                    }
                }
            }
        };
        C.CMD = U;
        N.exports = C
    }, function(T, I, V) {
        var R = V(10);
        var C = R.create;
        var a = R.distSquare;
        var U = Math.pow;
        var A = Math.sqrt;
        var J = 1e-08;
        var F = 0.0001;
        var c = A(3);
        var Y = 1 / 3;
        var M = C();
        var L = C();
        var O = C();

        function X(d) {
            return d > -J && d < J
        }

        function P(d) {
            return d > J || d < -J
        }

        function S(e, f, h, i, g) {
            var d = 1 - g;
            return d * d * (d * e + 3 * g * f) + g * g * (g * i + 3 * d * h)
        }

        function H(e, f, h, i, g) {
            var d = 1 - g;
            return 3 * (((f - e) * d + 2 * (h - f) * g) * d + (i - h) * g * g)
        }

        function N(s, Ae, g, v, z, o) {
            var p = v + 3 * (Ae - g) - s;
            var m = 3 * (g - Ae * 2 + s);
            var e = 3 * (Ae - s);
            var r = s - z;
            var Aa = m * m - 3 * p * e;
            var x = m * e - 9 * p * r;
            var y = e * e - 3 * m * r;
            var j = 0;
            if (X(Aa) && X(x)) {
                if (X(m)) {
                    o[0] = 0
                } else {
                    var f = -e / m;
                    if (f >= 0 && f <= 1) {
                        o[j++] = f
                    }
                }
            } else {
                var Ab = x * x - 4 * Aa * y;
                if (X(Ab)) {
                    var t = x / Aa;
                    var f = -m / p + t;
                    var i = -t / 2;
                    if (f >= 0 && f <= 1) {
                        o[j++] = f
                    }
                    if (i >= 0 && i <= 1) {
                        o[j++] = i
                    }
                } else {
                    if (Ab > 0) {
                        var u = A(Ab);
                        var h = Aa * m + 1.5 * p * (-x + u);
                        var k = Aa * m + 1.5 * p * (-x - u);
                        if (h < 0) {
                            h = -U(-h, Y)
                        } else {
                            h = U(h, Y)
                        }
                        if (k < 0) {
                            k = -U(-k, Y)
                        } else {
                            k = U(k, Y)
                        }
                        var f = (-m - (h + k)) / (3 * p);
                        if (f >= 0 && f <= 1) {
                            o[j++] = f
                        }
                    } else {
                        var q = (2 * Aa * m - 3 * p * x) / (2 * A(Aa * Aa * Aa));
                        var w = Math.acos(q) / 3;
                        var l = A(Aa);
                        var Ac = Math.cos(w);
                        var f = (-m - 2 * l * Ac) / (3 * p);
                        var i = (-m + l * (Ac + c * Math.sin(w))) / (3 * p);
                        var Ad = (-m + l * (Ac - c * Math.sin(w))) / (3 * p);
                        if (f >= 0 && f <= 1) {
                            o[j++] = f
                        }
                        if (i >= 0 && i <= 1) {
                            o[j++] = i
                        }
                        if (Ad >= 0 && Ad <= 1) {
                            o[j++] = Ad
                        }
                    }
                }
            }
            return j
        }

        function Z(h, e, k, j, q) {
            var l = 6 * k - 12 * e + 6 * h;
            var p = 9 * e + 3 * j - 3 * h - 9 * k;
            var m = 3 * e - 3 * h;
            var o = 0;
            if (X(p)) {
                if (P(l)) {
                    var g = -m / l;
                    if (g >= 0 && g <= 1) {
                        q[o++] = g
                    }
                }
            } else {
                var d = l * l - 4 * p * m;
                if (X(d)) {
                    q[0] = -l / (2 * p)
                } else {
                    if (d > 0) {
                        var i = A(d);
                        var g = (-l + i) / (2 * p);
                        var f = (-l - i) / (2 * p);
                        if (g >= 0 && g <= 1) {
                            q[o++] = g
                        }
                        if (f >= 0 && f <= 1) {
                            q[o++] = f
                        }
                    }
                }
            }
            return o
        }

        function G(g, j, k, i, e, d) {
            var n = (j - g) * e + g;
            var f = (k - j) * e + j;
            var m = (i - k) * e + k;
            var h = (f - n) * e + n;
            var l = (m - f) * e + f;
            var o = (l - h) * e + h;
            d[0] = g;
            d[1] = n;
            d[2] = h;
            d[3] = o;
            d[4] = o;
            d[5] = l;
            d[6] = m;
            d[7] = i
        }

        function Q(k, l, u, v, Aa, Ab, n, o, w, z, q) {
            var f;
            var g = 0.005;
            var p = Infinity;
            var s;
            var r;
            var m;
            var j;
            M[0] = w;
            M[1] = z;
            for (var e = 0; e < 1; e += 0.05) {
                L[0] = S(k, u, Aa, n, e);
                L[1] = S(l, v, Ab, o, e);
                m = a(M, L);
                if (m < p) {
                    f = e;
                    p = m
                }
            }
            p = Infinity;
            for (var h = 0; h < 32; h++) {
                if (g < F) {
                    break
                }
                s = f - g;
                r = f + g;
                L[0] = S(k, u, Aa, n, s);
                L[1] = S(l, v, Ab, o, s);
                m = a(L, M);
                if (s >= 0 && m < p) {
                    f = s;
                    p = m
                } else {
                    O[0] = S(k, u, Aa, n, r);
                    O[1] = S(l, v, Ab, o, r);
                    j = a(O, M);
                    if (r <= 1 && j < p) {
                        f = r;
                        p = j
                    } else {
                        g *= 0.5
                    }
                }
            }
            if (q) {
                q[0] = S(k, u, Aa, n, f);
                q[1] = S(l, v, Ab, o, f)
            }
            return A(p)
        }

        function b(e, f, h, g) {
            var d = 1 - g;
            return d * (d * e + 2 * g * f) + g * g * h
        }

        function K(d, e, g, f) {
            return 2 * ((1 - f) * (e - d) + f * (g - e))
        }

        function B(e, i, j, h, p) {
            var o = e - 2 * i + j;
            var k = 2 * (i - e);
            var l = e - h;
            var m = 0;
            if (X(o)) {
                if (P(k)) {
                    var g = -l / k;
                    if (g >= 0 && g <= 1) {
                        p[m++] = g
                    }
                }
            } else {
                var d = k * k - 4 * o * l;
                if (X(d)) {
                    var g = -k / (2 * o);
                    if (g >= 0 && g <= 1) {
                        p[m++] = g
                    }
                } else {
                    if (d > 0) {
                        var q = A(d);
                        var g = (-k + q) / (2 * o);
                        var f = (-k - q) / (2 * o);
                        if (g >= 0 && g <= 1) {
                            p[m++] = g
                        }
                        if (f >= 0 && f <= 1) {
                            p[m++] = f
                        }
                    }
                }
            }
            return m
        }

        function E(d, f, g) {
            var e = d + g - 2 * f;
            if (e === 0) {
                return 0.5
            } else {
                return (d - f) / e
            }
        }

        function W(g, i, j, e, d) {
            var k = (i - g) * e + g;
            var f = (j - i) * e + i;
            var h = (f - k) * e + k;
            d[0] = g;
            d[1] = k;
            d[2] = h;
            d[3] = h;
            d[4] = f;
            d[5] = j
        }

        function D(j, k, r, s, w, z, u, v, o) {
            var f;
            var g = 0.005;
            var n = Infinity;
            M[0] = u;
            M[1] = v;
            for (var e = 0; e < 1; e += 0.05) {
                L[0] = b(j, r, w, e);
                L[1] = b(k, s, z, e);
                var l = a(M, L);
                if (l < n) {
                    f = e;
                    n = l
                }
            }
            n = Infinity;
            for (var h = 0; h < 32; h++) {
                if (g < F) {
                    break
                }
                var q = f - g;
                var p = f + g;
                L[0] = b(j, r, w, q);
                L[1] = b(k, s, z, q);
                var l = a(L, M);
                if (q >= 0 && l < n) {
                    f = q;
                    n = l
                } else {
                    O[0] = b(j, r, w, p);
                    O[1] = b(k, s, z, p);
                    var m = a(O, M);
                    if (p <= 1 && m < n) {
                        f = p;
                        n = m
                    } else {
                        g *= 0.5
                    }
                }
            }
            if (o) {
                o[0] = b(j, r, w, f);
                o[1] = b(k, s, z, f)
            }
            return A(n)
        }

        T.exports = {
            cubicAt: S,
            cubicDerivativeAt: H,
            cubicRootAt: N,
            cubicExtrema: Z,
            cubicSubdivide: G,
            cubicProjectPoint: Q,
            quadraticAt: b,
            quadraticDerivativeAt: K,
            quadraticRootAt: B,
            quadraticExtremum: E,
            quadraticSubdivide: W,
            quadraticProjectPoint: D
        }
    }, function(O, P, H) {
        var J = H(10);
        var B = H(37);
        var N = {};
        var C = Math.min;
        var M = Math.max;
        var L = Math.sin;
        var A = Math.cos;
        var D = J.create();
        var G = J.create();
        var I = J.create();
        var E = Math.PI * 2;
        N.fromPoints = function(Y, S, T) {
            if (Y.length === 0) {
                return
            }
            var Q = Y[0];
            var V = Q[0];
            var R = Q[0];
            var U = Q[1];
            var X = Q[1];
            var W;
            for (W = 1; W < Y.length; W++) {
                Q = Y[W];
                V = C(V, Q[0]);
                R = M(R, Q[0]);
                U = C(U, Q[1]);
                X = M(X, Q[1])
            }
            S[0] = V;
            S[1] = U;
            T[0] = R;
            T[1] = X
        };
        N.fromLine = function(R, S, T, U, Q, V) {
            Q[0] = C(R, T);
            Q[1] = C(S, U);
            V[0] = M(R, T);
            V[1] = M(S, U)
        };
        var K = [];
        var F = [];
        N.fromCubic = function(S, T, Q, R, Z, X, W, d, f, a) {
            var V = B.cubicExtrema;
            var U = B.cubicAt;
            var Y;
            var c = V(S, Q, Z, W, K);
            f[0] = Infinity;
            f[1] = Infinity;
            a[0] = -Infinity;
            a[1] = -Infinity;
            for (Y = 0; Y < c; Y++) {
                var b = U(S, Q, Z, W, K[Y]);
                f[0] = C(b, f[0]);
                a[0] = M(b, a[0])
            }
            c = V(T, R, X, d, F);
            for (Y = 0; Y < c; Y++) {
                var e = U(T, R, X, d, F[Y]);
                f[1] = C(e, f[1]);
                a[1] = M(e, a[1])
            }
            f[0] = C(S, f[0]);
            a[0] = M(S, a[0]);
            f[0] = C(W, f[0]);
            a[0] = M(W, a[0]);
            f[1] = C(T, f[1]);
            a[1] = M(T, a[1]);
            f[1] = C(d, f[1]);
            a[1] = M(d, a[1])
        };
        N.fromQuadratic = function(U, V, S, T, W, X, d, Y) {
            var R = B.quadraticExtremum;
            var b = B.quadraticAt;
            var Q = M(C(R(U, S, W), 1), 0);
            var c = M(C(R(V, T, X), 1), 0);
            var Z = b(U, S, W, Q);
            var a = b(V, T, X, c);
            d[0] = C(U, W, Z);
            d[1] = C(V, X, a);
            Y[0] = M(U, W, Z);
            Y[1] = M(V, X, a)
        };
        N.fromArc = function(b, c, Y, Z, d, Q, U, S, T) {
            var R = J.min;
            var X = J.max;
            var V = Math.abs(d - Q);
            if (V % E < 0.0001 && V > 0.0001) {
                S[0] = b - Y;
                S[1] = c - Z;
                T[0] = b + Y;
                T[1] = c + Z;
                return
            }
            D[0] = A(d) * Y + b;
            D[1] = L(d) * Z + c;
            G[0] = A(Q) * Y + b;
            G[1] = L(Q) * Z + c;
            R(S, D, G);
            X(T, D, G);
            d = d % (E);
            if (d < 0) {
                d = d + E
            }
            Q = Q % (E);
            if (Q < 0) {
                Q = Q + E
            }
            if (d > Q && !U) {
                Q += E
            } else {
                if (d < Q && U) {
                    d += E
                }
            }
            if (U) {
                var W = Q;
                Q = d;
                d = W
            }
            for (var a = 0; a < Q; a += Math.PI / 2) {
                if (a > d) {
                    I[0] = A(a) * Y + b;
                    I[1] = L(a) * Z + c;
                    R(S, I, S);
                    X(T, I, T)
                }
            }
        };
        O.exports = N
    }, function(C, F, S) {
        var V = S(36).CMD;
        var E = S(40);
        var P = S(41);
        var A = S(42);
        var O = S(43);
        var T = S(44).normalizeRadian;
        var Q = S(37);
        var D = S(45);
        var U = E.containStroke;
        var R = Math.PI * 2;
        var G = 0.0001;

        function K(X, W) {
            return Math.abs(X - W) < G
        }

        var I = [-1, -1, -1];
        var L = [-1, -1];

        function H() {
            var W = L[0];
            L[0] = L[1];
            L[1] = W
        }

        function B(b, c, k, l, o, p, d, e, m, n) {
            if ((n > c && n > l && n > p && n > e) || (n < c && n < l && n < p && n < e)) {
                return 0
            }
            var Z = Q.cubicRootAt(c, l, p, e, n, I);
            if (Z === 0) {
                return 0
            } else {
                var X = 0;
                var g = -1;
                var W, f;
                for (var a = 0; a < Z; a++) {
                    var Y = I[a];
                    var j = (Y === 0 || Y === 1) ? 0.5 : 1;
                    var h = Q.cubicAt(b, k, o, d, Y);
                    if (h < m) {
                        continue
                    }
                    if (g < 0) {
                        g = Q.cubicExtrema(c, l, p, e, L);
                        if (L[1] < L[0] && g > 1) {
                            H()
                        }
                        W = Q.cubicAt(c, l, p, e, L[0]);
                        if (g > 1) {
                            f = Q.cubicAt(c, l, p, e, L[1])
                        }
                    }
                    if (g == 2) {
                        if (Y < L[0]) {
                            X += W < c ? j : -j
                        } else {
                            if (Y < L[1]) {
                                X += f < W ? j : -j
                            } else {
                                X += e < f ? j : -j
                            }
                        }
                    } else {
                        if (Y < L[0]) {
                            X += W < c ? j : -j
                        } else {
                            X += e < W ? j : -j
                        }
                    }
                }
                return X
            }
        }

        function J(b, c, Y, Z, d, e, h, j) {
            if ((j > c && j > Z && j > e) || (j < c && j < Z && j < e)) {
                return 0
            }
            var X = Q.quadraticRootAt(c, Z, e, j, I);
            if (X === 0) {
                return 0
            } else {
                var a = Q.quadraticExtremum(c, Z, e);
                if (a >= 0 && a <= 1) {
                    var f = 0;
                    var g = Q.quadraticAt(c, Z, e, a);
                    for (var k = 0; k < X; k++) {
                        var l = (I[k] === 0 || I[k] === 1) ? 0.5 : 1;
                        var W = Q.quadraticAt(b, Y, d, I[k]);
                        if (W < h) {
                            continue
                        }
                        if (I[k] < a) {
                            f += g < c ? l : -l
                        } else {
                            f += e < g ? l : -l
                        }
                    }
                    return f
                } else {
                    var l = (I[0] === 0 || I[0] === 1) ? 0.5 : 1;
                    var W = Q.quadraticAt(b, Y, d, I[0]);
                    if (W < h) {
                        return 0
                    }
                    return e < c ? l : -l
                }
            }
        }

        function N(d, b, W, l, X, e, h, j) {
            j -= b;
            if (j > W || j < -W) {
                return 0
            }
            var c = Math.sqrt(W * W - j * j);
            I[0] = -c;
            I[1] = c;
            var Z = Math.abs(l - X);
            if (Z < 0.0001) {
                return 0
            }
            if (Z % R < 0.0001) {
                l = 0;
                X = R;
                var Y = e ? 1 : -1;
                if (h >= I[0] + d && h <= I[1] + d) {
                    return Y
                } else {
                    return 0
                }
            }
            if (e) {
                var c = l;
                l = T(X);
                X = T(c)
            } else {
                l = T(l);
                X = T(X)
            }
            if (l > X) {
                X += R
            }
            var a = 0;
            for (var f = 0; f < 2; f++) {
                var k = I[f];
                if (k + d > h) {
                    var g = Math.atan2(j, k);
                    var Y = e ? 1 : -1;
                    if (g < 0) {
                        g = R + g
                    }
                    if ((g >= l && g <= X) || (g + R >= l && g + R <= X)) {
                        if (g > Math.PI / 2 && g < Math.PI * 1.5) {
                            Y = -Y
                        }
                        a += Y
                    }
                }
            }
            return a
        }

        function M(r, p, h, s, t) {
            var o = 0;
            var Z = 0;
            var a = 0;
            var f = 0;
            var g = 0;
            for (var c = 0; c < r.length;) {
                var k = r[c++];
                if (k === V.M && c > 1) {
                    if (!h) {
                        o += D(Z, a, f, g, s, t)
                    }
                }
                if (c == 1) {
                    Z = r[c];
                    a = r[c + 1];
                    f = Z;
                    g = a
                }
                switch (k) {
                    case V.M:
                        f = r[c++];
                        g = r[c++];
                        Z = f;
                        a = g;
                        break;
                    case V.L:
                        if (h) {
                            if (U(Z, a, r[c], r[c + 1], p, s, t)) {
                                return true
                            }
                        } else {
                            o += D(Z, a, r[c], r[c + 1], s, t) || 0
                        }
                        Z = r[c++];
                        a = r[c++];
                        break;
                    case V.C:
                        if (h) {
                            if (P.containStroke(Z, a, r[c++], r[c++], r[c++], r[c++], r[c], r[c + 1], p, s, t)) {
                                return true
                            }
                        } else {
                            o += B(Z, a, r[c++], r[c++], r[c++], r[c++], r[c], r[c + 1], s, t) || 0
                        }
                        Z = r[c++];
                        a = r[c++];
                        break;
                    case V.Q:
                        if (h) {
                            if (A.containStroke(Z, a, r[c++], r[c++], r[c], r[c + 1], p, s, t)) {
                                return true
                            }
                        } else {
                            o += J(Z, a, r[c++], r[c++], r[c], r[c + 1], s, t) || 0
                        }
                        Z = r[c++];
                        a = r[c++];
                        break;
                    case V.A:
                        var b = r[c++];
                        var m = r[c++];
                        var v = r[c++];
                        var d = r[c++];
                        var l = r[c++];
                        var n = r[c++];
                        var j = r[c++];
                        var W = 1 - r[c++];
                        var q = Math.cos(l) * v + b;
                        var Y = Math.sin(l) * d + m;
                        if (c > 1) {
                            o += D(Z, a, q, Y, s, t)
                        } else {
                            f = q;
                            g = Y
                        }
                        var X = (s - b) * d / v + b;
                        if (h) {
                            if (O.containStroke(b, m, d, l, l + n, W, p, X, t)) {
                                return true
                            }
                        } else {
                            o += N(b, m, d, l, l + n, W, X, t)
                        }
                        Z = Math.cos(l + n) * v + b;
                        a = Math.sin(l + n) * d + m;
                        break;
                    case V.R:
                        f = Z = r[c++];
                        g = a = r[c++];
                        var e = r[c++];
                        var u = r[c++];
                        var q = f + e;
                        var Y = g + u;
                        if (h) {
                            if (U(f, g, q, g, p, s, t) || U(q, g, q, Y, p, s, t) || U(q, Y, f, Y, p, s, t) || U(f, Y, f, g, p, s, t)) {
                                return true
                            }
                        } else {
                            o += D(q, g, q, Y, s, t);
                            o += D(f, Y, f, g, s, t)
                        }
                        break;
                    case V.Z:
                        if (h) {
                            if (U(Z, a, f, g, p, s, t)) {
                                return true
                            }
                        } else {
                            o += D(Z, a, f, g, s, t)
                        }
                        Z = f;
                        a = g;
                        break
                }
            }
            if (!h && !K(a, g)) {
                o += D(Z, a, f, g, s, t) || 0
            }
            return o !== 0
        }

        C.exports = {
            contain: function(Y, W, X) {
                return M(Y, 0, false, W, X)
            }, containStroke: function(Y, X, W, Z) {
                return M(Y, X, true, W, Z)
            }
        }
    }, function(A, B) {
        A.exports = {
            containStroke: function(F, G, C, D, I, K, L) {
                if (I === 0) {
                    return false
                }
                var N = I;
                var E = 0;
                var J = F;
                if ((L > G + N && L > D + N) || (L < G - N && L < D - N) || (K > F + N && K > C + N) || (K < F - N && K < C - N)) {
                    return false
                }
                if (F !== C) {
                    E = (G - D) / (F - C);
                    J = (F * D - C * G) / (F - C)
                } else {
                    return Math.abs(K - F) <= N / 2
                }
                var H = E * K - L + J;
                var M = H * H / (E * E + 1);
                return M <= N / 2 * N / 2
            }
        }
    }, function(B, C, A) {
        var D = A(37);
        B.exports = {
            containStroke: function(G, H, E, F, L, J, I, O, K, M, N) {
                if (K === 0) {
                    return false
                }
                var P = K;
                if ((N > H + P && N > F + P && N > J + P && N > O + P) || (N < H - P && N < F - P && N < J - P && N < O - P) || (M > G + P && M > E + P && M > L + P && M > I + P) || (M < G - P && M < E - P && M < L - P && M < I - P)) {
                    return false
                }
                var Q = D.cubicProjectPoint(G, H, E, F, L, J, I, O, M, N, null);
                return Q <= P / 2
            }
        }
    }, function(B, C, A) {
        var D = A(37);
        B.exports = {
            containStroke: function(G, H, E, F, I, K, J, L, M) {
                if (J === 0) {
                    return false
                }
                var N = J;
                if ((M > H + N && M > F + N && M > K + N) || (M < H - N && M < F - N && M < K - N) || (L > G + N && L > E + N && L > I + N) || (L < G - N && L < E - N && L < I - N)) {
                    return false
                }
                var O = D.quadraticProjectPoint(G, H, E, F, I, K, L, M, null);
                return O <= N / 2
            }
        }
    }, function(B, D, A) {
        var C = A(44).normalizeRadian;
        var E = Math.PI * 2;
        B.exports = {
            containStroke: function(K, I, F, R, G, M, L, O, P) {
                if (L === 0) {
                    return false
                }
                var Q = L;
                O -= K;
                P -= I;
                var H = Math.sqrt(O * O + P * P);
                if ((H - Q > F) || (H + Q < F)) {
                    return false
                }
                if (Math.abs(R - G) % E < 0.0001) {
                    return true
                }
                if (M) {
                    var J = R;
                    R = C(G);
                    G = C(J)
                } else {
                    R = C(R);
                    G = C(G)
                }
                if (R > G) {
                    G += E
                }
                var N = Math.atan2(P, O);
                if (N < 0) {
                    N += E
                }
                return (N >= R && N <= G) || (N + E >= R && N + E <= G)
            }
        }
    }, function(A, B) {
        var C = Math.PI * 2;
        A.exports = {
            normalizeRadian: function(D) {
                D %= C;
                if (D < 0) {
                    D += C
                }
                return D
            }
        }
    }, function(A, C) {
        A.exports = function B(H, I, E, F, K, L) {
            if ((L > I && L > F) || (L < I && L < F)) {
                return 0
            }
            if (F === I) {
                return 0
            }
            var D = F < I ? 1 : -1;
            var G = (L - I) / (F - I);
            if (G === 1 || G === 0) {
                D = F < I ? 0.5 : -0.5
            }
            var J = G * (E - H) + H;
            return J > K ? D : 0
        }
    }, function(B, C) {
        var A = function(D, E) {
            this.image = D;
            this.repeat = E;
            this.type = "pattern"
        };
        A.prototype.getCanvasPattern = function(D) {
            return D.createPattern(this.image, this.repeat || "repeat")
        };
        B.exports = A
    }, function(I, J, C) {
        var G = C(36).CMD;
        var E = C(10);
        var F = E.applyTransform;
        var H = [[], [], []];
        var A = Math.sqrt;
        var B = Math.atan2;

        function D(W, U) {
            var c = W.data;
            var X;
            var P;
            var S;
            var N;
            var O;
            var K;
            var Z = G.M;
            var a = G.C;
            var Y = G.L;
            var g = G.R;
            var b = G.A;
            var V = G.Q;
            for (S = 0, N = 0; S < c.length;) {
                X = c[S++];
                N = S;
                P = 0;
                switch (X) {
                    case Z:
                        P = 1;
                        break;
                    case Y:
                        P = 1;
                        break;
                    case a:
                        P = 3;
                        break;
                    case V:
                        P = 2;
                        break;
                    case b:
                        var e = U[4];
                        var f = U[5];
                        var d = A(U[0] * U[0] + U[1] * U[1]);
                        var T = A(U[2] * U[2] + U[3] * U[3]);
                        var h = B(-U[1] / T, U[0] / d);
                        c[S] *= d;
                        c[S++] += e;
                        c[S] *= T;
                        c[S++] += f;
                        c[S++] *= d;
                        c[S++] *= T;
                        c[S++] += h;
                        c[S++] += h;
                        S += 2;
                        N = S;
                        break;
                    case g:
                        K[0] = c[S++];
                        K[1] = c[S++];
                        F(K, K, U);
                        c[N++] = K[0];
                        c[N++] = K[1];
                        K[0] += c[S++];
                        K[1] += c[S++];
                        F(K, K, U);
                        c[N++] = K[0];
                        c[N++] = K[1]
                }
                for (O = 0; O < P; O++) {
                    var K = H[O];
                    K[0] = c[S++];
                    K[1] = c[S++];
                    F(K, K, U);
                    c[N++] = K[0];
                    c[N++] = K[1]
                }
            }
        }

        I.exports = D
    }, function(E, G, C) {
        var B = C(4);
        var F = C(23);
        var A = C(9);
        var D = function(I) {
            I = I || {};
            F.call(this, I);
            for (var H in I) {
                if (I.hasOwnProperty(H)) {
                    this[H] = I[H]
                }
            }
            this._children = [];
            this.__storage = null;
            this.__dirty = true
        };
        D.prototype = {
            constructor: D, isGroup: true, type: "group", silent: false, children: function() {
                return this._children.slice()
            }, childAt: function(H) {
                return this._children[H]
            }, childOfName: function(I) {
                var J = this._children;
                for (var H = 0; H < J.length; H++) {
                    if (J[H].name === I) {
                        return J[H]
                    }
                }
            }, childCount: function() {
                return this._children.length
            }, add: function(H) {
                if (H && H !== this && H.parent !== this) {
                    this._children.push(H);
                    this._doAdd(H)
                }
                return this
            }, addBefore: function(H, J) {
                if (H && H !== this && H.parent !== this && J && J.parent === this) {
                    var K = this._children;
                    var I = K.indexOf(J);
                    if (I >= 0) {
                        K.splice(I, 0, H);
                        this._doAdd(H)
                    }
                }
                return this
            }, _doAdd: function(J) {
                if (J.parent) {
                    J.parent.remove(J)
                }
                J.parent = this;
                var H = this.__storage;
                var I = this.__zr;
                if (H && H !== J.__storage) {
                    H.addToStorage(J);
                    if (J instanceof D) {
                        J.addChildrenToStorage(H)
                    }
                }
                I && I.refresh()
            }, remove: function(J) {
                var I = this.__zr;
                var H = this.__storage;
                var L = this._children;
                var K = B.indexOf(L, J);
                if (K < 0) {
                    return this
                }
                L.splice(K, 1);
                J.parent = null;
                if (H) {
                    H.delFromStorage(J);
                    if (J instanceof D) {
                        J.delChildrenFromStorage(H)
                    }
                }
                I && I.refresh();
                return this
            }, removeAll: function() {
                var K = this._children;
                var H = this.__storage;
                var J;
                var I;
                for (I = 0; I < K.length; I++) {
                    J = K[I];
                    if (H) {
                        H.delFromStorage(J);
                        if (J instanceof D) {
                            J.delChildrenFromStorage(H)
                        }
                    }
                    J.parent = null
                }
                K.length = 0;
                return this
            }, eachChild: function(H, I) {
                var L = this._children;
                for (var J = 0; J < L.length; J++) {
                    var K = L[J];
                    H.call(I, K, J)
                }
                return this
            }, traverse: function(H, I) {
                for (var J = 0; J < this._children.length; J++) {
                    var K = this._children[J];
                    H.call(I, K);
                    if (K.type === "group") {
                        K.traverse(H, I)
                    }
                }
                return this
            }, addChildrenToStorage: function(H) {
                for (var I = 0; I < this._children.length; I++) {
                    var J = this._children[I];
                    H.addToStorage(J);
                    if (J instanceof D) {
                        J.addChildrenToStorage(H)
                    }
                }
            }, delChildrenFromStorage: function(H) {
                for (var I = 0; I < this._children.length; I++) {
                    var J = this._children[I];
                    H.delFromStorage(J);
                    if (J instanceof D) {
                        J.delChildrenFromStorage(H)
                    }
                }
            }, dirty: function() {
                this.__dirty = true;
                this.__zr && this.__zr.refresh();
                return this
            }, getBoundingRect: function(O) {
                var L = null;
                var P = new A(0, 0, 0, 0);
                var K = O || this._children;
                var J = [];
                for (var M = 0; M < K.length; M++) {
                    var I = K[M];
                    if (I.ignore || I.invisible) {
                        continue
                    }
                    var H = I.getBoundingRect();
                    var N = I.getLocalTransform(J);
                    if (N) {
                        P.copy(H);
                        P.applyTransform(N);
                        L = L || P.clone();
                        L.union(P)
                    } else {
                        L = L || H.clone();
                        L.union(H)
                    }
                }
                return L || P
            }
        };
        B.inherits(D, F);
        E.exports = D
    }, function(G, I, D) {
        var E = D(21);
        var F = D(9);
        var C = D(4);
        var B = D(32);
        var H = new B(50);

        function A(J) {
            E.call(this, J)
        }

        A.prototype = {
            constructor: A, type: "image", brush: function(O, T) {
                var P = this.style;
                var J = P.image;
                var W;
                P.bind(O, this, T);
                if (typeof J === "string") {
                    W = this._image
                } else {
                    W = J
                }
                if (!W && J) {
                    var M = H.get(J);
                    if (!M) {
                        W = new Image();
                        W.onload = function() {
                            W.onload = null;
                            for (var Y = 0; Y < M.pending.length; Y++) {
                                M.pending[Y].dirty()
                            }
                        };
                        M = {image: W, pending: [this]};
                        W.src = J;
                        H.put(J, M);
                        this._image = W;
                        return
                    } else {
                        W = M.image;
                        this._image = W;
                        if (!W.width || !W.height) {
                            M.pending.push(this);
                            return
                        }
                    }
                }
                if (W) {
                    var U = P.x || 0;
                    var V = P.y || 0;
                    if (!W.width || !W.height) {
                        return
                    }
                    var S = P.width;
                    var X = P.height;
                    var K = W.width / W.height;
                    if (S == null && X != null) {
                        S = X * K
                    } else {
                        if (X == null && S != null) {
                            X = S / K
                        } else {
                            if (S == null && X == null) {
                                S = W.width;
                                X = W.height
                            }
                        }
                    }
                    this.setTransform(O);
                    if (P.sWidth && P.sHeight) {
                        var R = P.sx || 0;
                        var Q = P.sy || 0;
                        O.drawImage(W, R, Q, P.sWidth, P.sHeight, U, V, S, X)
                    } else {
                        if (P.sx && P.sy) {
                            var R = P.sx;
                            var Q = P.sy;
                            var L = S - R;
                            var N = X - Q;
                            O.drawImage(W, R, Q, L, N, U, V, S, X)
                        } else {
                            O.drawImage(W, U, V, S, X)
                        }
                    }
                    this.restoreTransform(O);
                    if (P.text != null) {
                        this.drawRectText(O, this.getBoundingRect())
                    }
                }
            }, getBoundingRect: function() {
                var J = this.style;
                if (!this._rect) {
                    this._rect = new F(J.x || 0, J.y || 0, J.width || 0, J.height || 0)
                }
                return this._rect
            }
        };
        C.inherits(A, E);
        G.exports = A
    }, function(E, G, C) {
        var D = C(21);
        var B = C(4);
        var F = C(8);
        var A = function(H) {
            D.call(this, H)
        };
        A.prototype = {
            constructor: A, type: "text", brush: function(M, Q) {
                var N = this.style;
                var R = N.x || 0;
                var S = N.y || 0;
                var O = N.text;
                O != null && (O += "");
                N.bind(M, this, Q);
                if (O) {
                    this.setTransform(M);
                    var T;
                    var H = N.textAlign;
                    var K = N.textFont || N.font;
                    if (N.textVerticalAlign) {
                        var J = F.getBoundingRect(O, K, N.textAlign, "top");
                        T = "middle";
                        switch (N.textVerticalAlign) {
                            case"middle":
                                S -= J.height / 2 - J.lineHeight / 2;
                                break;
                            case"bottom":
                                S -= J.height - J.lineHeight / 2;
                                break;
                            default:
                                S += J.lineHeight / 2
                        }
                    } else {
                        T = N.textBaseline
                    }
                    M.font = K || "12px sans-serif";
                    M.textAlign = H || "left";
                    if (M.textAlign !== H) {
                        M.textAlign = "left"
                    }
                    M.textBaseline = T || "alphabetic";
                    if (M.textBaseline !== T) {
                        M.textBaseline = "alphabetic"
                    }
                    var L = F.measureText("", M.font).width;
                    var I = O.split("\n");
                    for (var P = 0; P < I.length; P++) {
                        N.hasStroke() && M.strokeText(I[P], R, S);
                        N.hasFill() && M.fillText(I[P], R, S);
                        S += L
                    }
                    this.restoreTransform(M)
                }
            }, getBoundingRect: function() {
                var I = this.style;
                if (!this._rect) {
                    var K = I.textVerticalAlign;
                    var H = F.getBoundingRect(I.text + "", I.textFont || I.font, I.textAlign, K ? "top" : I.textBaseline);
                    switch (K) {
                        case"middle":
                            H.y -= H.height / 2;
                            break;
                        case"bottom":
                            H.y -= H.height;
                            break
                    }
                    H.x += I.x || 0;
                    H.y += I.y || 0;
                    if (I.hasStroke()) {
                        var J = I.lineWidth;
                        H.x -= J / 2;
                        H.y -= J / 2;
                        H.width += J;
                        H.height += J
                    }
                    this._rect = H
                }
                return this._rect
            }
        };
        B.inherits(A, D);
        E.exports = A
    }, function(B, C, A) {
        B.exports = A(20).extend({
            type: "circle", shape: {cx: 0, cy: 0, r: 0}, buildPath: function(E, F, D) {
                if (D) {
                    E.moveTo(F.cx + F.r, F.cy)
                }
                E.arc(F.cx, F.cy, F.r, 0, Math.PI * 2, true)
            }
        })
    }, function(E, F, C) {
        var A = C(2);
        var B = C(20);
        var D = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];
        E.exports = B.extend({
            type: "sector",
            shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true},
            brush: (A.browser.ie && A.browser.version >= 11) ? function() {
                var I = this.__clipPaths;
                var J = this.style;
                var H;
                if (I) {
                    for (var G = 0; G < I.length; G++) {
                        var L = I[G] && I[G].shape;
                        if (L && L.startAngle === L.endAngle) {
                            for (var K = 0; K < D.length; K++) {
                                D[K][2] = J[D[K][0]];
                                J[D[K][0]] = D[K][1]
                            }
                            H = true;
                            break
                        }
                    }
                }
                B.prototype.brush.apply(this, arguments);
                if (H) {
                    for (var K = 0; K < D.length; K++) {
                        J[D[K][0]] = D[K][2]
                    }
                }
            } : B.prototype.brush,
            buildPath: function(K, I) {
                var M = I.cx;
                var N = I.cy;
                var L = Math.max(I.r0 || 0, 0);
                var G = Math.max(I.r, 0);
                var Q = I.startAngle;
                var H = I.endAngle;
                var J = I.clockwise;
                var O = Math.cos(Q);
                var P = Math.sin(Q);
                K.moveTo(O * L + M, P * L + N);
                K.lineTo(O * G + M, P * G + N);
                K.arc(M, N, G, Q, H, !J);
                K.lineTo(Math.cos(H) * L + M, Math.sin(H) * L + N);
                if (L !== 0) {
                    K.arc(M, N, L, H, Q, J)
                }
                K.closePath()
            }
        })
    }, function(B, C, A) {
        B.exports = A(20).extend({
            type: "ring", shape: {cx: 0, cy: 0, r: 0, r0: 0}, buildPath: function(F, H) {
                var D = H.cx;
                var E = H.cy;
                var G = Math.PI * 2;
                F.moveTo(D + H.r, E);
                F.arc(D, E, H.r, 0, G, false);
                F.moveTo(D + H.r0, E);
                F.arc(D, E, H.r0, 0, G, true)
            }
        })
    }, function(B, D, A) {
        var C = A(55);
        B.exports = A(20).extend({
            type: "polygon", shape: {points: null, smooth: false, smoothConstraint: null}, buildPath: function(E, F) {
                C.buildPath(E, F, true)
            }
        })
    }, function(C, E, B) {
        var A = B(56);
        var D = B(57);
        C.exports = {
            buildPath: function(J, I, K) {
                var H = I.points;
                var F = I.smooth;
                if (H && H.length >= 2) {
                    if (F && F !== "spline") {
                        var M = D(H, F, K, I.smoothConstraint);
                        J.moveTo(H[0][0], H[0][1]);
                        var N = H.length;
                        for (var L = 0; L < (K ? N : N - 1); L++) {
                            var O = M[L * 2];
                            var Q = M[L * 2 + 1];
                            var G = H[(L + 1) % N];
                            J.bezierCurveTo(O[0], O[1], Q[0], Q[1], G[0], G[1])
                        }
                    } else {
                        if (F === "spline") {
                            H = A(H, K)
                        }
                        J.moveTo(H[0][0], H[0][1]);
                        for (var L = 1, P = H.length; L < P; L++) {
                            J.lineTo(H[L][0], H[L][1])
                        }
                    }
                    K && J.closePath()
                }
            }
        }
    }, function(C, E, B) {
        var A = B(10);

        function D(H, F, K, I, G, N, L) {
            var M = (K - H) * 0.5;
            var J = (I - F) * 0.5;
            return (2 * (F - K) + M + J) * L + (-3 * (F - K) - 2 * M - J) * N + M * G + F
        }

        C.exports = function(H, L) {
            var Q = H.length;
            var T = [];
            var N = 0;
            for (var M = 1; M < Q; M++) {
                N += A.distance(H[M - 1], H[M])
            }
            var R = N / 2;
            R = R < Q ? Q : R;
            for (var M = 0; M < R; M++) {
                var O = M / (R - 1) * (L ? Q : Q - 1);
                var K = Math.floor(O);
                var I = O - K;
                var P;
                var F = H[K % Q];
                var S;
                var G;
                if (!L) {
                    P = H[K === 0 ? K : K - 1];
                    S = H[K > Q - 2 ? Q - 1 : K + 1];
                    G = H[K > Q - 3 ? Q - 1 : K + 2]
                } else {
                    P = H[(K - 1 + Q) % Q];
                    S = H[(K + 1) % Q];
                    G = H[(K + 2) % Q]
                }
                var U = I * I;
                var J = I * U;
                T.push([D(P[0], F[0], S[0], G[0], I, U, J), D(P[1], F[1], S[1], G[1], I, U, J)])
            }
            return T
        }
    }, function(H, I, D) {
        var G = D(10);
        var E = G.min;
        var C = G.max;
        var A = G.scale;
        var B = G.distance;
        var F = G.add;
        H.exports = function(U, Y, c, T) {
            var N = [];
            var Z = [];
            var J = [];
            var M = [];
            var P;
            var X;
            var S, a;
            if (T) {
                S = [Infinity, Infinity];
                a = [-Infinity, -Infinity];
                for (var O = 0, K = U.length; O < K; O++) {
                    E(S, S, U[O]);
                    C(a, a, U[O])
                }
                E(S, S, T[0]);
                C(a, a, T[1])
            }
            for (var O = 0, K = U.length; O < K; O++) {
                var L = U[O];
                if (c) {
                    P = U[O ? O - 1 : K - 1];
                    X = U[(O + 1) % K]
                } else {
                    if (O === 0 || O === K - 1) {
                        N.push(G.clone(U[O]));
                        continue
                    } else {
                        P = U[O - 1];
                        X = U[O + 1]
                    }
                }
                G.sub(Z, X, P);
                A(Z, Z, Y);
                var b = B(L, P);
                var Q = B(L, X);
                var R = b + Q;
                if (R !== 0) {
                    b /= R;
                    Q /= R
                }
                A(J, Z, -b);
                A(M, Z, Q);
                var W = F([], L, J);
                var V = F([], L, M);
                if (T) {
                    C(W, W, S);
                    E(W, W, a);
                    C(V, V, S);
                    E(V, V, a)
                }
                N.push(W);
                N.push(V)
            }
            if (c) {
                N.push(N.shift())
            }
            return N
        }
    }, function(B, D, A) {
        var C = A(55);
        B.exports = A(20).extend({
            type: "polyline",
            shape: {points: null, smooth: false, smoothConstraint: null},
            style: {stroke: "#000", fill: null},
            buildPath: function(E, F) {
                C.buildPath(E, F, false)
            }
        })
    }, function(C, D, B) {
        var A = B(60);
        C.exports = B(20).extend({
            type: "rect", shape: {r: 0, x: 0, y: 0, width: 0, height: 0}, buildPath: function(I, J) {
                var G = J.x;
                var H = J.y;
                var F = J.width;
                var E = J.height;
                if (!J.r) {
                    I.rect(G, H, F, E)
                } else {
                    A.buildPath(I, J)
                }
                I.closePath();
                return
            }
        })
    }, function(A, B) {
        A.exports = {
            buildPath: function(I, F) {
                var M = F.x;
                var N = F.y;
                var L = F.width;
                var E = F.height;
                var C = F.r;
                var H;
                var J;
                var D;
                var G;
                if (L < 0) {
                    M = M + L;
                    L = -L
                }
                if (E < 0) {
                    N = N + E;
                    E = -E
                }
                if (typeof C === "number") {
                    H = J = D = G = C
                } else {
                    if (C instanceof Array) {
                        if (C.length === 1) {
                            H = J = D = G = C[0]
                        } else {
                            if (C.length === 2) {
                                H = D = C[0];
                                J = G = C[1]
                            } else {
                                if (C.length === 3) {
                                    H = C[0];
                                    J = G = C[1];
                                    D = C[2]
                                } else {
                                    H = C[0];
                                    J = C[1];
                                    D = C[2];
                                    G = C[3]
                                }
                            }
                        }
                    } else {
                        H = J = D = G = 0
                    }
                }
                var K;
                if (H + J > L) {
                    K = H + J;
                    H *= L / K;
                    J *= L / K
                }
                if (D + G > L) {
                    K = D + G;
                    D *= L / K;
                    G *= L / K
                }
                if (J + D > E) {
                    K = J + D;
                    J *= E / K;
                    D *= E / K
                }
                if (H + G > E) {
                    K = H + G;
                    H *= E / K;
                    G *= E / K
                }
                I.moveTo(M + H, N);
                I.lineTo(M + L - J, N);
                J !== 0 && I.quadraticCurveTo(M + L, N, M + L, N + J);
                I.lineTo(M + L, N + E - D);
                D !== 0 && I.quadraticCurveTo(M + L, N + E, M + L - D, N + E);
                I.lineTo(M + G, N + E);
                G !== 0 && I.quadraticCurveTo(M, N + E, M, N + E - G);
                I.lineTo(M, N + H);
                H !== 0 && I.quadraticCurveTo(M, N, M + H, N)
            }
        }
    }, function(B, C, A) {
        B.exports = A(20).extend({
            type: "line",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function(H, J) {
                var F = J.x1;
                var I = J.y1;
                var D = J.x2;
                var E = J.y2;
                var G = J.percent;
                if (G === 0) {
                    return
                }
                H.moveTo(F, I);
                if (G < 1) {
                    D = F * (1 - G) + D * G;
                    E = I * (1 - G) + E * G
                }
                H.lineTo(D, E)
            },
            pointAt: function(D) {
                var E = this.shape;
                return [E.x1 * (1 - D) + E.x2 * D, E.y1 * (1 - D) + E.y2 * D]
            }
        })
    }, function(L, M, E) {
        var J = E(37);
        var G = E(10);
        var C = J.quadraticSubdivide;
        var H = J.cubicSubdivide;
        var K = J.quadraticAt;
        var F = J.cubicAt;
        var D = J.quadraticDerivativeAt;
        var A = J.cubicDerivativeAt;
        var B = [];

        function I(R, P, N) {
            var O = R.cpx2;
            var Q = R.cpy2;
            if (O === null || Q === null) {
                return [(N ? A : F)(R.x1, R.cpx1, R.cpx2, R.x2, P), (N ? A : F)(R.y1, R.cpy1, R.cpy2, R.y2, P)]
            } else {
                return [(N ? D : K)(R.x1, R.cpx1, R.x2, P), (N ? D : K)(R.y1, R.cpy1, R.y2, P)]
            }
        }

        L.exports = E(20).extend({
            type: "bezier-curve",
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1},
            style: {stroke: "#000", fill: null},
            buildPath: function(T, Q) {
                var P = Q.x1;
                var W = Q.y1;
                var R = Q.x2;
                var S = Q.y2;
                var X = Q.cpx1;
                var U = Q.cpy1;
                var O = Q.cpx2;
                var N = Q.cpy2;
                var V = Q.percent;
                if (V === 0) {
                    return
                }
                T.moveTo(P, W);
                if (O == null || N == null) {
                    if (V < 1) {
                        C(P, X, R, V, B);
                        X = B[1];
                        R = B[2];
                        C(W, U, S, V, B);
                        U = B[1];
                        S = B[2]
                    }
                    T.quadraticCurveTo(X, U, R, S)
                } else {
                    if (V < 1) {
                        H(P, X, O, R, V, B);
                        X = B[1];
                        O = B[2];
                        R = B[3];
                        H(W, U, N, S, V, B);
                        U = B[1];
                        N = B[2];
                        S = B[3]
                    }
                    T.bezierCurveTo(X, U, O, N, R, S)
                }
            },
            pointAt: function(N) {
                return I(this.shape, N, false)
            },
            tangentAt: function(O) {
                var N = I(this.shape, O, true);
                return G.normalize(N, N)
            }
        })
    }, function(B, C, A) {
        B.exports = A(20).extend({
            type: "arc",
            shape: {cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true},
            style: {stroke: "#000", fill: null},
            buildPath: function(H, F) {
                var I = F.cx;
                var J = F.cy;
                var D = Math.max(F.r, 0);
                var M = F.startAngle;
                var E = F.endAngle;
                var G = F.clockwise;
                var K = Math.cos(M);
                var L = Math.sin(M);
                H.moveTo(K * D + I, L * D + J);
                H.arc(I, J, D, M, E, !G)
            }
        })
    }, function(C, D, B) {
        var A = B(20);
        C.exports = A.extend({
            type: "compound", shape: {paths: null}, _updatePathDirty: function() {
                var F = this.__dirtyPath;
                var G = this.shape.paths;
                for (var E = 0; E < G.length; E++) {
                    F = F || G[E].__dirtyPath
                }
                this.__dirtyPath = F;
                this.__dirty = this.__dirty || F
            }, beforeBrush: function() {
                this._updatePathDirty();
                var G = this.shape.paths || [];
                var F = this.getGlobalScale();
                for (var E = 0; E < G.length; E++) {
                    if (!G[E].path) {
                        G[E].createPathProxy()
                    }
                    G[E].path.setScale(F[0], F[1])
                }
            }, buildPath: function(G, H) {
                var F = H.paths || [];
                for (var E = 0; E < F.length; E++) {
                    F[E].buildPath(G, F[E].shape, true)
                }
            }, afterBrush: function() {
                var F = this.shape.paths;
                for (var E = 0; E < F.length; E++) {
                    F[E].__dirtyPath = false
                }
            }, getBoundingRect: function() {
                this._updatePathDirty();
                return A.prototype.getBoundingRect.call(this)
            }
        })
    }, function(D, F, B) {
        var A = B(4);
        var E = B(66);
        var C = function(J, K, G, H, L, I) {
            this.x = J == null ? 0 : J;
            this.y = K == null ? 0 : K;
            this.x2 = G == null ? 1 : G;
            this.y2 = H == null ? 0 : H;
            this.type = "linear";
            this.global = I || false;
            E.call(this, L)
        };
        C.prototype = {constructor: C};
        A.inherits(C, E);
        D.exports = C
    }, function(B, C) {
        var A = function(D) {
            this.colorStops = D || []
        };
        A.prototype = {
            constructor: A, addColorStop: function(D, E) {
                this.colorStops.push({offset: D, color: E})
            }
        };
        B.exports = A
    }, function(C, F, B) {
        var A = B(4);
        var E = B(66);
        var D = function(I, J, G, K, H) {
            this.x = I == null ? 0.5 : I;
            this.y = J == null ? 0.5 : J;
            this.r = G == null ? 0.5 : G;
            this.type = "radial";
            this.global = H || false;
            E.call(this, K)
        };
        D.prototype = {constructor: D};
        A.inherits(D, E);
        C.exports = D
    }, function(C, D, B) {
        var A = B(15)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);
        C.exports = {
            getItemStyle: function(G, E) {
                var F = A.call(this, G, E);
                var H = this.getBorderLineDash();
                H && (F.lineDash = H);
                return F
            }, getBorderLineDash: function() {
                var E = this.get("borderType");
                return (E === "solid" || E == null) ? null : (E === "dashed" ? [5, 5] : [1, 1])
            }
        }
    }, function(I, K, B) {
        var F = B(12);
        var A = B(4);
        var H = Array.prototype.push;
        var C = B(70);
        var G = B(13);
        var D = B(71);
        var J = F.extend({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            $constructor: function(L, O, M, N) {
                F.call(this, L, O, M, N);
                this.uid = C.getUID("componentModel")
            },
            init: function(L, O, M, N) {
                this.mergeDefaultAndTheme(L, M)
            },
            mergeDefaultAndTheme: function(M, N) {
                var P = this.layoutMode;
                var L = P ? D.getLayoutParams(M) : {};
                var O = N.getTheme();
                A.merge(M, O.get(this.mainType));
                A.merge(M, this.getDefaultOption());
                if (P) {
                    D.mergeLayoutParam(M, L, P)
                }
            },
            mergeOption: function(L, M) {
                A.merge(this.option, L, true);
                var N = this.layoutMode;
                if (N) {
                    D.mergeLayoutParam(this.option, L, N)
                }
            },
            optionUpdated: function(L, M) {
            },
            getDefaultOption: function() {
                if (!G.hasOwn(this, "__defaultOption")) {
                    var P = [];
                    var O = this.constructor;
                    while (O) {
                        var M = O.prototype.defaultOption;
                        M && P.push(M);
                        O = O.superClass
                    }
                    var N = {};
                    for (var L = P.length - 1; L >= 0; L--) {
                        N = A.merge(N, P[L], true)
                    }
                    G.set(this, "__defaultOption", N)
                }
                return G.get(this, "__defaultOption")
            },
            getReferringComponents: function(L) {
                return this.ecModel.queryComponents({mainType: L, index: this.get(L + "Index", true), id: this.get(L + "Id", true)})
            }
        });
        G.enableClassManagement(J, {registerWhenExtend: true});
        C.enableSubTypeDefaulter(J);
        C.enableTopologicalTravel(J, E);

        function E(L) {
            var M = [];
            A.each(J.getClassesByMainType(L), function(N) {
                H.apply(M, N.prototype.dependencies || [])
            });
            return A.map(M, function(N) {
                return G.parseClassType(N).main
            })
        }

        A.mixin(J, B(72));
        I.exports = J
    }, function(H, I, C) {
        var B = C(4);
        var G = C(13);
        var E = G.parseClassType;
        var A = 0;
        var D = {};
        var F = "_";
        D.getUID = function(J) {
            return [(J || ""), A++, Math.random()].join(F)
        };
        D.enableSubTypeDefaulter = function(K) {
            var J = {};
            K.registerSubTypeDefaulter = function(L, M) {
                L = E(L);
                J[L.main] = M
            };
            K.determineSubType = function(N, M) {
                var L = M.type;
                if (!L) {
                    var O = E(N).main;
                    if (K.hasSubTypes(N) && J[O]) {
                        L = J[O](M)
                    }
                }
                return L
            };
            return K
        };
        D.enableTopologicalTravel = function(N, M) {
            N.topologicalTravel = function(W, O, R, V) {
                if (!W.length) {
                    return
                }
                var Q = J(O);
                var S = Q.graph;
                var a = Q.noEntryList;
                var T = {};
                B.each(W, function(b) {
                    T[b] = true
                });
                while (a.length) {
                    var U = a.pop();
                    var P = S[U];
                    var Y = !!T[U];
                    if (Y) {
                        R.call(V, U, P.originalDeps.slice());
                        delete T[U]
                    }
                    B.each(P.successor, Y ? Z : X)
                }
                B.each(T, function() {
                    throw new Error("Circle dependency may exists")
                });

                function X(b) {
                    S[b].entryCount--;
                    if (S[b].entryCount === 0) {
                        a.push(b)
                    }
                }

                function Z(b) {
                    T[b] = true;
                    X(b)
                }
            };

            function J(P) {
                var O = {};
                var Q = [];
                B.each(P, function(T) {
                    var R = K(O, T);
                    var S = R.originalDeps = M(T);
                    var U = L(S, P);
                    R.entryCount = U.length;
                    if (R.entryCount === 0) {
                        Q.push(T)
                    }
                    B.each(U, function(V) {
                        if (B.indexOf(R.predecessor, V) < 0) {
                            R.predecessor.push(V)
                        }
                        var W = K(O, V);
                        if (B.indexOf(W.successor, V) < 0) {
                            W.successor.push(T)
                        }
                    })
                });
                return {graph: O, noEntryList: Q}
            }

            function K(O, P) {
                if (!O[P]) {
                    O[P] = {predecessor: [], successor: []}
                }
                return O[P]
            }

            function L(O, P) {
                var Q = [];
                B.each(O, function(R) {
                    B.indexOf(P, R) >= 0 && Q.push(R)
                });
                return Q
            }
        };
        H.exports = D
    }, function(L, M, E) {
        var D = E(4);
        var K = E(9);
        var F = E(7);
        var I = E(6);
        var G = F.parsePercent;
        var A = D.each;
        var H = {};
        var C = H.LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
        var B = H.HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];

        function J(Q, P, O, R, U) {
            var S = 0;
            var T = 0;
            if (R == null) {
                R = Infinity
            }
            if (U == null) {
                U = Infinity
            }
            var N = 0;
            P.eachChild(function(c, Y) {
                var a = c.position;
                var V = c.getBoundingRect();
                var b = P.childAt(Y + 1);
                var e = b && b.getBoundingRect();
                var W;
                var X;
                if (Q === "horizontal") {
                    var Z = V.width + (e ? (-e.x + V.x) : 0);
                    W = S + Z;
                    if (W > R || c.newline) {
                        S = 0;
                        W = Z;
                        T += N + O;
                        N = V.height
                    } else {
                        N = Math.max(N, V.height)
                    }
                } else {
                    var d = V.height + (e ? (-e.y + V.y) : 0);
                    X = T + d;
                    if (X > U || c.newline) {
                        S += N + O;
                        T = 0;
                        X = d;
                        N = V.width
                    } else {
                        N = Math.max(N, V.width)
                    }
                }
                if (c.newline) {
                    return
                }
                a[0] = S;
                a[1] = T;
                Q === "horizontal" ? (S = W + O) : (T = X + O)
            })
        }

        H.box = J;
        H.vbox = D.curry(J, "vertical");
        H.hbox = D.curry(J, "horizontal");
        H.getAvailableSize = function(S, P, N) {
            var O = P.width;
            var V = P.height;
            var T = G(S.x, O);
            var U = G(S.y, V);
            var Q = G(S.x2, O);
            var R = G(S.y2, V);
            (isNaN(T) || isNaN(parseFloat(S.x))) && (T = 0);
            (isNaN(Q) || isNaN(parseFloat(S.x2))) && (Q = O);
            (isNaN(U) || isNaN(parseFloat(S.y))) && (U = 0);
            (isNaN(R) || isNaN(parseFloat(S.y2))) && (R = V);
            N = I.normalizeCssArray(N || 0);
            return {width: Math.max(Q - T - N[1] - N[3], 0), height: Math.max(R - U - N[0] - N[2], 0)}
        };
        H.getLayoutRect = function(W, Q, N) {
            N = I.normalizeCssArray(N || 0);
            var O = Q.width;
            var b = Q.height;
            var U = G(W.left, O);
            var T = G(W.top, b);
            var P = G(W.right, O);
            var Y = G(W.bottom, b);
            var X = G(W.width, O);
            var Z = G(W.height, b);
            var V = N[2] + N[0];
            var a = N[1] + N[3];
            var S = W.aspect;
            if (isNaN(X)) {
                X = O - P - a - U
            }
            if (isNaN(Z)) {
                Z = b - Y - V - T
            }
            if (isNaN(X) && isNaN(Z)) {
                if (S > O / b) {
                    X = O * 0.8
                } else {
                    Z = b * 0.8
                }
            }
            if (S != null) {
                if (isNaN(X)) {
                    X = S * Z
                }
                if (isNaN(Z)) {
                    Z = X / S
                }
            }
            if (isNaN(U)) {
                U = O - P - X - a
            }
            if (isNaN(T)) {
                T = b - Y - Z - V
            }
            switch (W.left || W.right) {
                case"center":
                    U = O / 2 - X / 2 - N[3];
                    break;
                case"right":
                    U = O - X - a;
                    break
            }
            switch (W.top || W.bottom) {
                case"middle":
                case"center":
                    T = b / 2 - Z / 2 - N[0];
                    break;
                case"bottom":
                    T = b - Z - V;
                    break
            }
            U = U || 0;
            T = T || 0;
            if (isNaN(X)) {
                X = O - U - (P || 0)
            }
            if (isNaN(Z)) {
                Z = b - T - (Y || 0)
            }
            var R = new K(U + N[3], T + N[0], X, Z);
            R.margin = N;
            return R
        };
        H.positionElement = function(Y, U, Q, N, W) {
            var S = !W || !W.hv || W.hv[0];
            var R = !W || !W.hv || W.hv[1];
            var Z = W && W.boundingMode || "all";
            if (!S && !R) {
                return
            }
            var X;
            if (Z === "raw") {
                X = Y.type === "group" ? new K(0, 0, +U.width || 0, +U.height || 0) : Y.getBoundingRect()
            } else {
                X = Y.getBoundingRect();
                if (Y.needLocalTransform()) {
                    var T = Y.getLocalTransform();
                    X = X.clone();
                    X.applyTransform(T)
                }
            }
            U = H.getLayoutRect(D.defaults({width: X.width, height: X.height}, U), Q, N);
            var P = Y.position;
            var O = S ? U.x - X.x : 0;
            var V = R ? U.y - X.y : 0;
            Y.attr("position", Z === "raw" ? [O, V] : [P[0] + O, P[1] + V])
        };
        H.sizeCalculable = function(N, O) {
            return N[B[O][0]] != null || (N[B[O][1]] != null && N[B[O][2]] != null)
        };
        H.mergeLayoutParam = function(R, N, P) {
            !D.isObject(P) && (P = {});
            var U = P.ignoreSize;
            !D.isArray(U) && (U = [U, U]);
            var O = T(B[0], 0);
            var S = T(B[1], 1);
            Q(B[0], R, O);
            Q(B[1], R, S);

            function T(Z, X) {
                var a = {};
                var c = 0;
                var f = {};
                var b = 0;
                var d = 2;
                A(Z, function(g) {
                    f[g] = R[g]
                });
                A(Z, function(g) {
                    V(N, g) && (a[g] = f[g] = N[g]);
                    W(a, g) && c++;
                    W(f, g) && b++
                });
                if (U[X]) {
                    if (W(N, Z[1])) {
                        f[Z[2]] = null
                    } else {
                        if (W(N, Z[2])) {
                            f[Z[1]] = null
                        }
                    }
                    return f
                }
                if (b === d || !c) {
                    return f
                } else {
                    if (c >= d) {
                        return a
                    } else {
                        for (var e = 0; e < Z.length; e++) {
                            var Y = Z[e];
                            if (!V(a, Y) && V(R, Y)) {
                                a[Y] = R[Y];
                                break
                            }
                        }
                        return a
                    }
                }
            }

            function V(X, Y) {
                return X.hasOwnProperty(Y)
            }

            function W(X, Y) {
                return X[Y] != null && X[Y] !== "auto"
            }

            function Q(Z, Y, X) {
                A(Z, function(a) {
                    Y[a] = X[a]
                })
            }
        };
        H.getLayoutParams = function(N) {
            return H.copyLayoutParams({}, N)
        };
        H.copyLayoutParams = function(O, N) {
            N && O && A(C, function(P) {
                N.hasOwnProperty(P) && (O[P] = N[P])
            });
            return O
        };
        L.exports = H
    }, function(A, B) {
        A.exports = {
            getBoxLayoutParams: function() {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get("bottom"),
                    width: this.get("width"),
                    height: this.get("height")
                }
            }
        }
    }, function(A, C) {
        var B = "";
        if (typeof navigator !== "undefined") {
            B = navigator.platform || ""
        }
        A.exports = {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            textStyle: {fontFamily: B.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal"},
            blendMode: null,
            animation: "auto",
            animationDuration: 1000,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut",
            animationThreshold: 2000,
            progressiveThreshold: 3000,
            progressive: 400,
            hoverLayerThreshold: 3000,
            useUTC: false
        }
    }, function(D, F, B) {
        var C = B(13);
        var E = C.set;
        var A = C.get;
        D.exports = {
            clearColorPalette: function() {
                E(this, "colorIdx", 0);
                E(this, "colorNameMap", {})
            }, getColorFromPalette: function(J, K) {
                K = K || this;
                var G = A(K, "colorIdx") || 0;
                var H = A(K, "colorNameMap") || E(K, "colorNameMap", {});
                if (H.hasOwnProperty(J)) {
                    return H[J]
                }
                var I = this.get("color", true) || [];
                if (!I.length) {
                    return
                }
                var L = I[G];
                if (J) {
                    H[J] = L
                }
                E(K, "colorIdx", (G + 1) % I.length);
                return L
            }
        }
    }, function(C, F, B) {
        var A = B(4);
        var D = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];

        function E(G) {
            A.each(D, function(H) {
                this[H] = A.bind(G[H], G)
            }, this)
        }

        C.exports = E
    }, function(D, E, C) {
        var A = C(4);
        var F = {};

        function B() {
            this._coordinateSystems = []
        }

        B.prototype = {
            constructor: B, create: function(G, I) {
                var H = [];
                A.each(F, function(L, J) {
                    var K = L.create(G, I);
                    H = H.concat(K || [])
                });
                this._coordinateSystems = H
            }, update: function(G, H) {
                A.each(this._coordinateSystems, function(I) {
                    I.update && I.update(G, H)
                })
            }, getCoordinateSystems: function() {
                return this._coordinateSystems.slice()
            }
        };
        B.register = function(G, H) {
            F[G] = H
        };
        B.get = function(G) {
            return F[G]
        };
        D.exports = B
    }, function(M, F, O) {
        var E = O(4);
        var C = O(5);
        var B = O(69);
        var G = E.each;
        var D = E.clone;
        var L = E.map;
        var K = E.merge;
        var Q = /^(min|max)?(.+)$/;

        function P(R) {
            this._api = R;
            this._timelineOptions = [];
            this._mediaList = [];
            this._mediaDefault;
            this._currentMediaIndices = [];
            this._optionBackup;
            this._newBaseOption
        }

        P.prototype = {
            constructor: P, setOption: function(S, R) {
                S = D(S, true);
                var T = this._optionBackup;
                var U = A.call(this, S, R, !T);
                this._newBaseOption = U.baseOption;
                if (T) {
                    J(T.baseOption, U.baseOption);
                    if (U.timelineOptions.length) {
                        T.timelineOptions = U.timelineOptions
                    }
                    if (U.mediaList.length) {
                        T.mediaList = U.mediaList
                    }
                    if (U.mediaDefault) {
                        T.mediaDefault = U.mediaDefault
                    }
                } else {
                    this._optionBackup = U
                }
            }, mountOption: function(S) {
                var R = this._optionBackup;
                this._timelineOptions = L(R.timelineOptions, D);
                this._mediaList = L(R.mediaList, D);
                this._mediaDefault = D(R.mediaDefault);
                this._currentMediaIndices = [];
                return D(S ? R.baseOption : this._newBaseOption)
            }, getTimelineOption: function(S) {
                var R;
                var T = this._timelineOptions;
                if (T.length) {
                    var U = S.getComponent("timeline");
                    if (U) {
                        R = D(T[U.getCurrentIndex()], true)
                    }
                }
                return R
            }, getMediaOption: function(X) {
                var T = this._api.getWidth();
                var Y = this._api.getHeight();
                var Z = this._mediaList;
                var V = this._mediaDefault;
                var U = [];
                var S = [];
                if (!Z.length && !V) {
                    return S
                }
                for (var W = 0, R = Z.length; W < R; W++) {
                    if (H(Z[W].query, T, Y)) {
                        U.push(W)
                    }
                }
                if (!U.length && V) {
                    U = [-1]
                }
                if (U.length && !N(U, this._currentMediaIndices)) {
                    S = L(U, function(a) {
                        return D(a === -1 ? V.option : Z[a].option)
                    })
                }
                this._currentMediaIndices = U;
                return S
            }
        };

        function A(W, V, R) {
            var X = [];
            var Z = [];
            var Y;
            var T;
            var U = W.timeline;
            if (W.baseOption) {
                T = W.baseOption
            }
            if (U || W.options) {
                T = T || {};
                X = (W.options || []).slice()
            }
            if (W.media) {
                T = T || {};
                var S = W.media;
                G(S, function(a) {
                    if (a && a.option) {
                        if (a.query) {
                            Z.push(a)
                        } else {
                            if (!Y) {
                                Y = a
                            }
                        }
                    }
                })
            }
            if (!T) {
                T = W
            }
            if (!T.timeline) {
                T.timeline = U
            }
            G([T].concat(X).concat(E.map(Z, function(a) {
                return a.option
            })), function(a) {
                G(V, function(b) {
                    b(a, R)
                })
            });
            return {baseOption: T, timelineOptions: X, mediaDefault: Y, mediaList: Z}
        }

        function H(S, U, T) {
            var V = {width: U, height: T, aspectratio: U / T};
            var R = true;
            E.each(S, function(Z, a) {
                var X = a.match(Q);
                if (!X || !X[1] || !X[2]) {
                    return
                }
                var W = X[1];
                var Y = X[2].toLowerCase();
                if (!I(V[Y], Z, W)) {
                    R = false
                }
            });
            return R
        }

        function I(R, S, T) {
            if (T === "min") {
                return R >= S
            } else {
                if (T === "max") {
                    return R <= S
                } else {
                    return R === S
                }
            }
        }

        function N(R, S) {
            return R.join(",") === S.join(",")
        }

        function J(R, S) {
            S = S || {};
            G(S, function(W, V) {
                if (W == null) {
                    return
                }
                var U = R[V];
                if (!B.hasClass(V)) {
                    R[V] = K(U, W, true)
                } else {
                    W = C.normalizeToArray(W);
                    U = C.normalizeToArray(U);
                    var T = C.mappingToExists(U, W);
                    R[V] = L(T, function(X) {
                        return (X.option && X.exist) ? K(X.exist, X.option, true) : (X.exist || X.option)
                    })
                }
            })
        }

        M.exports = P
    }, function(N, P, E) {
        var C = E(4);
        var D = E(6);
        var A = E(13);
        var B = E(5);
        var O = E(69);
        var I = E(74);
        var G = E(2);
        var H = E(71);
        var F = A.set;
        var M = A.get;
        var K = D.encodeHTML;
        var L = D.addCommas;
        var J = O.extend({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            visualColorAccessPath: "itemStyle.normal.color",
            layoutMode: null,
            init: function(Q, T, R, S) {
                this.seriesIndex = this.componentIndex;
                this.mergeDefaultAndTheme(Q, R);
                var U = this.getInitialData(Q, R);
                if (true) {
                    C.assert(U, "getInitialData returned invalid data.")
                }
                F(this, "dataBeforeProcessed", U);
                this.restoreData()
            },
            mergeDefaultAndTheme: function(R, S) {
                var T = this.layoutMode;
                var Q = T ? H.getLayoutParams(R) : {};
                C.merge(R, S.getTheme().get(this.subType));
                C.merge(R, this.getDefaultOption());
                B.defaultEmphasis(R.label, B.LABEL_OPTIONS);
                this.fillDataTextStyle(R.data);
                if (T) {
                    H.mergeLayoutParam(R, Q, T)
                }
            },
            mergeOption: function(S, Q) {
                S = C.merge(this.option, S, true);
                this.fillDataTextStyle(S.data);
                var T = this.layoutMode;
                if (T) {
                    H.mergeLayoutParam(this.option, S, T)
                }
                var R = this.getInitialData(S, Q);
                if (R) {
                    F(this, "data", R);
                    F(this, "dataBeforeProcessed", R.cloneShallow())
                }
            },
            fillDataTextStyle: function(R) {
                if (R) {
                    for (var Q = 0; Q < R.length; Q++) {
                        if (R[Q] && R[Q].label) {
                            B.defaultEmphasis(R[Q].label, B.LABEL_OPTIONS)
                        }
                    }
                }
            },
            getInitialData: function() {
            },
            getData: function(Q) {
                var R = M(this, "data");
                return Q == null ? R : R.getLinkedData(Q)
            },
            setData: function(Q) {
                F(this, "data", Q)
            },
            getRawData: function() {
                return M(this, "dataBeforeProcessed")
            },
            coordDimToDataDim: function(Q) {
                return B.coordDimToDataDim(this.getData(), Q)
            },
            dataDimToCoordDim: function(Q) {
                return B.dataDimToCoordDim(this.getData(), Q)
            },
            getBaseAxis: function() {
                var Q = this.coordinateSystem;
                return Q && Q.getBaseAxis && Q.getBaseAxis()
            },
            formatTooltip: function(Y, Z, S) {
                function T(d) {
                    var f = C.reduce(d, function(j, i, h) {
                        var g = U.getDimensionInfo(h);
                        return j |= g && g.tooltip !== false && g.tooltipName != null
                    }, 0);
                    var b = [];
                    var e = B.otherDimToDataDim(U, "tooltip");
                    e.length ? C.each(e, function(g) {
                        c(U.get(g, Y), g)
                    }) : C.each(d, c);

                    function c(j, i) {
                        var h = U.getDimensionInfo(i);
                        if (!h || h.otherDims.tooltip === false) {
                            return
                        }
                        var k = h.type;
                        var g = (f ? "- " + (h.tooltipName || h.name) + ": " : "") + (k === "ordinal" ? j + "" : k === "time" ? (Z ? "" : D.formatTime("yyyy/MM/dd hh:mm:ss", j)) : L(j));
                        g && b.push(K(g))
                    }

                    return (f ? "<br/>" : "") + b.join(f ? "<br/>" : ", ")
                }

                var U = M(this, "data");
                var W = this.getRawValue(Y);
                var Q = C.isArray(W) ? T(W) : K(L(W));
                var R = U.getName(Y);
                var V = U.getItemVisual(Y, "color");
                if (C.isObject(V) && V.colorStops) {
                    V = (V.colorStops[0] || {}).color
                }
                V = V || "transparent";
                var X = D.getTooltipMarker(V);
                var a = this.name;
                if (a === "\0-") {
                    a = ""
                }
                a = a ? K(a) + (!Z ? "<br/>" : ": ") : "";
                return !Z ? a + X + (R ? K(R) + ": " + Q : Q) : X + a + Q
            },
            isAnimationEnabled: function() {
                if (G.node) {
                    return false
                }
                var Q = this.getShallow("animation");
                if (Q) {
                    if (this.getData().count() > this.getShallow("animationThreshold")) {
                        Q = false
                    }
                }
                return Q
            },
            restoreData: function() {
                F(this, "data", M(this, "dataBeforeProcessed").cloneShallow())
            },
            getColorFromPalette: function(R, S) {
                var Q = this.ecModel;
                var T = I.getColorFromPalette.call(this, R, S);
                if (!T) {
                    T = Q.getColorFromPalette(R, S)
                }
                return T
            },
            getAxisTooltipData: null,
            getTooltipPosition: null
        });
        C.mixin(J, B.dataFormatMixin);
        C.mixin(J, I);
        N.exports = J
    }, function(F, H, B) {
        var D = B(48);
        var C = B(70);
        var E = B(13);
        var G = function() {
            this.group = new D();
            this.uid = C.getUID("viewComponent")
        };
        G.prototype = {
            constructor: G, init: function(I, J) {
            }, render: function(K, J, L, I) {
            }, dispose: function() {
            }
        };
        var A = G.prototype;
        A.updateView = A.updateLayout = A.updateVisual = function(I, J, L, K) {
        };
        E.enableClassExtend(G);
        E.enableClassManagement(G, {registerWhenExtend: true});
        F.exports = G
    }, function(K, L, E) {
        var G = E(48);
        var F = E(70);
        var I = E(13);
        var B = E(5);
        var D = E(4);

        function C() {
            this.group = new G();
            this.uid = F.getUID("viewChart")
        }

        C.prototype = {
            type: "chart", init: function(M, N) {
            }, render: function(M, N, P, O) {
            }, highlight: function(M, N, P, O) {
                J(M.getData(), O, "emphasis")
            }, downplay: function(M, N, P, O) {
                J(M.getData(), O, "normal")
            }, remove: function(M, N) {
                this.group.removeAll()
            }, dispose: function() {
            }
        };
        var H = C.prototype;
        H.updateView = H.updateLayout = H.updateVisual = function(M, N, P, O) {
            this.render(M, N, P, O)
        };

        function A(M, O) {
            if (M) {
                M.trigger(O);
                if (M.type === "group") {
                    for (var N = 0; N < M.childCount(); N++) {
                        A(M.childAt(N), O)
                    }
                }
            }
        }

        function J(P, N, O) {
            var M = B.queryDataIndex(P, N);
            if (M != null) {
                D.each(B.normalizeToArray(M), function(Q) {
                    A(P.getItemGraphicEl(Q), O)
                })
            } else {
                P.eachItemGraphicEl(function(Q) {
                    A(Q, O)
                })
            }
        }

        I.enableClassExtend(C, ["dispose"]);
        I.enableClassManagement(C, {registerWhenExtend: true});
        K.exports = C
    }, function(D, E) {
        var C = {};
        var F = "\0__throttleOriginMethod";
        var A = "\0__throttleRate";
        var B = "\0__throttleType";
        C.throttle = function(N, J, O) {
            var S;
            var I = 0;
            var G = 0;
            var Q = null;
            var K;
            var M;
            var H;
            var L;
            J = J || 0;

            function R() {
                G = (new Date()).getTime();
                Q = null;
                N.apply(M, H || [])
            }

            var P = function() {
                S = (new Date()).getTime();
                M = this;
                H = arguments;
                var T = L || J;
                var U = L || O;
                L = null;
                K = S - (U ? I : G) - T;
                clearTimeout(Q);
                if (U) {
                    Q = setTimeout(R, T)
                } else {
                    if (K >= 0) {
                        R()
                    } else {
                        Q = setTimeout(R, -K)
                    }
                }
                I = S
            };
            P.clear = function() {
                if (Q) {
                    clearTimeout(Q);
                    Q = null
                }
            };
            P.debounceNextCall = function(T) {
                L = T
            };
            return P
        };
        C.createOrUpdate = function(L, I, J, G) {
            var K = L[I];
            if (!K) {
                return
            }
            var M = K[F] || K;
            var N = K[B];
            var H = K[A];
            if (H !== J || N !== G) {
                if (J == null || !G) {
                    return (L[I] = M)
                }
                K = L[I] = C.throttle(M, J, G === "debounce");
                K[F] = M;
                K[B] = G;
                K[A] = J
            }
            return K
        };
        C.clear = function(G, I) {
            var H = G[I];
            if (H && H[F]) {
                G[I] = H[F]
            }
        };
        D.exports = C
    }, function(O, P, G) {
        /*
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
        var K = G(24);
        var J = G(2);
        var F = G(4);
        var B = G(83);
        var C = G(85);
        var E = G(87);
        var H = G(90);
        var N = !J.canvasSupported;
        var M = {canvas: G(92)};
        var I = {};
        var D = {};
        D.version = "3.5.2";
        D.init = function(Q, S) {
            var R = new L(K(), Q, S);
            I[R.id] = R;
            return R
        };
        D.dispose = function(R) {
            if (R) {
                R.dispose()
            } else {
                for (var Q in I) {
                    if (I.hasOwnProperty(Q)) {
                        I[Q].dispose()
                    }
                }
                I = {}
            }
            return D
        };
        D.getInstance = function(Q) {
            return I[Q]
        };
        D.registerPainter = function(Q, R) {
            M[Q] = R
        };

        function A(Q) {
            delete I[Q]
        }

        var L = function(W, R, U) {
            U = U || {};
            this.dom = R;
            this.id = W;
            var X = this;
            var Q = new C();
            var Y = U.renderer;
            if (N) {
                if (!M.vml) {
                    throw new Error("You need to require 'zrender/vml/vml' to support IE8")
                }
                Y = "vml"
            } else {
                if (!Y || !M[Y]) {
                    Y = "canvas"
                }
            }
            var Z = new M[Y](R, Q, U);
            this.storage = Q;
            this.painter = Z;
            var V = !J.node ? new H(Z.getViewportRoot()) : null;
            this.handler = new B(Q, Z, V, Z.root);
            this.animation = new E({stage: {update: F.bind(this.flush, this)}});
            this.animation.start();
            this._needsRefresh;
            var S = Q.delFromStorage;
            var T = Q.addToStorage;
            Q.delFromStorage = function(a) {
                S.call(Q, a);
                a && a.removeSelfFromZr(X)
            };
            Q.addToStorage = function(a) {
                T.call(Q, a);
                a.addSelfToZr(X)
            }
        };
        L.prototype = {
            constructor: L, getId: function() {
                return this.id
            }, add: function(Q) {
                this.storage.addRoot(Q);
                this._needsRefresh = true
            }, remove: function(Q) {
                this.storage.delRoot(Q);
                this._needsRefresh = true
            }, configLayer: function(R, Q) {
                this.painter.configLayer(R, Q);
                this._needsRefresh = true
            }, refreshImmediately: function() {
                this._needsRefresh = false;
                this.painter.refresh();
                this._needsRefresh = false
            }, refresh: function() {
                this._needsRefresh = true
            }, flush: function() {
                if (this._needsRefresh) {
                    this.refreshImmediately()
                }
                if (this._needsRefreshHover) {
                    this.refreshHoverImmediately()
                }
            }, addHover: function(Q, R) {
                if (this.painter.addHover) {
                    this.painter.addHover(Q, R);
                    this.refreshHover()
                }
            }, removeHover: function(Q) {
                if (this.painter.removeHover) {
                    this.painter.removeHover(Q);
                    this.refreshHover()
                }
            }, clearHover: function() {
                if (this.painter.clearHover) {
                    this.painter.clearHover();
                    this.refreshHover()
                }
            }, refreshHover: function() {
                this._needsRefreshHover = true
            }, refreshHoverImmediately: function() {
                this._needsRefreshHover = false;
                this.painter.refreshHover && this.painter.refreshHover()
            }, resize: function(Q) {
                Q = Q || {};
                this.painter.resize(Q.width, Q.height);
                this.handler.resize()
            }, clearAnimation: function() {
                this.animation.clear()
            }, getWidth: function() {
                return this.painter.getWidth()
            }, getHeight: function() {
                return this.painter.getHeight()
            }, pathToImage: function(Q, R) {
                return this.painter.pathToImage(Q, R)
            }, setCursorStyle: function(Q) {
                this.handler.setCursorStyle(Q)
            }, findHover: function(Q, R) {
                return this.handler.findHover(Q, R)
            }, on: function(R, S, Q) {
                this.handler.on(R, S, Q)
            }, off: function(Q, R) {
                this.handler.off(Q, R)
            }, trigger: function(Q, R) {
                this.handler.trigger(Q, R)
            }, clear: function() {
                this.storage.delRoot();
                this.painter.clear()
            }, dispose: function() {
                this.animation.stop();
                this.clear();
                this.storage.dispose();
                this.painter.dispose();
                this.handler.dispose();
                this.animation = this.storage = this.painter = this.handler = null;
                A(this.id)
            }
        };
        O.exports = D
    }, function(K, L, D) {
        var J = D(4);
        var C = D(84);
        var F = D(25);
        var G = "silent";

        function B(M, N, O) {
            return {
                type: M,
                event: O,
                target: N.target,
                topTarget: N.topTarget,
                cancelBubble: false,
                offsetX: O.zrX,
                offsetY: O.zrY,
                gestureEvent: O.gestureEvent,
                pinchX: O.pinchX,
                pinchY: O.pinchY,
                pinchScale: O.pinchScale,
                wheelDelta: O.zrDelta,
                zrByTouch: O.zrByTouch
            }
        }

        function I() {
        }

        I.prototype.dispose = function() {
        };
        var E = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
        var A = function(M, N, O, P) {
            F.call(this);
            this.storage = M;
            this.painter = N;
            this.painterRoot = P;
            O = O || new I();
            this.proxy = O;
            O.handler = this;
            this._hovered = {};
            this._lastTouchMoment;
            this._lastX;
            this._lastY;
            C.call(this);
            J.each(E, function(Q) {
                O.on && O.on(Q, this[Q], this)
            }, this)
        };
        A.prototype = {
            constructor: A, mousemove: function(N) {
                var Q = N.zrX;
                var R = N.zrY;
                var S = this._hovered;
                var T = this._hovered = this.findHover(Q, R);
                var O = T.target;
                var P = S.target;
                var M = this.proxy;
                M.setCursor && M.setCursor(O ? O.cursor : "default");
                if (P && O !== P && P.__zr) {
                    this.dispatchToElement(S, "mouseout", N)
                }
                this.dispatchToElement(T, "mousemove", N);
                if (O && O !== P) {
                    this.dispatchToElement(T, "mouseover", N)
                }
            }, mouseout: function(N) {
                this.dispatchToElement(this._hovered, "mouseout", N);
                var O = N.toElement || N.relatedTarget;
                var M;
                do {
                    O = O && O.parentNode
                } while (O && O.nodeType != 9 && !(M = O === this.painterRoot));
                !M && this.trigger("globalout", {event: N})
            }, resize: function(M) {
                this._hovered = {}
            }, dispatch: function(N, O) {
                var M = this[N];
                M && M.call(this, O)
            }, dispose: function() {
                this.proxy.dispose();
                this.storage = this.proxy = this.painter = null
            }, setCursorStyle: function(N) {
                var M = this.proxy;
                M.setCursor && M.setCursor(N)
            }, dispatchToElement: function(P, O, R) {
                P = P || {};
                var Q = "on" + O;
                var M = B(O, P, R);
                var N = P.target;
                while (N) {
                    N[Q] && (M.cancelBubble = N[Q].call(N, M));
                    N.trigger(O, M);
                    N = N.parent;
                    if (M.cancelBubble) {
                        break
                    }
                }
                if (!M.cancelBubble) {
                    this.trigger(O, M);
                    this.painter && this.painter.eachOtherLayer(function(S) {
                        if (typeof(S[Q]) == "function") {
                            S[Q].call(S, M)
                        }
                        if (S.trigger) {
                            S.trigger(O, M)
                        }
                    })
                }
            }, findHover: function(R, S, P) {
                var O = this.storage.getDisplayList();
                var Q = {};
                for (var M = O.length - 1; M >= 0; M--) {
                    var N;
                    if (O[M] !== P && !O[M].ignore && (N = H(O[M], R, S))) {
                        !Q.topTarget && (Q.topTarget = O[M]);
                        if (N !== G) {
                            Q.target = O[M];
                            break
                        }
                    }
                }
                return Q
            }
        };
        J.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(M) {
            A.prototype[M] = function(O) {
                var N = this.findHover(O.zrX, O.zrY);
                var P = N.target;
                if (M === "mousedown") {
                    this._downel = P;
                    this._upel = P
                } else {
                    if (M === "mosueup") {
                        this._upel = P
                    } else {
                        if (M === "click") {
                            if (this._downel !== this._upel) {
                                return
                            }
                        }
                    }
                }
                this.dispatchToElement(N, M, O)
            }
        });

        function H(N, O, P) {
            if (N[N.rectHover ? "rectContain" : "contain"](O, P)) {
                var M = N;
                var Q;
                while (M) {
                    if (M.clipPath && !M.clipPath.contain(O, P)) {
                        return false
                    }
                    if (M.silent) {
                        Q = true
                    }
                    M = M.parent
                }
                return Q ? G : true
            }
            return false
        }

        J.mixin(A, F);
        J.mixin(A, C);
        K.exports = A
    }, function(C, D) {
        function B() {
            this.on("mousedown", this._dragStart, this);
            this.on("mousemove", this._drag, this);
            this.on("mouseup", this._dragEnd, this);
            this.on("globalout", this._dragEnd, this)
        }

        B.prototype = {
            constructor: B, _dragStart: function(E) {
                var F = E.target;
                if (F && F.draggable) {
                    this._draggingTarget = F;
                    F.dragging = true;
                    this._x = E.offsetX;
                    this._y = E.offsetY;
                    this.dispatchToElement(A(F, E), "dragstart", E.event)
                }
            }, _drag: function(E) {
                var F = this._draggingTarget;
                if (F) {
                    var J = E.offsetX;
                    var K = E.offsetY;
                    var I = J - this._x;
                    var H = K - this._y;
                    this._x = J;
                    this._y = K;
                    F.drift(I, H, E);
                    this.dispatchToElement(A(F, E), "drag", E.event);
                    var L = this.findHover(J, K, F).target;
                    var G = this._dropTarget;
                    this._dropTarget = L;
                    if (F !== L) {
                        if (G && L !== G) {
                            this.dispatchToElement(A(G, E), "dragleave", E.event)
                        }
                        if (L && L !== G) {
                            this.dispatchToElement(A(L, E), "dragenter", E.event)
                        }
                    }
                }
            }, _dragEnd: function(E) {
                var F = this._draggingTarget;
                if (F) {
                    F.dragging = false
                }
                this.dispatchToElement(A(F, E), "dragend", E.event);
                if (this._dropTarget) {
                    this.dispatchToElement(A(this._dropTarget, E), "drop", E.event)
                }
                this._draggingTarget = null;
                this._dropTarget = null
            }
        };

        function A(F, E) {
            return {target: F, topTarget: E && E.topTarget}
        }

        C.exports = B
    }, function(H, I, C) {
        var G = C(4);
        var E = C(2);
        var F = C(48);
        var A = C(86);

        function D(K, J) {
            if (K.zlevel === J.zlevel) {
                if (K.z === J.z) {
                    return K.z2 - J.z2
                }
                return K.z - J.z
            }
            return K.zlevel - J.zlevel
        }

        var B = function() {
            this._roots = [];
            this._displayList = [];
            this._displayListLen = 0
        };
        B.prototype = {
            constructor: B, traverse: function(J, K) {
                for (var L = 0; L < this._roots.length; L++) {
                    this._roots[L].traverse(J, K)
                }
            }, getDisplayList: function(J, K) {
                K = K || false;
                if (J) {
                    this.updateDisplayList(K)
                }
                return this._displayList
            }, updateDisplayList: function(M) {
                this._displayListLen = 0;
                var K = this._roots;
                var N = this._displayList;
                for (var J = 0, L = K.length; J < L; J++) {
                    this._updateAndAddDisplayable(K[J], null, M)
                }
                N.length = this._displayListLen;
                E.canvasSupported && A(N, D)
            }, _updateAndAddDisplayable: function(M, O, R) {
                if (M.ignore && !R) {
                    return
                }
                M.beforeUpdate();
                if (M.__dirty) {
                    M.update()
                }
                M.afterUpdate();
                var K = M.clipPath;
                if (K) {
                    if (O) {
                        O = O.slice()
                    } else {
                        O = []
                    }
                    var J = K;
                    var Q = M;
                    while (J) {
                        J.parent = Q;
                        J.updateTransform();
                        O.push(J);
                        Q = J;
                        J = J.clipPath
                    }
                }
                if (M.isGroup) {
                    var L = M._children;
                    for (var N = 0; N < L.length; N++) {
                        var P = L[N];
                        if (M.__dirty) {
                            P.__dirty = true
                        }
                        this._updateAndAddDisplayable(P, O, R)
                    }
                    M.__dirty = false
                } else {
                    M.__clipPaths = O;
                    this._displayList[this._displayListLen++] = M
                }
            }, addRoot: function(J) {
                if (J.__storage === this) {
                    return
                }
                if (J instanceof F) {
                    J.addChildrenToStorage(this)
                }
                this.addToStorage(J);
                this._roots.push(J)
            }, delRoot: function(J) {
                if (J == null) {
                    for (var K = 0; K < this._roots.length; K++) {
                        var L = this._roots[K];
                        if (L instanceof F) {
                            L.delChildrenFromStorage(this)
                        }
                    }
                    this._roots = [];
                    this._displayList = [];
                    this._displayListLen = 0;
                    return
                }
                if (J instanceof Array) {
                    for (var K = 0, M = J.length; K < M; K++) {
                        this.delRoot(J[K])
                    }
                    return
                }
                var N = G.indexOf(this._roots, J);
                if (N >= 0) {
                    this.delFromStorage(J);
                    this._roots.splice(N, 1);
                    if (J instanceof F) {
                        J.delChildrenFromStorage(this)
                    }
                }
            }, addToStorage: function(J) {
                J.__storage = this;
                J.dirty(false);
                return this
            }, delFromStorage: function(J) {
                if (J) {
                    J.__storage = null
                }
                return this
            }, dispose: function() {
                this._renderList = this._roots = null
            }, displayableSortFunc: D
        };
        H.exports = B
    }, function(K, M) {
        var D = 32;
        var A = 7;
        var G = 256;

        function B(O) {
            var N = 0;
            while (O >= D) {
                N |= O & 1;
                O >>= 1
            }
            return O + N
        }

        function L(O, N, P, Q) {
            var R = N + 1;
            if (R === P) {
                return 1
            }
            if (Q(O[R++], O[N]) < 0) {
                while (R < P && Q(O[R], O[R - 1]) < 0) {
                    R++
                }
                H(O, N, R)
            } else {
                while (R < P && Q(O[R], O[R - 1]) >= 0) {
                    R++
                }
            }
            return R - N
        }

        function H(O, N, P) {
            P--;
            while (N < P) {
                var Q = O[N];
                O[N++] = O[P];
                O[P--] = Q
            }
        }

        function I(N, P, Q, O, S) {
            if (O === P) {
                O++
            }
            for (; O < Q; O++) {
                var T = N[O];
                var R = P;
                var V = O;
                var W;
                while (R < V) {
                    W = R + V >>> 1;
                    if (S(T, N[W]) < 0) {
                        V = W
                    } else {
                        R = W + 1
                    }
                }
                var U = O - R;
                switch (U) {
                    case 3:
                        N[R + 3] = N[R + 2];
                    case 2:
                        N[R + 2] = N[R + 1];
                    case 1:
                        N[R + 1] = N[R];
                        break;
                    default:
                        while (U > 0) {
                            N[R + U] = N[R + U - 1];
                            U--
                        }
                }
                N[R] = T
            }
        }

        function J(T, O, P, S, V, N) {
            var W = 0;
            var U = 0;
            var Q = 1;
            if (N(T, O[P + V]) > 0) {
                U = S - V;
                while (Q < U && N(T, O[P + V + Q]) > 0) {
                    W = Q;
                    Q = (Q << 1) + 1;
                    if (Q <= 0) {
                        Q = U
                    }
                }
                if (Q > U) {
                    Q = U
                }
                W += V;
                Q += V
            } else {
                U = V + 1;
                while (Q < U && N(T, O[P + V - Q]) <= 0) {
                    W = Q;
                    Q = (Q << 1) + 1;
                    if (Q <= 0) {
                        Q = U
                    }
                }
                if (Q > U) {
                    Q = U
                }
                var R = W;
                W = V - Q;
                Q = V - R
            }
            W++;
            while (W < Q) {
                var X = W + (Q - W >>> 1);
                if (N(T, O[P + X]) > 0) {
                    W = X + 1
                } else {
                    Q = X
                }
            }
            return Q
        }

        function C(T, O, P, S, V, N) {
            var W = 0;
            var U = 0;
            var Q = 1;
            if (N(T, O[P + V]) < 0) {
                U = V + 1;
                while (Q < U && N(T, O[P + V - Q]) < 0) {
                    W = Q;
                    Q = (Q << 1) + 1;
                    if (Q <= 0) {
                        Q = U
                    }
                }
                if (Q > U) {
                    Q = U
                }
                var R = W;
                W = V - Q;
                Q = V - R
            } else {
                U = S - V;
                while (Q < U && N(T, O[P + V + Q]) >= 0) {
                    W = Q;
                    Q = (Q << 1) + 1;
                    if (Q <= 0) {
                        Q = U
                    }
                }
                if (Q > U) {
                    Q = U
                }
                W += V;
                Q += V
            }
            W++;
            while (W < Q) {
                var X = W + (Q - W >>> 1);
                if (N(T, O[P + X]) < 0) {
                    Q = X
                } else {
                    W = X + 1
                }
            }
            return Q
        }

        function E(O, U) {
            var W = A;
            var T = 0;
            var P = G;
            var S = 0;
            var N;
            var X;
            var Z = 0;
            T = O.length;
            if (T < 2 * G) {
                P = T >>> 1
            }
            var R = [];
            S = T < 120 ? 5 : T < 1542 ? 10 : T < 119151 ? 19 : 40;
            N = [];
            X = [];

            function Y(d, e) {
                N[Z] = d;
                X[Z] = e;
                Z += 1
            }

            function b() {
                while (Z > 1) {
                    var d = Z - 2;
                    if (d >= 1 && X[d - 1] <= X[d] + X[d + 1] || d >= 2 && X[d - 2] <= X[d] + X[d - 1]) {
                        if (X[d - 1] < X[d + 1]) {
                            d--
                        }
                    } else {
                        if (X[d] > X[d + 1]) {
                            break
                        }
                    }
                    a(d)
                }
            }

            function c() {
                while (Z > 1) {
                    var d = Z - 2;
                    if (d > 0 && X[d - 1] < X[d + 1]) {
                        d--
                    }
                    a(d)
                }
            }

            function a(e) {
                var j = N[e];
                var f = X[e];
                var h = N[e + 1];
                var g = X[e + 1];
                X[e] = f + g;
                if (e === Z - 3) {
                    N[e + 1] = N[e + 2];
                    X[e + 1] = X[e + 2]
                }
                Z--;
                var d = C(O[h], O, j, f, 0, U);
                j += d;
                f -= d;
                if (f === 0) {
                    return
                }
                g = J(O[j + f - 1], O, h, g, g - 1, U);
                if (g === 0) {
                    return
                }
                if (f <= g) {
                    Q(j, f, h, g)
                } else {
                    V(j, f, h, g)
                }
            }

            function Q(p, f, n, g) {
                var j = 0;
                for (j = 0; j < f; j++) {
                    R[j] = O[p + j]
                }
                var k = 0;
                var l = n;
                var h = p;
                O[h++] = O[l++];
                if (--g === 0) {
                    for (j = 0; j < f; j++) {
                        O[h + j] = R[k + j]
                    }
                    return
                }
                if (f === 1) {
                    for (j = 0; j < g; j++) {
                        O[h + j] = O[l + j]
                    }
                    O[h + g] = R[k];
                    return
                }
                var m = W;
                var d, o, e;
                while (1) {
                    d = 0;
                    o = 0;
                    e = false;
                    do {
                        if (U(O[l], R[k]) < 0) {
                            O[h++] = O[l++];
                            o++;
                            d = 0;
                            if (--g === 0) {
                                e = true;
                                break
                            }
                        } else {
                            O[h++] = R[k++];
                            d++;
                            o = 0;
                            if (--f === 1) {
                                e = true;
                                break
                            }
                        }
                    } while ((d | o) < m);
                    if (e) {
                        break
                    }
                    do {
                        d = C(O[l], R, k, f, 0, U);
                        if (d !== 0) {
                            for (j = 0; j < d; j++) {
                                O[h + j] = R[k + j]
                            }
                            h += d;
                            k += d;
                            f -= d;
                            if (f <= 1) {
                                e = true;
                                break
                            }
                        }
                        O[h++] = O[l++];
                        if (--g === 0) {
                            e = true;
                            break
                        }
                        o = J(R[k], O, l, g, 0, U);
                        if (o !== 0) {
                            for (j = 0; j < o; j++) {
                                O[h + j] = O[l + j]
                            }
                            h += o;
                            l += o;
                            g -= o;
                            if (g === 0) {
                                e = true;
                                break
                            }
                        }
                        O[h++] = R[k++];
                        if (--f === 1) {
                            e = true;
                            break
                        }
                        m--
                    } while (d >= A || o >= A);
                    if (e) {
                        break
                    }
                    if (m < 0) {
                        m = 0
                    }
                    m += 2
                }
                W = m;
                W < 1 && (W = 1);
                if (f === 1) {
                    for (j = 0; j < g; j++) {
                        O[h + j] = O[l + j]
                    }
                    O[h + g] = R[k]
                } else {
                    if (f === 0) {
                        throw new Error()
                    } else {
                        for (j = 0; j < f; j++) {
                            O[h + j] = R[k + j]
                        }
                    }
                }
            }

            function V(r, h, p, j) {
                var l = 0;
                for (l = 0; l < j; l++) {
                    R[l] = O[p + l]
                }
                var m = r + h - 1;
                var n = j - 1;
                var k = p + j - 1;
                var d = 0;
                var g = 0;
                O[k--] = O[m--];
                if (--h === 0) {
                    d = k - (j - 1);
                    for (l = 0; l < j; l++) {
                        O[d + l] = R[l]
                    }
                    return
                }
                if (j === 1) {
                    k -= h;
                    m -= h;
                    g = k + 1;
                    d = m + 1;
                    for (l = h - 1; l >= 0; l--) {
                        O[g + l] = O[d + l]
                    }
                    O[k] = R[n];
                    return
                }
                var o = W;
                while (true) {
                    var f = 0;
                    var q = 0;
                    var e = false;
                    do {
                        if (U(R[n], O[m]) < 0) {
                            O[k--] = O[m--];
                            f++;
                            q = 0;
                            if (--h === 0) {
                                e = true;
                                break
                            }
                        } else {
                            O[k--] = R[n--];
                            q++;
                            f = 0;
                            if (--j === 1) {
                                e = true;
                                break
                            }
                        }
                    } while ((f | q) < o);
                    if (e) {
                        break
                    }
                    do {
                        f = h - C(R[n], O, r, h, h - 1, U);
                        if (f !== 0) {
                            k -= f;
                            m -= f;
                            h -= f;
                            g = k + 1;
                            d = m + 1;
                            for (l = f - 1; l >= 0; l--) {
                                O[g + l] = O[d + l]
                            }
                            if (h === 0) {
                                e = true;
                                break
                            }
                        }
                        O[k--] = R[n--];
                        if (--j === 1) {
                            e = true;
                            break
                        }
                        q = j - J(O[m], R, 0, j, j - 1, U);
                        if (q !== 0) {
                            k -= q;
                            n -= q;
                            j -= q;
                            g = k + 1;
                            d = n + 1;
                            for (l = 0; l < q; l++) {
                                O[g + l] = R[d + l]
                            }
                            if (j <= 1) {
                                e = true;
                                break
                            }
                        }
                        O[k--] = O[m--];
                        if (--h === 0) {
                            e = true;
                            break
                        }
                        o--
                    } while (f >= A || q >= A);
                    if (e) {
                        break
                    }
                    if (o < 0) {
                        o = 0
                    }
                    o += 2
                }
                W = o;
                if (W < 1) {
                    W = 1
                }
                if (j === 1) {
                    k -= h;
                    m -= h;
                    g = k + 1;
                    d = m + 1;
                    for (l = h - 1; l >= 0; l--) {
                        O[g + l] = O[d + l]
                    }
                    O[k] = R[n]
                } else {
                    if (j === 0) {
                        throw new Error()
                    } else {
                        d = k - (j - 1);
                        for (l = 0; l < j; l++) {
                            O[d + l] = R[l]
                        }
                    }
                }
            }

            this.mergeRuns = b;
            this.forceMergeRuns = c;
            this.pushRun = Y
        }

        function F(N, S, R, Q) {
            if (!R) {
                R = 0
            }
            if (!Q) {
                Q = N.length
            }
            var P = Q - R;
            if (P < 2) {
                return
            }
            var U = 0;
            if (P < D) {
                U = L(N, R, Q, S);
                I(N, R, Q, R + U, S);
                return
            }
            var T = new E(N, S);
            var V = B(P);
            do {
                U = L(N, R, Q, S);
                if (U < V) {
                    var O = P;
                    if (O > V) {
                        O = V
                    }
                    I(N, R, R + O, R + U, S);
                    U = O
                }
                T.pushRun(R, U);
                T.mergeRuns();
                P -= U;
                R += U
            } while (P !== 0);
            T.forceMergeRuns()
        }

        K.exports = F
    }, function(G, H, B) {
        var F = B(4);
        var C = B(88).Dispatcher;
        var D = B(89);
        var E = B(28);
        var A = function(I) {
            I = I || {};
            this.stage = I.stage || {};
            this.onframe = I.onframe || function() {
            };
            this._clips = [];
            this._running = false;
            this._time;
            this._pausedTime;
            this._pauseStart;
            this._paused = false;
            C.call(this)
        };
        A.prototype = {
            constructor: A, addClip: function(I) {
                this._clips.push(I)
            }, addAnimator: function(J) {
                J.animation = this;
                var K = J.getClips();
                for (var I = 0; I < K.length; I++) {
                    this.addClip(K[I])
                }
            }, removeClip: function(I) {
                var J = F.indexOf(this._clips, I);
                if (J >= 0) {
                    this._clips.splice(J, 1)
                }
            }, removeAnimator: function(J) {
                var K = J.getClips();
                for (var I = 0; I < K.length; I++) {
                    this.removeClip(K[I])
                }
                J.animation = null
            }, _update: function() {
                var J = new Date().getTime() - this._pausedTime;
                var P = J - this._time;
                var N = this._clips;
                var O = N.length;
                var K = [];
                var L = [];
                for (var M = 0; M < O; M++) {
                    var Q = N[M];
                    var I = Q.step(J, P);
                    if (I) {
                        K.push(I);
                        L.push(Q)
                    }
                }
                for (var M = 0; M < O;) {
                    if (N[M]._needsRemove) {
                        N[M] = N[O - 1];
                        N.pop();
                        O--
                    } else {
                        M++
                    }
                }
                O = K.length;
                for (var M = 0; M < O; M++) {
                    L[M].fire(K[M])
                }
                this._time = J;
                this.onframe(P);
                this.trigger("frame", P);
                if (this.stage.update) {
                    this.stage.update()
                }
            }, _startLoop: function() {
                var J = this;
                this._running = true;

                function I() {
                    if (J._running) {
                        D(I);
                        !J._paused && J._update()
                    }
                }

                D(I)
            }, start: function() {
                this._time = new Date().getTime();
                this._pausedTime = 0;
                this._startLoop()
            }, stop: function() {
                this._running = false
            }, pause: function() {
                if (!this._paused) {
                    this._pauseStart = new Date().getTime();
                    this._paused = true
                }
            }, resume: function() {
                if (this._paused) {
                    this._pausedTime += (new Date().getTime()) - this._pauseStart;
                    this._paused = false
                }
            }, clear: function() {
                this._clips = []
            }, animate: function(K, J) {
                J = J || {};
                var I = new E(K, J.loop, J.getter, J.setter);
                this.addAnimator(I);
                return I
            }
        };
        F.mixin(A, C);
        G.exports = A
    }, function(K, M, F) {
        var H = F(25);
        var I = F(2);
        var D = (typeof window !== "undefined") && !!window.addEventListener;

        function E(N) {
            return N.getBoundingClientRect ? N.getBoundingClientRect() : {left: 0, top: 0}
        }

        function B(N, O, P, Q) {
            P = P || {};
            if (Q || !I.canvasSupported) {
                A(N, O, P)
            } else {
                if (I.browser.firefox && O.layerX != null && O.layerX !== O.offsetX) {
                    P.zrX = O.layerX;
                    P.zrY = O.layerY
                } else {
                    if (O.offsetX != null) {
                        P.zrX = O.offsetX;
                        P.zrY = O.offsetY
                    } else {
                        A(N, O, P)
                    }
                }
            }
            return P
        }

        function A(N, O, P) {
            var Q = E(N);
            P.zrX = O.clientX - Q.left;
            P.zrY = O.clientY - Q.top
        }

        function L(N, O, R) {
            O = O || window.event;
            if (O.zrX != null) {
                return O
            }
            var P = O.type;
            var S = P && P.indexOf("touch") >= 0;
            if (!S) {
                B(N, O, O, R);
                O.zrDelta = (O.wheelDelta) ? O.wheelDelta / 120 : -(O.detail || 0) / 3
            } else {
                var Q = P != "touchend" ? O.targetTouches[0] : O.changedTouches[0];
                Q && B(N, Q, O, R)
            }
            return O
        }

        function J(N, P, O) {
            if (D) {
                N.addEventListener(P, O)
            } else {
                N.attachEvent("on" + P, O)
            }
        }

        function C(N, P, O) {
            if (D) {
                N.removeEventListener(P, O)
            } else {
                N.detachEvent("on" + P, O)
            }
        }

        var G = D ? function(N) {
            N.preventDefault();
            N.stopPropagation();
            N.cancelBubble = true
        } : function(N) {
            N.returnValue = false;
            N.cancelBubble = true
        };
        K.exports = {clientToLocal: B, normalizeEvent: L, addEventListener: J, removeEventListener: C, stop: G, Dispatcher: H}
    }, function(A, B) {
        A.exports = (typeof window !== "undefined" && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window)) || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window)) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame)) || function(C) {
            setTimeout(C, 16)
        }
    }, function(Q, E, S) {
        var R = S(88);
        var D = S(4);
        var O = S(25);
        var A = S(2);
        var T = S(91);
        var P = R.addEventListener;
        var X = R.removeEventListener;
        var F = R.normalizeEvent;
        var G = 300;
        var B = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
        var I = ["touchstart", "touchend", "touchmove"];
        var M = {pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1};
        var K = D.map(B, function(Z) {
            var Y = Z.replace("mouse", "pointer");
            return M[Y] ? Y : Z
        });

        function U(Y) {
            return (Y === "mousewheel" && A.browser.firefox) ? "DOMMouseScroll" : Y
        }

        function N(a, c, Z) {
            var Y = a._gestureMgr;
            Z === "start" && Y.clear();
            var d = Y.recognize(c, a.handler.findHover(c.zrX, c.zrY, null).target, a.dom);
            Z === "end" && Y.clear();
            if (d) {
                var b = d.type;
                c.gestureEvent = b;
                a.handler.dispatchToElement({target: d.target}, b, d.event)
            }
        }

        function L(Y) {
            Y._touching = true;
            clearTimeout(Y._touchTimer);
            Y._touchTimer = setTimeout(function() {
                Y._touching = false
            }, 700)
        }

        var W = {
            mousemove: function(Y) {
                Y = F(this.dom, Y);
                this.trigger("mousemove", Y)
            }, mouseout: function(Y) {
                Y = F(this.dom, Y);
                var Z = Y.toElement || Y.relatedTarget;
                if (Z != this.dom) {
                    while (Z && Z.nodeType != 9) {
                        if (Z === this.dom) {
                            return
                        }
                        Z = Z.parentNode
                    }
                }
                this.trigger("mouseout", Y)
            }, touchstart: function(Y) {
                Y = F(this.dom, Y);
                Y.zrByTouch = true;
                this._lastTouchMoment = new Date();
                N(this, Y, "start");
                W.mousemove.call(this, Y);
                W.mousedown.call(this, Y);
                L(this)
            }, touchmove: function(Y) {
                Y = F(this.dom, Y);
                Y.zrByTouch = true;
                N(this, Y, "change");
                W.mousemove.call(this, Y);
                L(this)
            }, touchend: function(Y) {
                Y = F(this.dom, Y);
                Y.zrByTouch = true;
                N(this, Y, "end");
                W.mouseup.call(this, Y);
                if (+new Date() - this._lastTouchMoment < G) {
                    W.click.call(this, Y)
                }
                L(this)
            }, pointerdown: function(Y) {
                W.mousedown.call(this, Y)
            }, pointermove: function(Y) {
                if (!C(Y)) {
                    W.mousemove.call(this, Y)
                }
            }, pointerup: function(Y) {
                W.mouseup.call(this, Y)
            }, pointerout: function(Y) {
                if (!C(Y)) {
                    W.mouseout.call(this, Y)
                }
            }
        };

        function C(Z) {
            var Y = Z.pointerType;
            return Y === "pen" || Y === "touch"
        }

        D.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(Y) {
            W[Y] = function(Z) {
                Z = F(this.dom, Z);
                this.trigger(Y, Z)
            }
        });

        function H(Y) {
            D.each(I, function(a) {
                Y._handlers[a] = D.bind(W[a], Y)
            });
            D.each(K, function(a) {
                Y._handlers[a] = D.bind(W[a], Y)
            });
            D.each(B, function(a) {
                Y._handlers[a] = Z(W[a], Y)
            });

            function Z(b, a) {
                return function() {
                    if (a._touching) {
                        return
                    }
                    return b.apply(a, arguments)
                }
            }
        }

        function V(Y) {
            O.call(this);
            this.dom = Y;
            this._touching = false;
            this._touchTimer;
            this._gestureMgr = new T();
            this._handlers = {};
            H(this);
            if (A.pointerEventsSupported) {
                Z(K, this)
            } else {
                if (A.touchEventsSupported) {
                    Z(I, this)
                }
                Z(B, this)
            }

            function Z(b, a) {
                D.each(b, function(c) {
                    P(Y, U(c), a._handlers[c])
                }, a)
            }
        }

        var J = V.prototype;
        J.dispose = function() {
            var a = B.concat(I);
            for (var Y = 0; Y < a.length; Y++) {
                var Z = a[Y];
                X(this.dom, U(Z), this._handlers[Z])
            }
        };
        J.setCursor = function(Y) {
            this.dom.style.cursor = Y || "default"
        };
        D.mixin(V, O);
        Q.exports = V
    }, function(G, H, B) {
        var D = B(88);
        var E = function() {
            this._track = []
        };
        E.prototype = {
            constructor: E, recognize: function(J, K, I) {
                this._doTrack(J, K, I);
                return this._recognize(J)
            }, clear: function() {
                this._track.length = 0;
                return this
            }, _doTrack: function(L, P, I) {
                var O = L.touches;
                if (!O) {
                    return
                }
                var M = {points: [], touches: [], target: P, event: L};
                for (var N = 0, Q = O.length; N < Q; N++) {
                    var J = O[N];
                    var K = D.clientToLocal(I, J, {});
                    M.points.push([K.zrX, K.zrY]);
                    M.touches.push(J)
                }
                this._track.push(M)
            }, _recognize: function(J) {
                for (var I in C) {
                    if (C.hasOwnProperty(I)) {
                        var K = C[I](this._track, J);
                        if (K) {
                            return K
                        }
                    }
                }
            }
        };

        function F(I) {
            var J = I[1][0] - I[0][0];
            var K = I[1][1] - I[0][1];
            return Math.sqrt(J * J + K * K)
        }

        function A(I) {
            return [(I[0][0] + I[1][0]) / 2, (I[0][1] + I[1][1]) / 2]
        }

        var C = {
            pinch: function(M, O) {
                var L = M.length;
                if (!L) {
                    return
                }
                var I = (M[L - 1] || {}).points;
                var J = (M[L - 2] || {}).points || I;
                if (J && J.length > 1 && I && I.length > 1) {
                    var K = F(I) / F(J);
                    !isFinite(K) && (K = 1);
                    O.pinchScale = K;
                    var N = A(I);
                    O.pinchX = N[0];
                    O.pinchY = N[1];
                    return {type: "pinch", target: M[0].target, event: O}
                }
            }
        };
        G.exports = E
    }, function(O, I, P) {
        var B = P(34);
        var M = P(4);
        var T = P(33);
        var R = P(9);
        var C = P(86);
        var J = P(93);
        var K = P(89);
        var F = 5;

        function L(W) {
            return parseInt(W, 10)
        }

        function H(W) {
            if (!W) {
                return false
            }
            if (W.__builtin__) {
                return true
            }
            if (typeof(W.resize) !== "function" || typeof(W.refresh) !== "function") {
                return false
            }
            return true
        }

        function S(W) {
            W.__unusedCount++
        }

        function D(W) {
            if (W.__unusedCount == 1) {
                W.clear()
            }
        }

        var Q = new R(0, 0, 0, 0);
        var V = new R(0, 0, 0, 0);

        function N(W, Y, X) {
            Q.copy(W.getBoundingRect());
            if (W.transform) {
                Q.applyTransform(W.transform)
            }
            V.width = Y;
            V.height = X;
            return !Q.intersect(V)
        }

        function G(X, Y) {
            if (X == Y) {
                return false
            }
            if (!X || !Y || (X.length !== Y.length)) {
                return true
            }
            for (var W = 0; W < X.length; W++) {
                if (X[W] !== Y[W]) {
                    return true
                }
            }
        }

        function U(Y, Z) {
            for (var W = 0; W < Y.length; W++) {
                var X = Y[W];
                X.setTransform(Z);
                Z.beginPath();
                X.buildPath(Z, X.shape);
                Z.clip();
                X.restoreTransform(Z)
            }
        }

        function A(Y, W) {
            var X = document.createElement("div");
            X.style.cssText = ["position:relative", "overflow:hidden", "width:" + Y + "px", "height:" + W + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";";
            return X
        }

        var E = function(a, W, b) {
            var e = !a.nodeName || a.nodeName.toUpperCase() === "CANVAS";
            this._opts = b = M.extend({}, b || {});
            this.dpr = b.devicePixelRatio || B.devicePixelRatio;
            this._singleCanvas = e;
            this.root = a;
            var Y = a.style;
            if (Y) {
                Y["-webkit-tap-highlight-color"] = "transparent";
                Y["-webkit-user-select"] = Y["user-select"] = Y["-webkit-touch-callout"] = "none";
                a.innerHTML = ""
            }
            this.storage = W;
            var c = this._zlevelList = [];
            var f = this._layers = {};
            this._layerConfig = {};
            if (!e) {
                this._width = this._getSize(0);
                this._height = this._getSize(1);
                var X = this._domRoot = A(this._width, this._height);
                a.appendChild(X)
            } else {
                if (b.width != null) {
                    a.width = b.width
                }
                if (b.height != null) {
                    a.height = b.height
                }
                var d = a.width;
                var g = a.height;
                this._width = d;
                this._height = g;
                var Z = new J(a, this, 1);
                Z.initContext();
                f[0] = Z;
                c.push(0);
                this._domRoot = a
            }
            this._progressiveLayers = [];
            this._hoverlayer;
            this._hoverElements = []
        };
        E.prototype = {
            constructor: E, isSingleCanvas: function() {
                return this._singleCanvas
            }, getViewportRoot: function() {
                return this._domRoot
            }, refresh: function(Y) {
                var b = this.storage.getDisplayList(true);
                var X = this._zlevelList;
                this._paintList(b, Y);
                for (var W = 0; W < X.length; W++) {
                    var Z = X[W];
                    var a = this._layers[Z];
                    if (!a.__builtin__ && a.refresh) {
                        a.refresh()
                    }
                }
                this.refreshHover();
                if (this._progressiveLayers.length) {
                    this._startProgessive()
                }
                return this
            }, addHover: function(W, Y) {
                if (W.__hoverMir) {
                    return
                }
                var X = new W.constructor({style: W.style, shape: W.shape});
                X.__from = W;
                W.__hoverMir = X;
                X.setStyle(Y);
                this._hoverElements.push(X)
            }, removeHover: function(W) {
                var X = W.__hoverMir;
                var Z = this._hoverElements;
                var Y = M.indexOf(Z, X);
                if (Y >= 0) {
                    Z.splice(Y, 1)
                }
                W.__hoverMir = null
            }, clearHover: function(W) {
                var Z = this._hoverElements;
                for (var X = 0; X < Z.length; X++) {
                    var Y = Z[X].__from;
                    if (Y) {
                        Y.__hoverMir = null
                    }
                }
                Z.length = 0
            }, refreshHover: function() {
                var b = this._hoverElements;
                var Z = b.length;
                var Y = this._hoverlayer;
                Y && Y.clear();
                if (!Z) {
                    return
                }
                C(b, this.storage.displayableSortFunc);
                if (!Y) {
                    Y = this._hoverlayer = this.getLayer(100000)
                }
                var a = {};
                Y.ctx.save();
                for (var X = 0; X < Z;) {
                    var W = b[X];
                    var c = W.__from;
                    if (!(c && c.__zr)) {
                        b.splice(X, 1);
                        c.__hoverMir = null;
                        Z--;
                        continue
                    }
                    X++;
                    if (!c.invisible) {
                        W.transform = c.transform;
                        W.invTransform = c.invTransform;
                        W.__clipPaths = c.__clipPaths;
                        this._doPaintEl(W, Y, true, a)
                    }
                }
                Y.ctx.restore()
            }, _startProgessive: function() {
                var Y = this;
                if (!Y._furtherProgressive) {
                    return
                }
                var X = Y._progressiveToken = +new Date();
                Y._progress++;
                K(W);

                function W() {
                    if (X === Y._progressiveToken && Y.storage) {
                        Y._doPaintList(Y.storage.getDisplayList());
                        if (Y._furtherProgressive) {
                            Y._progress++;
                            K(W)
                        } else {
                            Y._progressiveToken = -1
                        }
                    }
                }
            }, _clearProgressive: function() {
                this._progressiveToken = -1;
                this._progress = 0;
                M.each(this._progressiveLayers, function(W) {
                    W.__dirty && W.clear()
                })
            }, _paintList: function(X, W) {
                if (W == null) {
                    W = false
                }
                this._updateLayerStatus(X);
                this._clearProgressive();
                this.eachBuiltinLayer(S);
                this._doPaintList(X, W);
                this.eachBuiltinLayer(D)
            }, _doPaintList: function(W, f) {
                var a;
                var k;
                var e;
                var d;
                var X = 0;
                var m;
                var h = this._width;
                var p = this._height;
                var g;
                var Y = this._progress;

                function Z(i) {
                    var l = e.dpr || 1;
                    e.save();
                    e.globalAlpha = 1;
                    e.shadowBlur = 0;
                    a.__dirty = true;
                    e.setTransform(1, 0, 0, 1, 0, 0);
                    e.drawImage(i.dom, 0, 0, h * l, p * l);
                    e.restore()
                }

                for (var n = 0, c = W.length; n < c; n++) {
                    var o = W[n];
                    var b = this._singleCanvas ? 0 : o.zlevel;
                    var j = o.__frame;
                    if (j < 0 && m) {
                        Z(m);
                        m = null
                    }
                    if (k !== b) {
                        if (e) {
                            e.restore()
                        }
                        d = {};
                        k = b;
                        a = this.getLayer(k);
                        if (!a.__builtin__) {
                            T("ZLevel " + k + " has been used by unkown layer " + a.id)
                        }
                        e = a.ctx;
                        e.save();
                        a.__unusedCount = 0;
                        if (a.__dirty || f) {
                            a.clear()
                        }
                    }
                    if (!(a.__dirty || f)) {
                        continue
                    }
                    if (j >= 0) {
                        if (!m) {
                            m = this._progressiveLayers[Math.min(X++, F - 1)];
                            m.ctx.save();
                            m.renderScope = {};
                            if (m && (m.__progress > m.__maxProgress)) {
                                n = m.__nextIdxNotProg - 1;
                                continue
                            }
                            g = m.__progress;
                            if (!m.__dirty) {
                                Y = g
                            }
                            m.__progress = Y + 1
                        }
                        if (j === Y) {
                            this._doPaintEl(o, m, true, m.renderScope)
                        }
                    } else {
                        this._doPaintEl(o, a, f, d)
                    }
                    o.__dirty = false
                }
                if (m) {
                    Z(m)
                }
                e && e.restore();
                this._furtherProgressive = false;
                M.each(this._progressiveLayers, function(i) {
                    if (i.__maxProgress >= i.__progress) {
                        this._furtherProgressive = true
                    }
                }, this)
            }, _doPaintEl: function(W, X, Y, b) {
                var c = X.ctx;
                var Z = W.transform;
                if ((X.__dirty || Y) && !W.invisible && W.style.opacity !== 0 && !(Z && !Z[0] && !Z[3]) && !(W.culling && N(W, this._width, this._height))) {
                    var a = W.__clipPaths;
                    if (b.prevClipLayer !== X || G(a, b.prevElClipPaths)) {
                        if (b.prevElClipPaths) {
                            b.prevClipLayer.ctx.restore();
                            b.prevClipLayer = b.prevElClipPaths = null;
                            b.prevEl = null
                        }
                        if (a) {
                            c.save();
                            U(a, c);
                            b.prevClipLayer = X;
                            b.prevElClipPaths = a
                        }
                    }
                    W.beforeBrush && W.beforeBrush(c);
                    W.brush(c, b.prevEl || null);
                    b.prevEl = W;
                    W.afterBrush && W.afterBrush(c)
                }
            }, getLayer: function(X) {
                if (this._singleCanvas) {
                    return this._layers[0]
                }
                var W = this._layers[X];
                if (!W) {
                    W = new J("zr_" + X, this, this.dpr);
                    W.__builtin__ = true;
                    if (this._layerConfig[X]) {
                        M.merge(W, this._layerConfig[X], true)
                    }
                    this.insertLayer(X, W);
                    W.initContext()
                }
                return W
            }, insertLayer: function(Y, e) {
                var Z = this._layers;
                var c = this._zlevelList;
                var d = c.length;
                var W = null;
                var a = -1;
                var X = this._domRoot;
                if (Z[Y]) {
                    T("ZLevel " + Y + " has been used already");
                    return
                }
                if (!H(e)) {
                    T("Layer of zlevel " + Y + " is not valid");
                    return
                }
                if (d > 0 && Y > c[0]) {
                    for (a = 0; a < d - 1; a++) {
                        if (c[a] < Y && c[a + 1] > Y) {
                            break
                        }
                    }
                    W = Z[c[a]]
                }
                c.splice(a + 1, 0, Y);
                Z[Y] = e;
                if (!e.virtual) {
                    if (W) {
                        var b = W.dom;
                        if (b.nextSibling) {
                            X.insertBefore(e.dom, b.nextSibling)
                        } else {
                            X.appendChild(e.dom)
                        }
                    } else {
                        if (X.firstChild) {
                            X.insertBefore(e.dom, X.firstChild)
                        } else {
                            X.appendChild(e.dom)
                        }
                    }
                }
            }, eachLayer: function(W, X) {
                var Y = this._zlevelList;
                var a;
                var Z;
                for (Z = 0; Z < Y.length; Z++) {
                    a = Y[Z];
                    W.call(X, this._layers[a], a)
                }
            }, eachBuiltinLayer: function(W, X) {
                var Y = this._zlevelList;
                var b;
                var a;
                var Z;
                for (Z = 0; Z < Y.length; Z++) {
                    a = Y[Z];
                    b = this._layers[a];
                    if (b.__builtin__) {
                        W.call(X, b, a)
                    }
                }
            }, eachOtherLayer: function(W, X) {
                var Y = this._zlevelList;
                var b;
                var a;
                var Z;
                for (Z = 0; Z < Y.length; Z++) {
                    a = Y[Z];
                    b = this._layers[a];
                    if (!b.__builtin__) {
                        W.call(X, b, a)
                    }
                }
            }, getLayers: function() {
                return this._layers
            }, _updateLayerStatus: function(X) {
                var e = this._layers;
                var a = this._progressiveLayers;
                var Y = {};
                var j = {};
                this.eachBuiltinLayer(function(l, i) {
                    Y[i] = l.elCount;
                    l.elCount = 0;
                    l.__dirty = false
                });
                M.each(a, function(i, l) {
                    j[l] = i.elCount;
                    i.elCount = 0;
                    i.__dirty = false
                });
                var c = 0;
                var m;
                var h;
                var f = 0;
                for (var Z = 0, b = X.length; Z < b; Z++) {
                    var n = X[Z];
                    var k = this._singleCanvas ? 0 : n.zlevel;
                    var d = e[k];
                    var W = n.progressive;
                    if (d) {
                        d.elCount++;
                        d.__dirty = d.__dirty || n.__dirty
                    }
                    if (W >= 0) {
                        if (h !== W) {
                            h = W;
                            f++
                        }
                        var g = n.__frame = f - 1;
                        if (!m) {
                            var o = Math.min(c, F - 1);
                            m = a[o];
                            if (!m) {
                                m = a[o] = new J("progressive", this, this.dpr);
                                m.initContext()
                            }
                            m.__maxProgress = 0
                        }
                        m.__dirty = m.__dirty || n.__dirty;
                        m.elCount++;
                        m.__maxProgress = Math.max(m.__maxProgress, g);
                        if (m.__maxProgress >= m.__progress) {
                            d.__dirty = true
                        }
                    } else {
                        n.__frame = -1;
                        if (m) {
                            m.__nextIdxNotProg = Z;
                            c++;
                            m = null
                        }
                    }
                }
                if (m) {
                    c++;
                    m.__nextIdxNotProg = Z
                }
                this.eachBuiltinLayer(function(l, i) {
                    if (Y[i] !== l.elCount) {
                        l.__dirty = true
                    }
                });
                a.length = Math.min(c, F);
                M.each(a, function(i, l) {
                    if (j[l] !== i.elCount) {
                        n.__dirty = true
                    }
                    if (i.__dirty) {
                        i.__progress = 0
                    }
                })
            }, clear: function() {
                this.eachBuiltinLayer(this._clearLayer);
                return this
            }, _clearLayer: function(W) {
                W.clear()
            }, configLayer: function(Z, Y) {
                if (Y) {
                    var X = this._layerConfig;
                    if (!X[Z]) {
                        X[Z] = Y
                    } else {
                        M.merge(X[Z], Y, true)
                    }
                    var W = this._layers[Z];
                    if (W) {
                        M.merge(W, X[Z], true)
                    }
                }
            }, delLayer: function(Z) {
                var Y = this._layers;
                var X = this._zlevelList;
                var W = Y[Z];
                if (!W) {
                    return
                }
                W.dom.parentNode.removeChild(W.dom);
                delete Y[Z];
                X.splice(M.indexOf(X, Z), 1)
            }, resize: function(Z, W) {
                var Y = this._domRoot;
                Y.style.display = "none";
                var X = this._opts;
                Z != null && (X.width = Z);
                W != null && (X.height = W);
                Z = this._getSize(0);
                W = this._getSize(1);
                Y.style.display = "";
                if (this._width != Z || W != this._height) {
                    Y.style.width = Z + "px";
                    Y.style.height = W + "px";
                    for (var a in this._layers) {
                        if (this._layers.hasOwnProperty(a)) {
                            this._layers[a].resize(Z, W)
                        }
                    }
                    M.each(this._progressiveLayers, function(b) {
                        b.resize(Z, W)
                    });
                    this.refresh(true)
                }
                this._width = Z;
                this._height = W;
                return this
            }, clearLayer: function(X) {
                var W = this._layers[X];
                if (W) {
                    W.clear()
                }
            }, dispose: function() {
                this.root.innerHTML = "";
                this.root = this.storage = this._domRoot = this._layers = null
            }, getRenderedCanvas: function(b) {
                b = b || {};
                if (this._singleCanvas) {
                    return this._layers[0].dom
                }
                var c = new J("image", this, b.pixelRatio || this.dpr);
                c.initContext();
                c.clearColor = b.backgroundColor;
                c.clear();
                var d = this.storage.getDisplayList(true);
                var Y = {};
                var W;
                var e = this;

                function X(j, h) {
                    var g = e._zlevelList;
                    if (j == null) {
                        j = -Infinity
                    }
                    var l;
                    for (var k = 0; k < g.length; k++) {
                        var m = g[k];
                        var f = e._layers[m];
                        if (!f.__builtin__ && m > j && m < h) {
                            l = f;
                            break
                        }
                    }
                    if (l && l.renderToCanvas) {
                        c.ctx.save();
                        l.renderToCanvas(c.ctx);
                        c.ctx.restore()
                    }
                }

                for (var a = 0; a < d.length; a++) {
                    var Z = d[a];
                    if (Z.zlevel !== W) {
                        X(W, Z.zlevel);
                        W = Z.zlevel
                    }
                    this._doPaintEl(Z, c, true, Y)
                }
                X(W, Infinity);
                return c.dom
            }, getWidth: function() {
                return this._width
            }, getHeight: function() {
                return this._height
            }, _getSize: function(W) {
                var Z = this._opts;
                var d = ["width", "height"][W];
                var X = ["clientWidth", "clientHeight"][W];
                var a = ["paddingLeft", "paddingTop"][W];
                var b = ["paddingRight", "paddingBottom"][W];
                if (Z[d] != null && Z[d] !== "auto") {
                    return parseFloat(Z[d])
                }
                var Y = this.root;
                var c = document.defaultView.getComputedStyle(Y);
                return ((Y[X] || L(c[d]) || L(Y.style[d])) - (L(c[a]) || 0) - (L(c[b]) || 0)) | 0
            }, pathToImage: function(a, g) {
                g = g || this.dpr;
                var W = document.createElement("canvas");
                var m = W.getContext("2d");
                var Z = a.getBoundingRect();
                var n = a.style;
                var i = n.shadowBlur;
                var Y = n.shadowOffsetX;
                var X = n.shadowOffsetY;
                var h = n.hasStroke() ? n.lineWidth : 0;
                var o = Math.max(h / 2, -Y + i);
                var j = Math.max(h / 2, Y + i);
                var d = Math.max(h / 2, -X + i);
                var f = Math.max(h / 2, X + i);
                var b = Z.width + o + j;
                var l = Z.height + d + f;
                W.width = b * g;
                W.height = l * g;
                m.scale(g, g);
                m.clearRect(0, 0, b, l);
                m.dpr = g;
                var k = {position: a.position, rotation: a.rotation, scale: a.scale};
                a.position = [o - Z.x, d - Z.y];
                a.rotation = 0;
                a.scale = [1, 1];
                a.updateTransform();
                if (a) {
                    a.brush(m)
                }
                var e = P(49);
                var c = new e({style: {x: 0, y: 0, image: W}});
                if (k.position != null) {
                    c.position = a.position = k.position
                }
                if (k.rotation != null) {
                    c.rotation = a.rotation = k.rotation
                }
                if (k.scale != null) {
                    c.scale = a.scale = k.scale
                }
                return c
            }
        };
        O.exports = E
    }, function(I, J, C) {
        var H = C(4);
        var A = C(34);
        var D = C(22);
        var B = C(46);

        function G() {
            return false
        }

        function E(P, M, R, O) {
            var Q = document.createElement(M);
            var L = R.getWidth();
            var K = R.getHeight();
            var N = Q.style;
            N.position = "absolute";
            N.left = 0;
            N.top = 0;
            N.width = L + "px";
            N.height = K + "px";
            Q.width = L * O;
            Q.height = K * O;
            Q.setAttribute("data-zr-dom-id", P);
            return Q
        }

        var F = function(O, L, N) {
            var K;
            N = N || A.devicePixelRatio;
            if (typeof O === "string") {
                K = E(O, "canvas", L, N)
            } else {
                if (H.isObject(O)) {
                    K = O;
                    O = K.id
                }
            }
            this.id = O;
            this.dom = K;
            var M = K.style;
            if (M) {
                K.onselectstart = G;
                M["-webkit-user-select"] = "none";
                M["user-select"] = "none";
                M["-webkit-touch-callout"] = "none";
                M["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
                M["padding"] = 0;
                M["margin"] = 0;
                M["border-width"] = 0
            }
            this.domBack = null;
            this.ctxBack = null;
            this.painter = L;
            this.config = null;
            this.clearColor = 0;
            this.motionBlur = false;
            this.lastFrameAlpha = 0.7;
            this.dpr = N
        };
        F.prototype = {
            constructor: F, elCount: 0, __dirty: true, initContext: function() {
                this.ctx = this.dom.getContext("2d");
                this.ctx.dpr = this.dpr
            }, createBackBuffer: function() {
                var K = this.dpr;
                this.domBack = E("back-" + this.id, "canvas", this.painter, K);
                this.ctxBack = this.domBack.getContext("2d");
                if (K != 1) {
                    this.ctxBack.scale(K, K)
                }
            }, resize: function(N, L) {
                var O = this.dpr;
                var K = this.dom;
                var P = K.style;
                var M = this.domBack;
                P.width = N + "px";
                P.height = L + "px";
                K.width = N * O;
                K.height = L * O;
                if (M) {
                    M.width = N * O;
                    M.height = L * O;
                    if (O != 1) {
                        this.ctxBack.scale(O, O)
                    }
                }
            }, clear: function(K) {
                var M = this.dom;
                var P = this.ctx;
                var S = M.width;
                var L = M.height;
                var T = this.clearColor;
                var N = this.motionBlur && !K;
                var R = this.lastFrameAlpha;
                var Q = this.dpr;
                if (N) {
                    if (!this.domBack) {
                        this.createBackBuffer()
                    }
                    this.ctxBack.globalCompositeOperation = "copy";
                    this.ctxBack.drawImage(M, 0, 0, S / Q, L / Q)
                }
                P.clearRect(0, 0, S, L);
                if (T) {
                    var O;
                    if (T.colorStops) {
                        O = T.__canvasGradient || D.getGradient(P, T, {x: 0, y: 0, width: S, height: L});
                        T.__canvasGradient = O
                    } else {
                        if (T.image) {
                            O = B.prototype.getCanvasPattern.call(T, P)
                        }
                    }
                    P.save();
                    P.fillStyle = O || T;
                    P.fillRect(0, 0, S, L);
                    P.restore()
                }
                if (N) {
                    var U = this.domBack;
                    P.save();
                    P.globalAlpha = R;
                    P.drawImage(U, 0, 0, S, L);
                    P.restore()
                }
            }
        };
        I.exports = F
    }, function(C, D, B) {
        var A = B(66);
        C.exports = function(F) {
            function E(H) {
                var G = (H.visualColorAccessPath || "itemStyle.normal.color").split(".");
                var J = H.getData();
                var I = H.get(G) || H.getColorFromPalette(H.get("name"));
                J.setVisual("color", I);
                if (!F.isSeriesFiltered(H)) {
                    if (typeof I === "function" && !(I instanceof A)) {
                        J.each(function(K) {
                            J.setItemVisual(K, "color", I(H.getDataParams(K)))
                        })
                    }
                    J.each(function(L) {
                        var K = J.getItemModel(L);
                        var M = K.get(G, true);
                        if (M != null) {
                            J.setItemVisual(L, "color", M)
                        }
                    })
                }
            }

            F.eachRawSeries(E)
        }
    }, function(K, L, E) {
        var C = E(4);
        var D = E(96);

        function F(N, P) {
            P = P.split(",");
            var O = N;
            for (var M = 0; M < P.length; M++) {
                O = O && O[P[M]];
                if (O == null) {
                    break
                }
            }
            return O
        }

        function G(N, S, R, P) {
            S = S.split(",");
            var Q = N;
            var M;
            for (var O = 0; O < S.length - 1; O++) {
                M = S[O];
                if (Q[M] == null) {
                    Q[M] = {}
                }
                Q = Q[M]
            }
            if (P || Q[S[O]] == null) {
                Q[S[O]] = R
            }
        }

        function H(M) {
            A(I, function(N) {
                if (N[0] in M && !(N[1] in M)) {
                    M[N[1]] = M[N[0]]
                }
            })
        }

        var I = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
        var J = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
        var B = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"];
        var A = C.each;
        K.exports = function(M) {
            A(M.series, function(P) {
                if (!C.isObject(P)) {
                    return
                }
                var O = P.type;
                D(P);
                if (O === "pie" || O === "gauge") {
                    if (P.clockWise != null) {
                        P.clockwise = P.clockWise
                    }
                }
                if (O === "gauge") {
                    var Q = F(P, "pointer.color");
                    Q != null && G(P, "itemStyle.normal.color", Q)
                }
                for (var N = 0; N < B.length; N++) {
                    if (B[N] === P.type) {
                        H(P);
                        break
                    }
                }
            });
            if (M.dataRange) {
                M.visualMap = M.dataRange
            }
            A(J, function(O) {
                var N = M[O];
                if (N) {
                    if (!C.isArray(N)) {
                        N = [N]
                    }
                    A(N, function(P) {
                        H(P)
                    })
                }
            })
        }
    }, function(D, F, C) {
        var B = C(4);
        var A = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];

        function E(G) {
            var H = G && G.itemStyle;
            if (H) {
                B.each(A, function(I) {
                    var K = H.normal;
                    var J = H.emphasis;
                    if (K && K[I]) {
                        G[I] = G[I] || {};
                        if (!G[I].normal) {
                            G[I].normal = K[I]
                        } else {
                            B.merge(G[I].normal, K[I])
                        }
                        K[I] = null
                    }
                    if (J && J[I]) {
                        G[I] = G[I] || {};
                        if (!G[I].emphasis) {
                            G[I].emphasis = J[I]
                        } else {
                            B.merge(G[I].emphasis, J[I])
                        }
                        J[I] = null
                    }
                })
            }
        }

        D.exports = function(J) {
            if (!J) {
                return
            }
            E(J);
            E(J.markPoint);
            E(J.markLine);
            var M = J.data;
            if (M) {
                for (var G = 0; G < M.length; G++) {
                    E(M[G])
                }
                var I = J.markPoint;
                if (I && I.data) {
                    var H = I.data;
                    for (var G = 0; G < H.length; G++) {
                        E(H[G])
                    }
                }
                var K = J.markLine;
                if (K && K.data) {
                    var L = K.data;
                    for (var G = 0; G < L.length; G++) {
                        if (B.isArray(L[G])) {
                            E(L[G][0]);
                            E(L[G][1])
                        } else {
                            E(L[G])
                        }
                    }
                }
            }
        }
    }, function(E, F, D) {
        var A = D(18);
        var B = D(4);
        var C = Math.PI;
        E.exports = function(K, I) {
            I = I || {};
            B.defaults(I, {text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0});
            var L = new A.Rect({style: {fill: I.maskColor}, zlevel: I.zlevel, z: 10000});
            var G = new A.Arc({
                shape: {startAngle: -C / 2, endAngle: -C / 2 + 0.1, r: 10},
                style: {stroke: I.color, lineCap: "round", lineWidth: 5},
                zlevel: I.zlevel,
                z: 10001
            });
            var J = new A.Rect({
                style: {fill: "none", text: I.text, textPosition: "right", textDistance: 10, textFill: I.textColor},
                zlevel: I.zlevel,
                z: 10001
            });
            G.animateShape(true).when(1000, {endAngle: C * 3 / 2}).start("circularInOut");
            G.animateShape(true).when(1000, {startAngle: C * 3 / 2}).delay(300).start("circularInOut");
            var H = new A.Group();
            H.add(G);
            H.add(J);
            H.add(L);
            H.resize = function() {
                var O = K.getWidth() / 2;
                var M = K.getHeight() / 2;
                G.setShape({cx: O, cy: M});
                var N = G.shape.r;
                J.setShape({x: O - N, y: M - N, width: N * 2, height: N * 2});
                L.setShape({x: 0, y: 0, width: K.getWidth(), height: K.getHeight()})
            };
            H.resize();
            return H
        }
    }, function(B, C, A) {
        (function(P) {
            var E = "undefined";
            var S = typeof window === "undefined" ? P : window;
            var D = typeof S.Float64Array === E ? Array : S.Float64Array;
            var K = typeof S.Int32Array === E ? Array : S.Int32Array;
            var V = {"float": D, "int": K, "ordinal": Array, "number": Array, "time": Array};
            var U = A(12);
            var M = A(99);
            var J = A(4);
            var H = A(5);
            var Q = J.isObject;
            var R = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"];

            function G(X, W) {
                J.each(R.concat(W.__wrappedMethods || []), function(Y) {
                    if (W.hasOwnProperty(Y)) {
                        X[Y] = W[Y]
                    }
                });
                X.__wrappedMethods = W.__wrappedMethods
            }

            function N(W) {
                this._array = W || []
            }

            N.prototype.pure = false;
            N.prototype.count = function() {
                return this._array.length
            };
            N.prototype.getItem = function(W) {
                return this._array[W]
            };
            var O = function(b, a) {
                b = b || ["x", "y"];
                var c = {};
                var Z = [];
                for (var X = 0; X < b.length; X++) {
                    var Y;
                    var W = {};
                    if (typeof b[X] === "string") {
                        Y = b[X];
                        W = {name: Y, coordDim: Y, coordDimIndex: 0, stackable: false, type: "number"}
                    } else {
                        W = b[X];
                        Y = W.name;
                        W.type = W.type || "number";
                        if (!W.coordDim) {
                            W.coordDim = Y;
                            W.coordDimIndex = 0
                        }
                    }
                    W.otherDims = W.otherDims || {};
                    Z.push(Y);
                    c[Y] = W
                }
                this.dimensions = Z;
                this._dimensionInfos = c;
                this.hostModel = a;
                this.dataType;
                this.indices = [];
                this._storage = {};
                this._nameList = [];
                this._idList = [];
                this._optionModels = [];
                this.stackedOn = null;
                this._visual = {};
                this._layout = {};
                this._itemVisuals = [];
                this._itemLayouts = [];
                this._graphicEls = [];
                this._rawData;
                this._extent
            };
            var T = O.prototype;
            T.type = "list";
            T.hasItemOption = true;
            T.getDimension = function(W) {
                if (!isNaN(W)) {
                    W = this.dimensions[W] || W
                }
                return W
            };
            T.getDimensionInfo = function(W) {
                return J.clone(this._dimensionInfos[this.getDimension(W)])
            };
            T.initData = function(X, W, c) {
                X = X || [];
                var q = J.isArray(X);
                if (q) {
                    X = new N(X)
                }
                if (true) {
                    if (!q && (typeof X.getItem != "function" || typeof X.count != "function")) {
                        throw new Error("Inavlid data provider.")
                    }
                }
                this._rawData = X;
                var Z = this._storage = {};
                var p = this.indices = [];
                var j = this.dimensions;
                var d = this._dimensionInfos;
                var Y = X.count();
                var g = [];
                var s = {};
                var h;
                W = W || [];
                for (var a = 0; a < j.length; a++) {
                    var l = d[j[a]];
                    l.otherDims.itemName === 0 && (h = a);
                    var n = V[l.type];
                    Z[j[a]] = new n(Y)
                }
                var t = this;
                if (!c) {
                    t.hasItemOption = false
                }
                c = c || function(u, v, i, k) {
                    var w = H.getDataItemValue(u);
                    if (H.isDataItemOption(u)) {
                        t.hasItemOption = true
                    }
                    return H.converDataValue((w instanceof Array) ? w[k] : w, d[v])
                };
                for (var a = 0; a < Y; a++) {
                    var b = X.getItem(a);
                    for (var e = 0; e < j.length; e++) {
                        var f = j[e];
                        var m = Z[f];
                        m[a] = c(b, f, a, e)
                    }
                    p.push(a)
                }
                for (var a = 0; a < Y; a++) {
                    var b = X.getItem(a);
                    if (!W[a] && b) {
                        if (b.name != null) {
                            W[a] = b.name
                        } else {
                            if (h != null) {
                                W[a] = Z[j[h]][a]
                            }
                        }
                    }
                    var r = W[a] || "";
                    var o = b && b.id;
                    if (!o && r) {
                        s[r] = s[r] || 0;
                        o = r;
                        if (s[r] > 0) {
                            o += "__ec__" + s[r]
                        }
                        s[r]++
                    }
                    o && (g[a] = o)
                }
                this._nameList = W;
                this._idList = g
            };
            T.count = function() {
                return this.indices.length
            };
            T.get = function(c, Y, e) {
                var W = this._storage;
                var X = this.indices[Y];
                if (X == null || !W[c]) {
                    return NaN
                }
                var a = W[c][X];
                if (e) {
                    var Z = this._dimensionInfos[c];
                    if (Z && Z.stackable) {
                        var b = this.stackedOn;
                        while (b) {
                            var d = b.get(c, Y);
                            if ((a >= 0 && d > 0) || (a <= 0 && d < 0)) {
                                a += d
                            }
                            b = b.stackedOn
                        }
                    }
                }
                return a
            };
            T.getValues = function(Y, Z, W) {
                var a = [];
                if (!J.isArray(Y)) {
                    W = Z;
                    Z = Y;
                    Y = this.dimensions
                }
                for (var X = 0, b = Y.length; X < b; X++) {
                    a.push(this.get(Y[X], Z, W))
                }
                return a
            };
            T.hasValue = function(Y) {
                var X = this.dimensions;
                var a = this._dimensionInfos;
                for (var W = 0, Z = X.length; W < Z; W++) {
                    if (a[X[W]].type !== "ordinal" && isNaN(this.get(X[W], Y))) {
                        return false
                    }
                }
                return true
            };
            T.getDataExtent = function(d, g, b) {
                d = this.getDimension(d);
                var X = this._storage[d];
                var W = this.getDimensionInfo(d);
                g = (W && W.stackable) && g;
                var Y = (this._extent || (this._extent = {}))[d + (!!g)];
                var Z;
                if (Y) {
                    return Y
                }
                if (X) {
                    var f = Infinity;
                    var a = -Infinity;
                    for (var e = 0, c = this.count(); e < c; e++) {
                        Z = this.get(d, e, g);
                        if (!b || b(Z, d, e)) {
                            Z < f && (f = Z);
                            Z > a && (a = Z)
                        }
                    }
                    return (this._extent[d + !!g] = [f, a])
                } else {
                    return [Infinity, -Infinity]
                }
            };
            T.getSum = function(b, X) {
                var Y = this._storage[b];
                var c = 0;
                if (Y) {
                    for (var Z = 0, a = this.count(); Z < a; Z++) {
                        var W = this.get(b, Z, X);
                        if (!isNaN(W)) {
                            c += W
                        }
                    }
                }
                return c
            };
            T.indexOf = function(Z, Y) {
                var W = this._storage;
                var X = W[Z];
                var a = this.indices;
                if (X) {
                    for (var b = 0, d = a.length; b < d; b++) {
                        var c = a[b];
                        if (X[c] === Y) {
                            return b
                        }
                    }
                }
                return -1
            };
            T.indexOfName = function(Z) {
                var W = this.indices;
                var b = this._nameList;
                for (var X = 0, a = W.length; X < a; X++) {
                    var Y = W[X];
                    if (b[Y] === Z) {
                        return X
                    }
                }
                return -1
            };
            T.indexOfRawIndex = function(Z) {
                var W = this.indices;
                var X = W[Z];
                if (X != null && X === Z) {
                    return Z
                }
                var Y = 0;
                var b = W.length - 1;
                while (Y <= b) {
                    var a = (Y + b) / 2 | 0;
                    if (W[a] < Z) {
                        Y = a + 1
                    } else {
                        if (W[a] > Z) {
                            b = a - 1
                        } else {
                            return a
                        }
                    }
                }
                return -1
            };
            T.indicesOfNearest = function(c, Z, j, g) {
                var W = this._storage;
                var Y = W[c];
                var b = [];
                if (!Y) {
                    return b
                }
                if (g == null) {
                    g = Infinity
                }
                var e = Number.MAX_VALUE;
                var h = -1;
                for (var d = 0, a = this.count(); d < a; d++) {
                    var X = Z - this.get(c, d, j);
                    var f = Math.abs(X);
                    if (X <= g && f <= e) {
                        if (f < e || (X >= 0 && h < 0)) {
                            e = f;
                            h = X;
                            b.length = 0
                        }
                        b.push(d)
                    }
                }
                return b
            };
            T.getRawIndex = function(X) {
                var W = this.indices[X];
                return W == null ? -1 : W
            };
            T.getRawDataItem = function(W) {
                return this._rawData.getItem(this.getRawIndex(W))
            };
            T.getName = function(W) {
                return this._nameList[this.indices[W]] || ""
            };
            T.getId = function(W) {
                return this._idList[this.indices[W]] || (this.getRawIndex(W) + "")
            };

            function I(W) {
                if (!J.isArray(W)) {
                    W = [W]
                }
                return W
            }

            T.each = function(X, W, e, Y) {
                if (typeof X === "function") {
                    Y = e;
                    e = W;
                    W = X;
                    X = []
                }
                X = J.map(I(X), this.getDimension, this);
                var Z = [];
                var d = X.length;
                var a = this.indices;
                Y = Y || this;
                for (var c = 0; c < a.length; c++) {
                    switch (d) {
                        case 0:
                            W.call(Y, c);
                            break;
                        case 1:
                            W.call(Y, this.get(X[0], c, e), c);
                            break;
                        case 2:
                            W.call(Y, this.get(X[0], c, e), this.get(X[1], c, e), c);
                            break;
                        default:
                            for (var b = 0; b < d; b++) {
                                Z[b] = this.get(X[b], c, e)
                            }
                            Z[b] = c;
                            W.apply(Y, Z)
                    }
                }
            };
            T.filterSelf = function(W, Y, g, Z) {
                if (typeof W === "function") {
                    Z = g;
                    g = Y;
                    Y = W;
                    W = []
                }
                W = J.map(I(W), this.getDimension, this);
                var f = [];
                var a = [];
                var e = W.length;
                var b = this.indices;
                Z = Z || this;
                for (var d = 0; d < b.length; d++) {
                    var X;
                    if (!e) {
                        X = Y.call(Z, d)
                    } else {
                        if (e === 1) {
                            X = Y.call(Z, this.get(W[0], d, g), d)
                        } else {
                            for (var c = 0; c < e; c++) {
                                a[c] = this.get(W[c], d, g)
                            }
                            a[c] = d;
                            X = Y.apply(Z, a)
                        }
                    }
                    if (X) {
                        f.push(b[d])
                    }
                }
                this.indices = f;
                this._extent = {};
                return this
            };
            T.mapArray = function(Z, W, X, a) {
                if (typeof Z === "function") {
                    a = X;
                    X = W;
                    W = Z;
                    Z = []
                }
                var Y = [];
                this.each(Z, function() {
                    Y.push(W && W.apply(this, arguments))
                }, X, a);
                return Y
            };

            function L(W, c) {
                var e = W.dimensions;
                var Y = new O(J.map(e, W.getDimensionInfo, W), W.hostModel);
                G(Y, W);
                var X = Y._storage = {};
                var Z = W._storage;
                for (var b = 0; b < e.length; b++) {
                    var a = e[b];
                    var d = Z[a];
                    if (J.indexOf(c, a) >= 0) {
                        X[a] = new d.constructor(Z[a].length)
                    } else {
                        X[a] = Z[a]
                    }
                }
                return Y
            }

            T.map = function(W, b, d, Z) {
                W = J.map(I(W), this.getDimension, this);
                var Y = L(this, W);
                var a = Y.indices = this.indices;
                var X = Y._storage;
                var c = [];
                this.each(W, function() {
                    var j = arguments[arguments.length - 1];
                    var g = b && b.apply(this, arguments);
                    if (g != null) {
                        if (typeof g === "number") {
                            c[0] = g;
                            g = c
                        }
                        for (var e = 0; e < g.length; e++) {
                            var f = W[e];
                            var h = X[f];
                            var k = a[j];
                            if (h) {
                                h[k] = g[e]
                            }
                        }
                    }
                }, d, Z);
                return Y
            };
            T.downSample = function(l, f, j, h) {
                var W = L(this, [l]);
                var a = this._storage;
                var g = W._storage;
                var b = this.indices;
                var m = W.indices = [];
                var c = [];
                var Y = [];
                var e = Math.floor(1 / f);
                var d = g[l];
                var X = this.count();
                for (var n = 0; n < a[l].length; n++) {
                    g[l][n] = a[l][n]
                }
                for (var n = 0; n < X; n += e) {
                    if (e > X - n) {
                        e = X - n;
                        c.length = e
                    }
                    for (var Z = 0; Z < e; Z++) {
                        var p = b[n + Z];
                        c[Z] = d[p];
                        Y[Z] = p
                    }
                    var o = j(c);
                    var p = Y[h(c, o) || 0];
                    d[p] = o;
                    m.push(p)
                }
                return W
            };
            T.getItemModel = function(X) {
                var W = this.hostModel;
                X = this.indices[X];
                return new U(this._rawData.getItem(X), W, W && W.ecModel)
            };
            T.diff = function(W) {
                var Y = this._idList;
                var a = W && W._idList;
                var Z;
                var X = "e\0\0";
                return new M(W ? W.indices : [], this.indices, function(b) {
                    return (Z = a[b]) != null ? Z : X + b
                }, function(b) {
                    return (Z = Y[b]) != null ? Z : X + b
                })
            };
            T.getVisual = function(W) {
                var X = this._visual;
                return X && X[W]
            };
            T.setVisual = function(W, Y) {
                if (Q(W)) {
                    for (var X in W) {
                        if (W.hasOwnProperty(X)) {
                            this.setVisual(X, W[X])
                        }
                    }
                    return
                }
                this._visual = this._visual || {};
                this._visual[W] = Y
            };
            T.setLayout = function(W, Y) {
                if (Q(W)) {
                    for (var X in W) {
                        if (W.hasOwnProperty(X)) {
                            this.setLayout(X, W[X])
                        }
                    }
                    return
                }
                this._layout[W] = Y
            };
            T.getLayout = function(W) {
                return this._layout[W]
            };
            T.getItemLayout = function(W) {
                return this._itemLayouts[W]
            };
            T.setItemLayout = function(X, Y, W) {
                this._itemLayouts[X] = W ? J.extend(this._itemLayouts[X] || {}, Y) : Y
            };
            T.clearItemLayouts = function() {
                this._itemLayouts.length = 0
            };
            T.getItemVisual = function(Z, W, a) {
                var Y = this._itemVisuals[Z];
                var X = Y && Y[W];
                if (X == null && !a) {
                    return this.getVisual(W)
                }
                return X
            };
            T.setItemVisual = function(a, X, W) {
                var Y = this._itemVisuals[a] || {};
                this._itemVisuals[a] = Y;
                if (Q(X)) {
                    for (var Z in X) {
                        if (X.hasOwnProperty(Z)) {
                            Y[Z] = X[Z]
                        }
                    }
                    return
                }
                Y[X] = W
            };
            T.clearAllVisual = function() {
                this._visual = {};
                this._itemVisuals = []
            };
            var F = function(W) {
                W.seriesIndex = this.seriesIndex;
                W.dataIndex = this.dataIndex;
                W.dataType = this.dataType
            };
            T.setItemGraphicEl = function(Y, W) {
                var X = this.hostModel;
                if (W) {
                    W.dataIndex = Y;
                    W.dataType = this.dataType;
                    W.seriesIndex = X && X.seriesIndex;
                    if (W.type === "group") {
                        W.traverse(F, W)
                    }
                }
                this._graphicEls[Y] = W
            };
            T.getItemGraphicEl = function(W) {
                return this._graphicEls[W]
            };
            T.eachItemGraphicEl = function(W, X) {
                J.each(this._graphicEls, function(Y, Z) {
                    if (Y) {
                        W && W.call(X, Y, Z)
                    }
                })
            };
            T.cloneShallow = function() {
                var X = J.map(this.dimensions, this.getDimensionInfo, this);
                var W = new O(X, this.hostModel);
                W._storage = this._storage;
                G(W, this);
                W.indices = this.indices.slice();
                if (this._extent) {
                    W._extent = J.extend({}, this._extent)
                }
                return W
            };
            T.wrapMethod = function(X, Y) {
                var W = this[X];
                if (typeof W !== "function") {
                    return
                }
                this.__wrappedMethods = this.__wrappedMethods || [];
                this.__wrappedMethods.push(X);
                this[X] = function() {
                    var Z = W.apply(this, arguments);
                    return Y.apply(this, [Z].concat(J.slice(arguments)))
                }
            };
            T.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"];
            T.CHANGABLE_METHODS = ["filterSelf"];
            B.exports = O
        }.call(C, (function() {
            return this
        }())))
    }, function(B, D) {
        function C(F) {
            return F
        }

        function E(G, I, H, F) {
            this._old = G;
            this._new = I;
            this._oldKeyGetter = H || C;
            this._newKeyGetter = F || C
        }

        E.prototype = {
            constructor: E, add: function(F) {
                this._add = F;
                return this
            }, update: function(F) {
                this._update = F;
                return this
            }, remove: function(F) {
                this._remove = F;
                return this
            }, execute: function() {
                var L = this._old;
                var R = this._new;
                var O = this._oldKeyGetter;
                var Q = this._newKeyGetter;
                var K = {};
                var N = {};
                var J = [];
                var H = [];
                var M;
                A(L, K, J, O);
                A(R, N, H, Q);
                for (M = 0; M < L.length; M++) {
                    var P = J[M];
                    var I = N[P];
                    if (I != null) {
                        var G = I.length;
                        if (G) {
                            G === 1 && (N[P] = null);
                            I = I.unshift()
                        } else {
                            N[P] = null
                        }
                        this._update && this._update(I, M)
                    } else {
                        this._remove && this._remove(M)
                    }
                }
                for (var M = 0; M < H.length; M++) {
                    var P = H[M];
                    if (N.hasOwnProperty(P)) {
                        var I = N[P];
                        if (I == null) {
                            continue
                        }
                        if (!I.length) {
                            this._add && this._add(I)
                        } else {
                            for (var F = 0, G = I.length; F < G; F++) {
                                this._add && this._add(I[F])
                            }
                        }
                    }
                }
            }
        };

        function A(J, H, I, L) {
            for (var G = 0; G < J.length; G++) {
                var F = "_ec_" + L(J[G], G);
                var K = H[F];
                if (K == null) {
                    I.push(F);
                    H[F] = G
                } else {
                    if (!K.length) {
                        H[F] = K = [K]
                    }
                    K.push(G)
                }
            }
        }

        B.exports = E
    }, function(I, J, C) {
        var D = C(7);
        var G = D.linearMap;
        var B = C(4);
        var E = C(101);

        function A(M, O) {
            var K = M[1] - M[0];
            var N = O;
            var L = K / N / 2;
            M[0] += L;
            M[1] -= L
        }

        var H = [0, 1];
        var F = function(L, M, K) {
            this.dim = L;
            this.scale = M;
            this._extent = K || [0, 0];
            this.inverse = false;
            this.onBand = false;
            this._labelInterval
        };
        F.prototype = {
            constructor: F, contain: function(M) {
                var L = this._extent;
                var K = Math.min(L[0], L[1]);
                var N = Math.max(L[0], L[1]);
                return M >= K && M <= N
            }, containData: function(K) {
                return this.contain(this.dataToCoord(K))
            }, getExtent: function() {
                return this._extent.slice()
            }, getPixelPrecision: function(K) {
                return D.getPixelPrecision(K || this.scale.getExtent(), this._extent)
            }, setExtent: function(M, L) {
                var K = this._extent;
                K[0] = M;
                K[1] = L
            }, dataToCoord: function(N, K) {
                var M = this._extent;
                var L = this.scale;
                N = L.normalize(N);
                if (this.onBand && L.type === "ordinal") {
                    M = M.slice();
                    A(M, L.count())
                }
                return G(N, H, M, K)
            }, coordToData: function(L, K) {
                var O = this._extent;
                var N = this.scale;
                if (this.onBand && N.type === "ordinal") {
                    O = O.slice();
                    A(O, N.count())
                }
                var M = G(L, O, H, K);
                return this.scale.scale(M)
            }, pointToData: function(K, L) {
            }, getTicksCoords: function(N) {
                if (this.onBand && !N) {
                    var M = this.getBands();
                    var L = [];
                    for (var K = 0; K < M.length; K++) {
                        L.push(M[K][0])
                    }
                    if (M[K - 1]) {
                        L.push(M[K - 1][1])
                    }
                    return L
                } else {
                    return B.map(this.scale.getTicks(), this.dataToCoord, this)
                }
            }, getLabelsCoords: function() {
                return B.map(this.scale.getTicks(), this.dataToCoord, this)
            }, getBands: function() {
                var N = this.getExtent();
                var M = [];
                var O = this.scale.count();
                var Q = N[0];
                var P = N[1];
                var L = P - Q;
                for (var K = 0; K < O; K++) {
                    M.push([L * K / O + Q, L * (K + 1) / O + Q])
                }
                return M
            }, getBandWidth: function() {
                var L = this._extent;
                var N = this.scale.getExtent();
                var M = N[1] - N[0] + (this.onBand ? 1 : 0);
                M === 0 && (M = 1);
                var K = Math.abs(L[1] - L[0]);
                return Math.abs(K) / M
            }, getLabelInterval: function() {
                var K = this._labelInterval;
                if (!K) {
                    var M = this.model;
                    var L = M.getModel("axisLabel");
                    var N = L.get("interval");
                    if (!(this.type === "category" && N === "auto")) {
                        K = N === "auto" ? 0 : N
                    } else {
                        if (this.isHorizontal) {
                            K = E.getAxisLabelInterval(B.map(this.scale.getTicks(), this.dataToCoord, this), M.getFormattedLabels(), L.getModel("textStyle").getFont(), this.isHorizontal())
                        }
                    }
                    this._labelInterval = K
                }
                return K
            }
        };
        I.exports = F
    }, function(I, J, D) {
        var H = D(102);
        var A = D(104);
        D(106);
        D(107);
        var B = D(103);
        var E = D(7);
        var C = D(4);
        var G = D(8);
        var F = {};
        F.getScaleExtent = function(L, U) {
            var P = L.type;
            var M = U.getMin();
            var N = U.getMax();
            var O = M != null;
            var S = N != null;
            var Q = L.getExtent();
            var T;
            var K;
            var R;
            if (P === "ordinal") {
                T = (U.get("data") || []).length
            } else {
                K = U.get("boundaryGap");
                if (!C.isArray(K)) {
                    K = [K || 0, K || 0]
                }
                if (typeof K[0] === "boolean") {
                    if (true) {
                        console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.')
                    }
                    K = [0, 0]
                }
                K[0] = E.parsePercent(K[0], 1);
                K[1] = E.parsePercent(K[1], 1);
                R = (Q[1] - Q[0]) || Math.abs(Q[0])
            }
            if (M == null) {
                M = P === "ordinal" ? (T ? 0 : NaN) : Q[0] - K[0] * R
            }
            if (N == null) {
                N = P === "ordinal" ? (T ? T - 1 : NaN) : Q[1] + K[1] * R
            }
            if (M === "dataMin") {
                M = Q[0]
            }
            if (N === "dataMax") {
                N = Q[1]
            }
            (M == null || !isFinite(M)) && (M = NaN);
            (N == null || !isFinite(N)) && (N = NaN);
            L.setBlank(C.eqNaN(M) || C.eqNaN(N));
            if (U.getNeedCrossZero()) {
                if (M > 0 && N > 0 && !O) {
                    M = 0
                }
                if (M < 0 && N < 0 && !S) {
                    N = 0
                }
            }
            return [M, N]
        };
        F.niceScaleExtent = function(P, Q) {
            var N = F.getScaleExtent(P, Q);
            var O = Q.getMin() != null;
            var L = Q.getMax() != null;
            var K = Q.get("splitNumber");
            if (P.type === "log") {
                P.base = Q.get("logBase")
            }
            P.setExtent(N[0], N[1]);
            P.niceExtent({splitNumber: K, fixMin: O, fixMax: L, minInterval: P.type === "interval" ? Q.get("minInterval") : null});
            var M = Q.get("interval");
            if (M != null) {
                P.setInterval && P.setInterval(M)
            }
        };
        F.createScaleByModel = function(L, K) {
            K = K || L.get("type");
            if (K) {
                switch (K) {
                    case"category":
                        return new H(L.getCategories(), [Infinity, -Infinity]);
                    case"value":
                        return new A();
                    default:
                        return (B.getClass(K) || A).create(L)
                }
            }
        };
        F.ifAxisCrossZero = function(N) {
            var M = N.scale.getExtent();
            var K = M[0];
            var L = M[1];
            return !((K > 0 && L > 0) || (K < 0 && L < 0))
        };
        F.getAxisLabelInterval = function(T, U, S, L) {
            var K;
            var R = 0;
            var P = 0;
            var O = 1;
            if (U.length > 40) {
                O = Math.floor(U.length / 40)
            }
            for (var Q = 0; Q < T.length; Q += O) {
                var N = T[Q];
                var M = G.getBoundingRect(U[Q], S, "center", "top");
                M[L ? "x" : "y"] += N;
                M[L ? "width" : "height"] *= 1.3;
                if (!K) {
                    K = M.clone()
                } else {
                    if (K.intersect(M)) {
                        P++;
                        R = Math.max(R, P)
                    } else {
                        K.union(M);
                        P = 0
                    }
                }
            }
            if (R === 0 && O > 1) {
                return O
            }
            return (R + 1) * O - 1
        };
        F.getFormattedLabels = function(O, L) {
            var M = O.scale;
            var N = M.getTicksLabels();
            var K = M.getTicks();
            if (typeof L === "string") {
                L = (function(P) {
                    return function(Q) {
                        return P.replace("{value}", Q != null ? Q : "")
                    }
                })(L);
                return C.map(N, L)
            } else {
                if (typeof L === "function") {
                    return C.map(K, function(P, Q) {
                        return L(F.getAxisRawValue(O, P), Q)
                    }, this)
                } else {
                    return N
                }
            }
        };
        F.getAxisRawValue = function(L, K) {
            return L.type === "category" ? L.scale.getLabel(K) : K
        };
        I.exports = F
    }, function(E, F, C) {
        var B = C(4);
        var G = C(103);
        var A = G.prototype;
        var D = G.extend({
            type: "ordinal", init: function(I, H) {
                this._data = I;
                this._extent = H || [0, I.length - 1]
            }, parse: function(H) {
                return typeof H === "string" ? B.indexOf(this._data, H) : Math.round(H)
            }, contain: function(H) {
                H = this.parse(H);
                return A.contain.call(this, H) && this._data[H] != null
            }, normalize: function(H) {
                return A.normalize.call(this, this.parse(H))
            }, scale: function(H) {
                return Math.round(A.scale.call(this, H))
            }, getTicks: function() {
                var J = [];
                var H = this._extent;
                var I = H[0];
                while (I <= H[1]) {
                    J.push(I);
                    I++
                }
                return J
            }, getLabel: function(H) {
                return this._data[H]
            }, count: function() {
                return this._extent[1] - this._extent[0] + 1
            }, unionExtentFromData: function(I, H) {
                this.unionExtent(I.getDataExtent(H, false))
            }, niceTicks: B.noop, niceExtent: B.noop
        });
        D.create = function() {
            return new D()
        };
        E.exports = D
    }, function(D, E, C) {
        var B = C(13);

        function F(G) {
            this._setting = G || {};
            this._extent = [Infinity, -Infinity];
            this._interval = 0;
            this.init && this.init.apply(this, arguments)
        }

        var A = F.prototype;
        A.parse = function(G) {
            return G
        };
        A.getSetting = function(G) {
            return this._setting[G]
        };
        A.contain = function(H) {
            var G = this._extent;
            return H >= G[0] && H <= G[1]
        };
        A.normalize = function(H) {
            var G = this._extent;
            if (G[1] === G[0]) {
                return 0.5
            }
            return (H - G[0]) / (G[1] - G[0])
        };
        A.scale = function(H) {
            var G = this._extent;
            return H * (G[1] - G[0]) + G[0]
        };
        A.unionExtent = function(H) {
            var G = this._extent;
            H[0] < G[0] && (G[0] = H[0]);
            H[1] > G[1] && (G[1] = H[1])
        };
        A.unionExtentFromData = function(H, G) {
            this.unionExtent(H.getDataExtent(G, true))
        };
        A.getExtent = function() {
            return this._extent.slice()
        };
        A.setExtent = function(I, H) {
            var G = this._extent;
            if (!isNaN(I)) {
                G[0] = I
            }
            if (!isNaN(H)) {
                G[1] = H
            }
        };
        A.getTicksLabels = function() {
            var H = [];
            var I = this.getTicks();
            for (var G = 0; G < I.length; G++) {
                H.push(this.getLabel(I[G]))
            }
            return H
        };
        A.isBlank = function() {
            return this._isBlank
        }, A.setBlank = function(G) {
            this._isBlank = G
        };
        B.enableClassExtend(F);
        B.enableClassManagement(F, {registerWhenExtend: true});
        D.exports = F
    }, function(H, I, C) {
        var D = C(7);
        var F = C(6);
        var B = C(103);
        var G = C(105);
        var E = D.round;
        var A = B.extend({
            type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function(L, K) {
                var J = this._extent;
                if (!isNaN(L)) {
                    J[0] = parseFloat(L)
                }
                if (!isNaN(K)) {
                    J[1] = parseFloat(K)
                }
            }, unionExtent: function(K) {
                var J = this._extent;
                K[0] < J[0] && (J[0] = K[0]);
                K[1] > J[1] && (J[1] = K[1]);
                A.prototype.setExtent.call(this, J[0], J[1])
            }, getInterval: function() {
                return this._interval
            }, setInterval: function(J) {
                this._interval = J;
                this._niceExtent = this._extent.slice();
                this._intervalPrecision = G.getIntervalPrecision(J)
            }, getTicks: function() {
                return G.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision)
            }, getTicksLabels: function() {
                var K = [];
                var L = this.getTicks();
                for (var J = 0; J < L.length; J++) {
                    K.push(this.getLabel(L[J]))
                }
                return K
            }, getLabel: function(L, J) {
                if (L == null) {
                    return ""
                }
                var K = J && J.precision;
                if (K == null) {
                    K = D.getPrecisionSafe(L) || 0
                } else {
                    if (K === "auto") {
                        K = this._intervalPrecision
                    }
                }
                L = E(L, K, true);
                return F.addCommas(L)
            }, niceTicks: function(J, N) {
                J = J || 5;
                var M = this._extent;
                var K = M[1] - M[0];
                if (!isFinite(K)) {
                    return
                }
                if (K < 0) {
                    K = -K;
                    M.reverse()
                }
                var L = G.intervalScaleNiceTicks(M, J, N);
                this._intervalPrecision = L.intervalPrecision;
                this._interval = L.interval;
                this._niceExtent = L.niceTickExtent
            }, niceExtent: function(J) {
                var L = this._extent;
                if (L[0] === L[1]) {
                    if (L[0] !== 0) {
                        var M = L[0];
                        if (!J.fixMax) {
                            L[1] += M / 2;
                            L[0] -= M / 2
                        } else {
                            L[0] -= M / 2
                        }
                    } else {
                        L[1] = 1
                    }
                }
                var N = L[1] - L[0];
                if (!isFinite(N)) {
                    L[0] = 0;
                    L[1] = 1
                }
                this.niceTicks(J.splitNumber, J.minInterval);
                var K = this._interval;
                if (!J.fixMin) {
                    L[0] = E(Math.floor(L[0] / K) * K)
                }
                if (!J.fixMax) {
                    L[1] = E(Math.ceil(L[1] / K) * K)
                }
            }
        });
        A.create = function() {
            return new A()
        };
        H.exports = A
    }, function(C, F, A) {
        var G = A(7);
        var E = G.round;
        var D = {};
        D.intervalScaleNiceTicks = function(K, J, H) {
            var I = {};
            var M = K[1] - K[0];
            var N = I.interval = G.nice(M / J, true);
            if (H != null && N < H) {
                N = I.interval = H
            }
            var O = I.intervalPrecision = D.getIntervalPrecision(N);
            var L = I.niceTickExtent = [E(Math.ceil(K[0] / N) * N, O), E(Math.floor(K[1] / N) * N, O)];
            D.fixExtent(L, K);
            return I
        };
        D.getIntervalPrecision = function(H) {
            return G.getPrecisionSafe(H) + 2
        };

        function B(J, I, H) {
            J[I] = Math.max(Math.min(J[I], H[1]), H[0])
        }

        D.fixExtent = function(I, H) {
            !isFinite(I[0]) && (I[0] = H[0]);
            !isFinite(I[1]) && (I[1] = H[1]);
            B(I, 0, H);
            B(I, 1, H);
            if (I[0] > I[1]) {
                I[0] = I[1]
            }
        };
        D.intervalScaleGetTicks = function(I, K, M, N) {
            var H = [];
            if (!I) {
                return H
            }
            var J = 10000;
            if (K[0] < M[0]) {
                H.push(K[0])
            }
            var L = M[0];
            while (L <= M[1]) {
                H.push(L);
                L = E(L + I, N);
                if (L === H[H.length - 1]) {
                    break
                }
                if (H.length > J) {
                    return []
                }
            }
            if (K[1] > (H.length ? H[H.length - 1] : M[1])) {
                H.push(K[1])
            }
            return H
        };
        C.exports = D
    }, function(N, G, O) {
        var F = O(4);
        var M = O(7);
        var D = O(6);
        var K = O(105);
        var I = O(104);
        var Q = I.prototype;
        var J = Math.ceil;
        var C = Math.floor;
        var R = 1000;
        var A = R * 60;
        var H = A * 60;
        var B = H * 24;
        var P = function(W, V, S, T) {
            while (S < T) {
                var U = S + T >>> 1;
                if (W[U][2] < V) {
                    S = U + 1
                } else {
                    T = U
                }
            }
            return S
        };
        var E = I.extend({
            type: "time", getLabel: function(T) {
                var S = this._stepLvl;
                var U = new Date(T);
                return D.formatTime(S[0], U, this.getSetting("useUTC"))
            }, niceExtent: function(T) {
                var V = this._extent;
                if (V[0] === V[1]) {
                    V[0] -= B;
                    V[1] += B
                }
                if (V[1] === -Infinity && V[0] === Infinity) {
                    var S = new Date();
                    V[1] = new Date(S.getFullYear(), S.getMonth(), S.getDate());
                    V[0] = V[1] - B
                }
                this.niceTicks(T.splitNumber);
                var U = this._interval;
                if (!T.fixMin) {
                    V[0] = M.round(C(V[0] / U) * U)
                }
                if (!T.fixMax) {
                    V[1] = M.round(J(V[1] / U) * U)
                }
            }, niceTicks: function(c) {
                var T = this.getSetting("useUTC") ? 0 : M.getTimezoneOffset() * 60 * 1000;
                c = c || 10;
                var X = this._extent;
                var W = X[1] - X[0];
                var Y = W / c;
                var U = L.length;
                var V = P(L, Y, 0, U);
                var a = L[Math.min(V, U - 1)];
                var Z = a[2];
                if (a[0] === "year") {
                    var d = W / Z;
                    var b = M.nice(d / c, true);
                    Z *= b
                }
                var S = [Math.round(J((X[0] - T) / Z) * Z + T), Math.round(C((X[1] - T) / Z) * Z + T)];
                K.fixExtent(S, X);
                this._stepLvl = a;
                this._interval = Z;
                this._niceExtent = S
            }, parse: function(S) {
                return +M.parseDate(S)
            }
        });
        F.each(["contain", "normalize"], function(S) {
            E.prototype[S] = function(T) {
                return Q[S].call(this, this.parse(T))
            }
        });
        var L = [["hh:mm:ss", 1, R], ["hh:mm:ss", 5, R * 5], ["hh:mm:ss", 10, R * 10], ["hh:mm:ss", 15, R * 15], ["hh:mm:ss", 30, R * 30], ["hh:mm\nMM-dd", 1, A], ["hh:mm\nMM-dd", 5, A * 5], ["hh:mm\nMM-dd", 10, A * 10], ["hh:mm\nMM-dd", 15, A * 15], ["hh:mm\nMM-dd", 30, A * 30], ["hh:mm\nMM-dd", 1, H], ["hh:mm\nMM-dd", 2, H * 2], ["hh:mm\nMM-dd", 6, H * 6], ["hh:mm\nMM-dd", 12, H * 12], ["MM-dd\nyyyy", 1, B], ["week", 7, B * 7], ["month", 1, B * 31], ["quarter", 3, B * 380 / 4], ["half-year", 6, B * 380 / 2], ["year", 1, B * 380]];
        E.create = function(S) {
            return new E({useUTC: S.ecModel.get("useUTC")})
        };
        N.exports = E
    }, function(M, E, O) {
        var D = O(4);
        var P = O(103);
        var L = O(7);
        var G = O(104);
        var J = P.prototype;
        var Q = G.prototype;
        var I = L.getPrecisionSafe;
        var C = L.round;
        var A = Math.floor;
        var H = Math.ceil;
        var N = Math.pow;
        var B = Math.log;
        var K = P.extend({
            type: "log", base: 10, $constructor: function() {
                P.apply(this, arguments);
                this._originalScale = new G()
            }, getTicks: function() {
                var R = this._originalScale;
                var T = this._extent;
                var S = R.getExtent();
                return D.map(Q.getTicks.call(this), function(V) {
                    var U = L.round(N(this.base, V));
                    U = (V === T[0] && R.__fixMin) ? F(U, S[0]) : U;
                    U = (V === T[1] && R.__fixMax) ? F(U, S[1]) : U;
                    return U
                }, this)
            }, getLabel: Q.getLabel, scale: function(R) {
                R = J.scale.call(this, R);
                return N(this.base, R)
            }, setExtent: function(T, S) {
                var R = this.base;
                T = B(T) / B(R);
                S = B(S) / B(R);
                Q.setExtent.call(this, T, S)
            }, getExtent: function() {
                var U = this.base;
                var T = J.getExtent.call(this);
                T[0] = N(U, T[0]);
                T[1] = N(U, T[1]);
                var R = this._originalScale;
                var S = R.getExtent();
                R.__fixMin && (T[0] = F(T[0], S[0]));
                R.__fixMax && (T[1] = F(T[1], S[1]));
                return T
            }, unionExtent: function(R) {
                this._originalScale.unionExtent(R);
                var S = this.base;
                R[0] = B(R[0]) / B(S);
                R[1] = B(R[1]) / B(S);
                J.unionExtent.call(this, R)
            }, unionExtentFromData: function(S, R) {
                this.unionExtent(S.getDataExtent(R, true, function(T) {
                    return T > 0
                }))
            }, niceTicks: function(R) {
                R = R || 10;
                var U = this._extent;
                var S = U[1] - U[0];
                if (S === Infinity || S <= 0) {
                    return
                }
                var T = L.quantity(S);
                var W = R / S * T;
                if (W <= 0.5) {
                    T *= 10
                }
                while (!isNaN(T) && Math.abs(T) < 1 && Math.abs(T) > 0) {
                    T *= 10
                }
                var V = [L.round(H(U[0] / T) * T), L.round(A(U[1] / T) * T)];
                this._interval = T;
                this._niceExtent = V
            }, niceExtent: function(S) {
                Q.niceExtent.call(this, S);
                var R = this._originalScale;
                R.__fixMin = S.fixMin;
                R.__fixMax = S.fixMax
            }
        });
        D.each(["contain", "normalize"], function(R) {
            K.prototype[R] = function(S) {
                S = B(S) / B(this.base);
                return J[R].call(this, S)
            }
        });
        K.create = function() {
            return new K()
        };

        function F(S, R) {
            return C(S, I(R))
        }

        M.exports = K
    }, function(G, I, C) {
        var B = C(109);
        var E = C(111);
        var D = C(101);
        var H = C(112);
        var F = C(12);
        var A = C(4);
        G.exports = {
            createList: function(J) {
                var K = J.get("data");
                return B(K, J, J.ecModel)
            }, completeDimensions: C(110), createSymbol: E.createSymbol, createScale: function(M, J) {
                var K = J;
                if (!(J instanceof F)) {
                    K = new F(J);
                    A.mixin(K, H)
                }
                var L = D.createScaleByModel(K);
                L.setExtent(M[0], M[1]);
                D.niceScaleExtent(L, K);
                return L
            }, mixinAxisModelCommonMethods: function(J) {
                A.mixin(J, H)
            }
        }
    }, function(L, F, M) {
        var I = M(98);
        var J = M(110);
        var E = M(4);
        var C = M(5);
        var B = M(76);
        var G = C.getDataItemValue;
        var K = C.converDataValue;

        function Q(S) {
            var R = 0;
            while (R < S.length && S[R] == null) {
                R++
            }
            return S[R]
        }

        function H(S) {
            var R = Q(S);
            return R != null && !E.isArray(G(R))
        }

        function N(U, e, S) {
            U = U || [];
            if (true) {
                if (!E.isArray(U)) {
                    throw new Error("Invalid data.")
                }
            }
            var b = e.get("coordinateSystem");
            var X = P[b];
            var a = B.get(b);
            var d = {encodeDef: e.get("encode"), dimsDef: e.get("dimensions")};
            var Y = X && X(U, e, S, d);
            var R = Y && Y.dimensions;
            if (!R) {
                R = (a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice())) || ["x", "y"];
                R = J(R, U, d)
            }
            var V = Y ? Y.categoryIndex : -1;
            var T = new I(R, e);
            var Z = A(Y, U);
            var c = {};
            var W = (V >= 0 && H(U)) ? function(h, i, f, g) {
                if (C.isDataItemOption(h)) {
                    T.hasItemOption = true
                }
                return g === V ? f : K(G(h), R[g])
            } : function(i, j, g, h) {
                var f = G(i);
                var k = K(f && f[h], R[h]);
                if (C.isDataItemOption(i)) {
                    T.hasItemOption = true
                }
                var l = Y && Y.categoryAxesModels;
                if (l && l[j]) {
                    if (typeof k === "string") {
                        c[j] = c[j] || l[j].getCategories();
                        k = E.indexOf(c[j], k);
                        if (k < 0 && !isNaN(k)) {
                            k = +k
                        }
                    }
                }
                return k
            };
            T.hasItemOption = false;
            T.initData(U, Z, W);
            return T
        }

        function O(R) {
            return R !== "category" && R !== "time"
        }

        function D(R) {
            return R === "category" ? "ordinal" : R === "time" ? "time" : "float"
        }

        var P = {
            cartesian2d: function(V, d, T, a) {
                var c = E.map(["xAxis", "yAxis"], function(e) {
                    return T.queryComponents({mainType: e, index: d.get(e + "Index"), id: d.get(e + "Id")})[0]
                });
                var W = c[0];
                var Y = c[1];
                if (true) {
                    if (!W) {
                        throw new Error('xAxis "' + E.retrieve(d.get("xAxisIndex"), d.get("xAxisId"), 0) + '" not found')
                    }
                    if (!Y) {
                        throw new Error('yAxis "' + E.retrieve(d.get("xAxisIndex"), d.get("yAxisId"), 0) + '" not found')
                    }
                }
                var X = W.get("type");
                var S = Y.get("type");
                var R = [{name: "x", type: D(X), stackable: O(X)}, {name: "y", type: D(S), stackable: O(S)}];
                var b = X === "category";
                var U = S === "category";
                R = J(R, V, a);
                var Z = {};
                if (b) {
                    Z.x = W
                }
                if (U) {
                    Z.y = Y
                }
                return {dimensions: R, categoryIndex: b ? 0 : (U ? 1 : -1), categoryAxesModels: Z}
            }, singleAxis: function(T, Z, S, Y) {
                var X = S.queryComponents({mainType: "singleAxis", index: Z.get("singleAxisIndex"), id: Z.get("singleAxisId")})[0];
                if (true) {
                    if (!X) {
                        throw new Error("singleAxis should be specified.")
                    }
                }
                var U = X.get("type");
                var W = U === "category";
                var R = [{name: "single", type: D(U), stackable: O(U)}];
                R = J(R, T, Y);
                var V = {};
                if (W) {
                    V.single = X
                }
                return {dimensions: R, categoryIndex: W ? 0 : -1, categoryAxesModels: V}
            }, polar: function(V, d, T, a) {
                var c = T.queryComponents({mainType: "polar", index: d.get("polarIndex"), id: d.get("polarId")})[0];
                var b = c.findAxisModel("angleAxis");
                var X = c.findAxisModel("radiusAxis");
                if (true) {
                    if (!b) {
                        throw new Error("angleAxis option not found")
                    }
                    if (!X) {
                        throw new Error("radiusAxis option not found")
                    }
                }
                var S = X.get("type");
                var Y = b.get("type");
                var R = [{name: "radius", type: D(S), stackable: O(S)}, {name: "angle", type: D(Y), stackable: O(Y)}];
                var U = Y === "category";
                var W = S === "category";
                R = J(R, V, a);
                var Z = {};
                if (W) {
                    Z.radius = X
                }
                if (U) {
                    Z.angle = b
                }
                return {dimensions: R, categoryIndex: U ? 1 : (W ? 0 : -1), categoryAxesModels: Z}
            }, geo: function(U, R, S, T) {
                return {dimensions: J([{name: "lng"}, {name: "lat"}], U, T)}
            }
        };

        function A(V, S) {
            var U = [];
            var Y = V && V.dimensions[V.categoryIndex];
            var X;
            if (Y) {
                X = V.categoryAxesModels[Y.name]
            }
            if (X) {
                var R = X.getCategories();
                if (R) {
                    var T = S.length;
                    if (E.isArray(S[0]) && S[0].length > 1) {
                        U = [];
                        for (var W = 0; W < T; W++) {
                            U[W] = R[S[W][V.categoryIndex || 0]]
                        }
                    } else {
                        U = R.slice(0)
                    }
                }
            }
            return U
        }

        L.exports = N
    }, function(K, M, E) {
        var D = E(4);
        var B = E(5);
        var A = D.each;
        var G = D.isString;
        var L = D.defaults;
        var H = B.normalizeToArray;
        var J = {tooltip: 1, label: 1, itemName: 1};

        function F(W, N, S) {
            N = N || [];
            S = S || {};
            W = (W || []).slice();
            var f = (S.dimsDef || []).slice();
            var e = D.createHashMap(S.encodeDef);
            var Z = D.createHashMap();
            var a = D.createHashMap();
            var O = [];
            var Y = S.dimCount;
            if (Y == null) {
                var b = I(N[0]);
                Y = Math.max(D.isArray(b) && b.length || 1, W.length, f.length);
                A(W, function(h) {
                    var i = h.dimsDef;
                    i && (Y = Math.max(Y, i.length))
                })
            }
            for (var P = 0; P < Y; P++) {
                var d = G(f[P]) ? {name: f[P]} : (f[P] || {});
                var V = d.name;
                var X = O[P] = {otherDims: {}};
                if (V != null && Z.get(V) == null) {
                    X.name = X.tooltipName = V;
                    Z.set(V, P)
                }
                d.type != null && (X.type = d.type)
            }
            e.each(function(h, i) {
                h = e.set(i, H(h).slice());
                A(h, function(j, k) {
                    G(j) && (j = Z.get(j));
                    if (j != null && j < Y) {
                        h[k] = j;
                        g(O[j], i, k)
                    }
                })
            });
            var R = 0;
            A(W, function(j, l) {
                var n;
                var j;
                var o;
                var m;
                if (G(j)) {
                    n = j;
                    j = {}
                } else {
                    n = j.name;
                    j = D.clone(j);
                    o = j.dimsDef;
                    m = j.otherDims;
                    j.name = j.coordDim = j.coordDimIndex = j.dimsDef = j.otherDims = null
                }
                var h = H(e.get(n));
                if (!h.length) {
                    for (var k = 0; k < (o && o.length || 1); k++) {
                        while (R < O.length && O[R].coordDim != null) {
                            R++
                        }
                        R < O.length && h.push(R++)
                    }
                }
                A(h, function(i, p) {
                    var q = O[i];
                    g(L(q, j), n, p);
                    if (q.name == null && o) {
                        q.name = q.tooltipName = o[p]
                    }
                    m && L(q.otherDims, m)
                })
            });
            var Q = S.extraPrefix || "value";
            for (var U = 0; U < Y; U++) {
                var X = O[U] = O[U] || {};
                var c = X.coordDim;
                c == null && (X.coordDim = T(Q, a, S.extraFromZero), X.coordDimIndex = 0, X.isExtraCoord = true);
                X.name == null && (X.name = T(X.coordDim, Z));
                X.type == null && C(N, U) && (X.type = "ordinal")
            }
            return O;

            function g(j, i, h) {
                if (J[i]) {
                    j.otherDims[i] = h
                } else {
                    j.coordDim = i;
                    j.coordDimIndex = h;
                    a.set(i, true)
                }
            }

            function T(k, j, l) {
                if (l || j.get(k) != null) {
                    var h = 0;
                    while (j.get(k + h) != null) {
                        h++
                    }
                    k += h
                }
                j.set(k, true);
                return k
            }
        }

        var C = F.guessOrdinal = function(R, O) {
            for (var N = 0, P = R.length; N < P; N++) {
                var Q = I(R[N]);
                if (!D.isArray(Q)) {
                    return false
                }
                var Q = Q[O];
                if (Q != null && isFinite(Q)) {
                    return false
                } else {
                    if (G(Q) && Q !== "-") {
                        return true
                    }
                }
            }
            return false
        };

        function I(N) {
            return D.isArray(N) ? N : D.isObject(N) ? N.value : N
        }

        K.exports = F
    }, function(O, P, D) {
        var H = D(18);
        var K = D(9);
        var N = H.extendShape({
            type: "triangle", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function(V, Q) {
                var U = Q.cx;
                var T = Q.cy;
                var R = Q.width / 2;
                var S = Q.height / 2;
                V.moveTo(U, T - S);
                V.lineTo(U + R, T + S);
                V.lineTo(U - R, T + S);
                V.closePath()
            }
        });
        var E = H.extendShape({
            type: "diamond", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function(V, Q) {
                var U = Q.cx;
                var T = Q.cy;
                var R = Q.width / 2;
                var S = Q.height / 2;
                V.moveTo(U, T - S);
                V.lineTo(U + R, T);
                V.lineTo(U, T + S);
                V.lineTo(U - R, T);
                V.closePath()
            }
        });
        var C = H.extendShape({
            type: "pin", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function(Z, X) {
                var b = X.x;
                var c = X.y;
                var S = X.width / 5 * 3;
                var W = Math.max(S, X.height);
                var Q = S / 2;
                var Y = Q * Q / (W - Q);
                var U = c - W + Q + Y;
                var a = Math.asin(Y / Q);
                var T = Math.cos(a) * Q;
                var d = Math.sin(a);
                var R = Math.cos(a);
                Z.arc(b, U, Q, Math.PI - a, Math.PI * 2 + a);
                var V = Q * 0.6;
                var e = Q * 0.7;
                Z.bezierCurveTo(b + T - d * V, U + Y + R * V, b, c - e, b, c);
                Z.bezierCurveTo(b, c - e, b - T + d * V, U + Y + R * V, b - T, U + Y);
                Z.closePath()
            }
        });
        var B = H.extendShape({
            type: "arrow", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function(V, W) {
                var Q = W.height;
                var S = W.width;
                var T = W.x;
                var U = W.y;
                var R = S / 3 * 2;
                V.moveTo(T, U);
                V.lineTo(T + R, U + Q);
                V.lineTo(T, U + Q / 4 * 3);
                V.lineTo(T - R, U + Q);
                V.lineTo(T, U);
                V.closePath()
            }
        });
        var F = {line: H.Line, rect: H.Rect, roundRect: H.Rect, square: H.Rect, circle: H.Circle, diamond: E, pin: C, arrow: B, triangle: N};
        var J = {
            line: function(R, S, T, Q, U) {
                U.x1 = R;
                U.y1 = S + Q / 2;
                U.x2 = R + T;
                U.y2 = S + Q / 2
            }, rect: function(R, S, T, Q, U) {
                U.x = R;
                U.y = S;
                U.width = T;
                U.height = Q
            }, roundRect: function(R, S, T, Q, U) {
                U.x = R;
                U.y = S;
                U.width = T;
                U.height = Q;
                U.r = Math.min(T, Q) / 4
            }, square: function(S, T, U, Q, V) {
                var R = Math.min(U, Q);
                V.x = S;
                V.y = T;
                V.width = R;
                V.height = R
            }, circle: function(R, S, T, Q, U) {
                U.cx = R + T / 2;
                U.cy = S + Q / 2;
                U.r = Math.min(T, Q) / 2
            }, diamond: function(R, S, T, Q, U) {
                U.cx = R + T / 2;
                U.cy = S + Q / 2;
                U.width = T;
                U.height = Q
            }, pin: function(R, S, T, Q, U) {
                U.x = R + T / 2;
                U.y = S + Q / 2;
                U.width = T;
                U.height = Q
            }, arrow: function(R, S, T, Q, U) {
                U.x = R + T / 2;
                U.y = S + Q / 2;
                U.width = T;
                U.height = Q
            }, triangle: function(R, S, T, Q, U) {
                U.cx = R + T / 2;
                U.cy = S + Q / 2;
                U.width = T;
                U.height = Q
            }
        };
        var M = {};
        for (var A in F) {
            if (F.hasOwnProperty(A)) {
                M[A] = new F[A]()
            }
        }
        var G = H.extendShape({
            type: "symbol", shape: {symbolType: "", x: 0, y: 0, width: 0, height: 0}, beforeBrush: function() {
                var Q = this.style;
                var R = this.shape;
                if (R.symbolType === "pin" && Q.textPosition === "inside") {
                    Q.textPosition = ["50%", "40%"];
                    Q.textAlign = "center";
                    Q.textVerticalAlign = "middle"
                }
            }, buildPath: function(T, U, S) {
                var Q = U.symbolType;
                var R = M[Q];
                if (U.symbolType !== "none") {
                    if (!R) {
                        Q = "rect";
                        R = M[Q]
                    }
                    J[Q](U.x, U.y, U.width, U.height, R.shape);
                    R.buildPath(T, R.shape, S)
                }
            }
        });
        var I = function(R) {
            if (this.type !== "image") {
                var Q = this.style;
                var S = this.shape;
                if (S && S.symbolType === "line") {
                    Q.stroke = R
                } else {
                    if (this.__isEmptyBrush) {
                        Q.stroke = R;
                        Q.fill = "#fff"
                    } else {
                        Q.fill && (Q.fill = R);
                        Q.stroke && (Q.stroke = R)
                    }
                }
                this.dirty(false)
            }
        };
        var L = {
            createSymbol: function(V, W, X, R, T, S) {
                var U = V.indexOf("empty") === 0;
                if (U) {
                    V = V.substr(5, 1).toLowerCase() + V.substr(6)
                }
                var Q;
                if (V.indexOf("image://") === 0) {
                    Q = new H.Image({style: {image: V.slice(8), x: W, y: X, width: R, height: T}})
                } else {
                    if (V.indexOf("path://") === 0) {
                        Q = H.makePath(V.slice(7), {}, new K(W, X, R, T))
                    } else {
                        Q = new G({shape: {symbolType: V, x: W, y: X, width: R, height: T}})
                    }
                }
                Q.__isEmptyBrush = U;
                Q.setColor = I;
                Q.setColor(S);
                return Q
            }
        };
        O.exports = L
    }, function(D, F, C) {
        var B = C(4);
        var E = C(101);

        function A(G) {
            if (B.isObject(G) && G.value != null) {
                return G.value
            } else {
                return G + ""
            }
        }

        D.exports = {
            getFormattedLabels: function() {
                return E.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
            }, getCategories: function() {
                return this.get("type") === "category" && B.map(this.get("data"), A)
            }, getMin: function(I) {
                var H = this.option;
                var G = (!I && H.rangeStart != null) ? H.rangeStart : H.min;
                if (this.axis && G != null && G !== "dataMin" && !B.eqNaN(G)) {
                    G = this.axis.scale.parse(G)
                }
                return G
            }, getMax: function(H) {
                var G = this.option;
                var I = (!H && G.rangeEnd != null) ? G.rangeEnd : G.max;
                if (this.axis && I != null && I !== "dataMax" && !B.eqNaN(I)) {
                    I = this.axis.scale.parse(I)
                }
                return I
            }, getNeedCrossZero: function() {
                var G = this.option;
                return (G.rangeStart != null || G.rangeEnd != null) ? false : !G.scale
            }, getCoordSysModel: B.noop, setRange: function(H, G) {
                this.option.rangeStart = H;
                this.option.rangeEnd = G
            }, resetRange: function() {
                this.option.rangeStart = this.option.rangeEnd = null
            }
        }
    }, function(D, F, C) {
        var A = C(4);
        var E = C(1);
        var B = E.PRIORITY;
        C(114);
        C(115);
        E.registerVisual(A.curry(C(121), "line", "circle", "line"));
        E.registerLayout(A.curry(C(122), "line"));
        E.registerProcessor(B.PROCESSOR.STATISTIC, A.curry(C(123), "line"));
        C(124)
    }, function(C, E, A) {
        var B = A(109);
        var D = A(78);
        C.exports = D.extend({
            type: "series.line",
            dependencies: ["grid", "polar"],
            getInitialData: function(F, G) {
                if (true) {
                    var H = F.coordinateSystem;
                    if (H !== "polar" && H !== "cartesian2d") {
                        throw new Error("Line not support coordinateSystem besides cartesian and polar")
                    }
                }
                return B(F.data, this, G)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: true,
                hoverAnimation: true,
                clipOverflow: true,
                label: {normal: {position: "top"}},
                lineStyle: {normal: {width: 2, type: "solid"}},
                step: false,
                smooth: false,
                smoothMonotone: null,
                symbol: "emptyCircle",
                symbolSize: 4,
                symbolRotate: null,
                showSymbol: true,
                showAllSymbol: false,
                connectNulls: false,
                sampling: "none",
                animationEasing: "linear",
                progressive: 0,
                hoverLayerThreshold: Infinity
            }
        })
    }, function(O, G, R) {
        var U = R(4);
        var B = R(116);
        var A = R(117);
        var S = R(119);
        var K = R(18);
        var C = R(5);
        var J = R(120);
        var H = R(80);

        function D(X, W) {
            if (X.length !== W.length) {
                return
            }
            for (var V = 0; V < X.length; V++) {
                var Y = X[V];
                var Z = W[V];
                if (Y[0] !== Z[0] || Y[1] !== Z[1]) {
                    return
                }
            }
            return true
        }

        function I(V) {
            return typeof(V) === "number" ? V : (V ? 0.3 : 0)
        }

        function P(Y) {
            var X = Y.getGlobalExtent();
            if (Y.onBand) {
                var W = Y.getBandWidth() / 2 - 1;
                var V = X[1] > X[0] ? 1 : -1;
                X[0] += V * W;
                X[1] -= V * W
            }
            return X
        }

        function F(V) {
            return V >= 0 ? 1 : -1
        }

        function E(Y, b) {
            var a = Y.getBaseAxis();
            var W = Y.getOtherAxis(a);
            var X = a.onZero ? 0 : W.scale.getExtent()[0];
            var V = W.dim;
            var Z = V === "x" || V === "radius" ? 1 : 0;
            return b.mapArray([V], function(f, e) {
                var c;
                var d = b.stackedOn;
                while (d && F(d.get(V, e)) === F(f)) {
                    c = d;
                    break
                }
                var g = [];
                g[Z] = b.get(a.dim, e);
                g[1 - Z] = c ? c.get(V, e, true) : X;
                return Y.dataToPoint(g)
            }, true)
        }

        function N(a, Z, h) {
            var V = P(a.getAxis("x"));
            var X = P(a.getAxis("y"));
            var Y = a.getBaseAxis().isHorizontal();
            var e = Math.min(V[0], V[1]);
            var f = Math.min(X[0], X[1]);
            var d = Math.max(V[0], V[1]) - e;
            var c = Math.max(X[0], X[1]) - f;
            var b = h.get("lineStyle.normal.width") || 2;
            var W = h.get("clipOverflow") ? b / 2 : Math.max(d, c);
            if (Y) {
                f -= W;
                c += W * 2
            } else {
                e -= W;
                d += W * 2
            }
            var g = new K.Rect({shape: {x: e, y: f, width: d, height: c}});
            if (Z) {
                g.shape[Y ? "width" : "height"] = 0;
                K.initProps(g, {shape: {width: d, height: c}}, h)
            }
            return g
        }

        function Q(V, a, d) {
            var W = V.getAngleAxis();
            var Y = V.getRadiusAxis();
            var Z = Y.getExtent();
            var b = W.getExtent();
            var X = Math.PI / 180;
            var c = new K.Sector({shape: {cx: V.cx, cy: V.cy, r0: Z[0], r: Z[1], startAngle: -b[0] * X, endAngle: -b[1] * X, clockwise: W.inverse}});
            if (a) {
                c.shape.endAngle = -b[0] * X;
                K.initProps(c, {shape: {endAngle: -b[1] * X}}, d)
            }
            return c
        }

        function M(X, W, V) {
            return X.type === "polar" ? Q(X, W, V) : N(X, W, V)
        }

        function T(Y, X, d) {
            var e = X.getBaseAxis();
            var a = e.dim === "x" || e.dim === "radius" ? 0 : 1;
            var V = [];
            for (var b = 0; b < Y.length - 1; b++) {
                var c = Y[b + 1];
                var W = Y[b];
                V.push(W);
                var g = [];
                switch (d) {
                    case"end":
                        g[a] = c[a];
                        g[1 - a] = W[1 - a];
                        V.push(g);
                        break;
                    case"middle":
                        var Z = (W[a] + c[a]) / 2;
                        var f = [];
                        g[a] = f[a] = Z;
                        g[1 - a] = W[1 - a];
                        f[1 - a] = c[1 - a];
                        V.push(g);
                        V.push(f);
                        break;
                    default:
                        g[a] = W[a];
                        g[1 - a] = c[1 - a];
                        V.push(g)
                }
            }
            Y[b] && V.push(Y[b]);
            return V
        }

        function L(a, Y) {
            var X = a.getVisual("visualMeta");
            if (!X || !X.length || !a.count()) {
                return
            }
            var k;
            for (var e = X.length - 1; e >= 0; e--) {
                if (X[e].dimension < 2) {
                    k = X[e];
                    break
                }
            }
            if (!k || Y.type !== "cartesian2d") {
                if (true) {
                    console.warn("Visual map on line style only support x or y dimension.")
                }
                return
            }
            var c = k.dimension;
            var b = a.dimensions[c];
            var Z = Y.getAxis(b);
            var j = U.map(k.stops, function(i) {
                return {coord: Z.toGlobalCoord(Z.dataToCoord(i.value)), color: i.color}
            });
            var h = j.length;
            var V = k.outerColors.slice();
            if (h && j[0].coord > j[h - 1].coord) {
                j.reverse();
                V.reverse()
            }
            var W = 10;
            var d = j[0].coord - W;
            var g = j[h - 1].coord + W;
            var l = g - d;
            if (l < 0.001) {
                return "transparent"
            }
            U.each(j, function(i) {
                i.offset = (i.coord - d) / l
            });
            j.push({offset: h ? j[h - 1].offset : 0.5, color: V[1] || "transparent"});
            j.unshift({offset: h ? j[0].offset : 0.5, color: V[0] || "transparent"});
            var f = new K.LinearGradient(0, 0, 0, 0, j, true);
            f[b] = d;
            f[b + "2"] = g;
            return f
        }

        O.exports = H.extend({
            type: "line", init: function() {
                var V = new K.Group();
                var W = new B();
                this.group.add(W.group);
                this._symbolDraw = W;
                this._lineGroup = V
            }, render: function(d, X, i) {
                var l = d.coordinateSystem;
                var n = this.group;
                var r = d.getData();
                var q = d.getModel("lineStyle.normal");
                var p = d.getModel("areaStyle.normal");
                var j = r.mapArray(r.getItemLayout, true);
                var Z = l.type === "polar";
                var a = this._coordSys;
                var Y = this._symbolDraw;
                var k = this._polyline;
                var b = this._polygon;
                var g = this._lineGroup;
                var e = d.get("animation");
                var u = !p.isEmpty();
                var c = E(l, r);
                var v = d.get("showSymbol");
                var f = v && !Z && !d.get("showAllSymbol") && this._getSymbolIgnoreFunc(r, l);
                var W = this._data;
                W && W.eachItemGraphicEl(function(w, x) {
                    if (w.__temp) {
                        n.remove(w);
                        W.setItemGraphicEl(x, null)
                    }
                });
                if (!v) {
                    Y.remove()
                }
                n.add(g);
                var V = !Z && d.get("step");
                if (!(k && a.type === l.type && V === this._step)) {
                    v && Y.updateData(r, f);
                    if (V) {
                        j = T(j, l, V);
                        c = T(c, l, V)
                    }
                    k = this._newPolyline(j, l, e);
                    if (u) {
                        b = this._newPolygon(j, c, l, e)
                    }
                    g.setClipPath(M(l, true, d))
                } else {
                    if (u && !b) {
                        b = this._newPolygon(j, c, l, e)
                    } else {
                        if (b && !u) {
                            g.remove(b);
                            b = this._polygon = null
                        }
                    }
                    g.setClipPath(M(l, false, d));
                    v && Y.updateData(r, f);
                    r.eachItemGraphicEl(function(w) {
                        w.stopAnimation(true)
                    });
                    if (!D(this._stackedOnPoints, c) || !D(this._points, j)) {
                        if (e) {
                            this._updateAnimation(r, c, l, i, V)
                        } else {
                            if (V) {
                                j = T(j, l, V);
                                c = T(c, l, V)
                            }
                            k.setShape({points: j});
                            b && b.setShape({points: j, stackedOnPoints: c})
                        }
                    }
                }
                var o = L(r, l) || r.getVisual("color");
                k.useStyle(U.defaults(q.getLineStyle(), {fill: "none", stroke: o, lineJoin: "bevel"}));
                var t = d.get("smooth");
                t = I(d.get("smooth"));
                k.setShape({smooth: t, smoothMonotone: d.get("smoothMonotone"), connectNulls: d.get("connectNulls")});
                if (b) {
                    var m = r.stackedOn;
                    var s = 0;
                    b.useStyle(U.defaults(p.getAreaStyle(), {fill: o, opacity: 0.7, lineJoin: "bevel"}));
                    if (m) {
                        var h = m.hostModel;
                        s = I(h.get("smooth"))
                    }
                    b.setShape({smooth: t, stackedOnSmooth: s, smoothMonotone: d.get("smoothMonotone"), connectNulls: d.get("connectNulls")})
                }
                this._data = r;
                this._coordSys = l;
                this._stackedOnPoints = c;
                this._points = j;
                this._step = V
            }, dispose: function() {
            }, highlight: function(c, W, b, X) {
                var Y = c.getData();
                var a = C.queryDataIndex(Y, X);
                if (!(a instanceof Array) && a != null && a >= 0) {
                    var Z = Y.getItemGraphicEl(a);
                    if (!Z) {
                        var V = Y.getItemLayout(a);
                        if (!V) {
                            return
                        }
                        Z = new A(Y, a);
                        Z.position = V;
                        Z.setZ(c.get("zlevel"), c.get("z"));
                        Z.ignore = isNaN(V[0]) || isNaN(V[1]);
                        Z.__temp = true;
                        Y.setItemGraphicEl(a, Z);
                        Z.stopSymbolAnimation(true);
                        this.group.add(Z)
                    }
                    Z.highlight()
                } else {
                    H.prototype.highlight.call(this, c, W, b, X)
                }
            }, downplay: function(V, X, a, Z) {
                var b = V.getData();
                var Y = C.queryDataIndex(b, Z);
                if (Y != null && Y >= 0) {
                    var W = b.getItemGraphicEl(Y);
                    if (W) {
                        if (W.__temp) {
                            b.setItemGraphicEl(Y, null);
                            this.group.remove(W)
                        } else {
                            W.downplay()
                        }
                    }
                } else {
                    H.prototype.downplay.call(this, V, X, a, Z)
                }
            }, _newPolyline: function(V) {
                var W = this._polyline;
                if (W) {
                    this._lineGroup.remove(W)
                }
                W = new J.Polyline({shape: {points: V}, silent: true, z2: 10});
                this._lineGroup.add(W);
                this._polyline = W;
                return W
            }, _newPolygon: function(V, X) {
                var W = this._polygon;
                if (W) {
                    this._lineGroup.remove(W)
                }
                W = new J.Polygon({shape: {points: V, stackedOnPoints: X}, silent: true});
                this._lineGroup.add(W);
                this._polygon = W;
                return W
            }, _getSymbolIgnoreFunc: function(X, W) {
                var V = W.getAxesByScale("ordinal")[0];
                if (V && V.isLabelIgnored) {
                    return U.bind(V.isLabelIgnored, V)
                }
            }, _updateAnimation: function(l, Z, k, e, V) {
                var g = this._polyline;
                var a = this._polygon;
                var b = l.hostModel;
                var X = S(this._data, l, this._stackedOnPoints, Z, this._coordSys, k);
                var c = X.current;
                var m = X.stackedOnCurrent;
                var j = X.next;
                var d = X.stackedOnNext;
                if (V) {
                    c = T(X.current, k, V);
                    m = T(X.stackedOnCurrent, k, V);
                    j = T(X.next, k, V);
                    d = T(X.stackedOnNext, k, V)
                }
                g.shape.__points = X.current;
                g.shape.points = c;
                K.updateProps(g, {shape: {points: j}}, b);
                if (a) {
                    a.setShape({points: c, stackedOnPoints: m});
                    K.updateProps(a, {shape: {points: j, stackedOnPoints: d}}, b)
                }
                var h = [];
                var W = X.status;
                for (var Y = 0; Y < W.length; Y++) {
                    var f = W[Y].cmd;
                    if (f === "=") {
                        var n = l.getItemGraphicEl(W[Y].idx1);
                        if (n) {
                            h.push({el: n, ptIdx: Y})
                        }
                    }
                }
                if (g.animators && g.animators.length) {
                    g.animators[0].during(function() {
                        for (var p = 0; p < h.length; p++) {
                            var o = h[p].el;
                            o.attr("position", g.shape.__points[h[p].ptIdx])
                        }
                    })
                }
            }, remove: function(W) {
                var V = this.group;
                var X = this._data;
                this._lineGroup.removeAll();
                this._symbolDraw.remove(true);
                X && X.eachItemGraphicEl(function(Y, Z) {
                    if (Y.__temp) {
                        V.remove(Y);
                        X.setItemGraphicEl(Z, null)
                    }
                });
                this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
            }
        })
    }, function(G, H, B) {
        var E = B(18);
        var D = B(117);

        function C(I) {
            this.group = new E.Group();
            this._symbolCtor = I || D
        }

        var A = C.prototype;

        function F(L, K, J) {
            var I = L.getItemLayout(K);
            return I && !isNaN(I[0]) && !isNaN(I[1]) && !(J && J(K)) && L.getItemVisual(K, "symbol") !== "none"
        }

        A.updateData = function(O, K) {
            var I = this.group;
            var J = O.hostModel;
            var M = this._data;
            var L = this._symbolCtor;
            var N = {
                itemStyle: J.getModel("itemStyle.normal").getItemStyle(["color"]),
                hoverItemStyle: J.getModel("itemStyle.emphasis").getItemStyle(),
                symbolRotate: J.get("symbolRotate"),
                symbolOffset: J.get("symbolOffset"),
                hoverAnimation: J.get("hoverAnimation"),
                labelModel: J.getModel("label.normal"),
                hoverLabelModel: J.getModel("label.emphasis"),
                cursorStyle: J.get("cursor")
            };
            O.diff(M).add(function(Q) {
                var R = O.getItemLayout(Q);
                if (F(O, Q, K)) {
                    var P = new L(O, Q, N);
                    P.attr("position", R);
                    O.setItemGraphicEl(Q, P);
                    I.add(P)
                }
            }).update(function(Q, S) {
                var R = M.getItemGraphicEl(S);
                var P = O.getItemLayout(Q);
                if (!F(O, Q, K)) {
                    I.remove(R);
                    return
                }
                if (!R) {
                    R = new L(O, Q);
                    R.attr("position", P)
                } else {
                    R.updateData(O, Q, N);
                    E.updateProps(R, {position: P}, J)
                }
                I.add(R);
                O.setItemGraphicEl(Q, R)
            }).remove(function(Q) {
                var P = M.getItemGraphicEl(Q);
                P && P.fadeOut(function() {
                    I.remove(P)
                })
            }).execute();
            this._data = O
        };
        A.updateLayout = function() {
            var I = this._data;
            if (I) {
                I.eachItemGraphicEl(function(J, L) {
                    var K = I.getItemLayout(L);
                    J.attr("position", K)
                })
            }
        };
        A.remove = function(J) {
            var I = this.group;
            var K = this._data;
            if (K) {
                if (J) {
                    K.eachItemGraphicEl(function(L) {
                        L.fadeOut(function() {
                            I.remove(L)
                        })
                    })
                } else {
                    I.removeAll()
                }
            }
        };
        G.exports = C
    }, function(M, E, O) {
        var D = O(4);
        var H = O(111);
        var G = O(18);
        var K = O(7);
        var L = O(118);

        function N(T, R) {
            var S = T.getItemVisual(R, "symbolSize");
            return S instanceof Array ? S.slice() : [+S, +S]
        }

        function B(R) {
            return [R[0] / 2, R[1] / 2]
        }

        function A(T, R, S) {
            G.Group.call(this);
            this.updateData(T, R, S)
        }

        var F = A.prototype;

        function J(R, S) {
            this.parent.drift(R, S)
        }

        F._createSymbol = function(R, X, U, V) {
            this.removeAll();
            var T = X.hostModel;
            var W = X.getItemVisual(U, "color");
            var S = H.createSymbol(R, -1, -1, 2, 2, W);
            S.attr({z2: 100, culling: true, scale: [0, 0]});
            S.drift = J;
            G.initProps(S, {scale: B(V)}, T, U);
            this._symbolType = R;
            this.add(S)
        };
        F.stopSymbolAnimation = function(R) {
            this.childAt(0).stopAnimation(R)
        };
        F.getSymbolPath = function() {
            return this.childAt(0)
        };
        F.getScale = function() {
            return this.childAt(0).scale
        };
        F.highlight = function() {
            this.childAt(0).trigger("emphasis")
        };
        F.downplay = function() {
            this.childAt(0).trigger("normal")
        };
        F.setZ = function(T, S) {
            var R = this.childAt(0);
            R.zlevel = T;
            R.z = S
        };
        F.setDraggable = function(R) {
            var S = this.childAt(0);
            S.draggable = R;
            S.cursor = R ? "move" : "pointer"
        };
        F.updateData = function(X, U, W) {
            this.silent = false;
            var R = X.getItemVisual(U, "symbol") || "circle";
            var T = X.hostModel;
            var V = N(X, U);
            if (R !== this._symbolType) {
                this._createSymbol(R, X, U, V)
            } else {
                var S = this.childAt(0);
                S.silent = false;
                G.updateProps(S, {scale: B(V)}, T, U)
            }
            this._updateCommon(X, U, V, W);
            this._seriesModel = T
        };
        var C = ["itemStyle", "normal"];
        var Q = ["itemStyle", "emphasis"];
        var I = ["label", "normal"];
        var P = ["label", "emphasis"];
        F._updateCommon = function(k, m, i, e) {
            var a = this.childAt(0);
            var Y = k.hostModel;
            var U = k.getItemVisual(m, "color");
            if (a.type !== "image") {
                a.useStyle({strokeNoScale: true})
            }
            e = e || null;
            var g = e && e.itemStyle;
            var b = e && e.hoverItemStyle;
            var h = e && e.symbolRotate;
            var Z = e && e.symbolOffset;
            var S = e && e.labelModel;
            var T = e && e.hoverLabelModel;
            var R = e && e.hoverAnimation;
            var j = e && e.cursorStyle;
            if (!e || k.hasItemOption) {
                var l = k.getItemModel(m);
                g = l.getModel(C).getItemStyle(["color"]);
                b = l.getModel(Q).getItemStyle();
                h = l.getShallow("symbolRotate");
                Z = l.getShallow("symbolOffset");
                S = l.getModel(I);
                T = l.getModel(P);
                R = l.getShallow("hoverAnimation");
                j = l.getShallow("cursor")
            } else {
                b = D.extend({}, b)
            }
            var d = a.style;
            a.attr("rotation", (h || 0) * Math.PI / 180 || 0);
            if (Z) {
                a.attr("position", [K.parsePercent(Z[0], i[0]), K.parsePercent(Z[1], i[1])])
            }
            j && a.attr("cursor", j);
            a.setColor(U);
            a.setStyle(g);
            var V = k.getItemVisual(m, "opacity");
            if (V != null) {
                d.opacity = V
            }
            var c = L.findLabelValueDim(k);
            L.setTextToStyle(k, m, c, d, Y, S, U);
            L.setTextToStyle(k, m, c, b, Y, T, U);
            a.off("mouseover").off("mouseout").off("emphasis").off("normal");
            a.hoverStyle = b;
            G.setHoverStyle(a);
            var f = B(i);
            if (R && Y.isAnimationEnabled()) {
                var X = function() {
                    var n = f[1] / f[0];
                    this.animateTo({scale: [Math.max(f[0] * 1.1, f[0] + 3), Math.max(f[1] * 1.1, f[1] + 3 * n)]}, 400, "elasticOut")
                };
                var W = function() {
                    this.animateTo({scale: f}, 400, "elasticOut")
                };
                a.on("mouseover", X).on("mouseout", W).on("emphasis", X).on("normal", W)
            }
        };
        F.fadeOut = function(R) {
            var S = this.childAt(0);
            this.silent = S.silent = true;
            S.style.text = "";
            G.updateProps(S, {scale: [0, 0]}, this._seriesModel, this.dataIndex, R)
        };
        D.inherits(A, G.Group);
        M.exports = A
    }, function(E, G, C) {
        var A = C(18);
        var B = C(4);
        var D = C(5);
        var F = {};
        F.findLabelValueDim = function(L) {
            var H;
            var K = D.otherDimToDataDim(L, "label");
            if (K.length) {
                H = K[0]
            } else {
                var J = L.dimensions.slice();
                var I;
                while (J.length && (H = J.pop(), I = L.getDimensionInfo(H).type, I === "ordinal" || I === "time")) {
                }
            }
            return H
        };
        F.setTextToStyle = function(N, I, H, J, K, L, M) {
            if (H != null && L.getShallow("show")) {
                A.setText(J, L, M);
                J.text = B.retrieve(K.getFormattedLabel(I, "normal"), N.get(H, I))
            } else {
                J.text = ""
            }
        };
        E.exports = F
    }, function(C, E) {
        function A(F) {
            return F >= 0 ? 1 : -1
        }

        function D(H, J, K) {
            var Q = H.getBaseAxis();
            var F = H.getOtherAxis(Q);
            var I = Q.onZero ? 0 : F.scale.getExtent()[0];
            var M = F.dim;
            var G = M === "x" || M === "radius" ? 1 : 0;
            var O;
            var L = J.stackedOn;
            var N = J.get(M, K);
            while (L && A(L.get(M, K)) === A(N)) {
                O = L;
                break
            }
            var P = [];
            P[G] = J.get(Q.dim, K);
            P[1 - G] = O ? O.get(M, K, true) : I;
            return H.dataToPoint(P)
        }

        function B(G, F) {
            var H = [];
            F.diff(G).add(function(I) {
                H.push({cmd: "+", idx: I})
            }).update(function(I, J) {
                H.push({cmd: "=", idx: J, idx1: I})
            }).remove(function(I) {
                H.push({cmd: "-", idx: I})
            }).execute();
            return H
        }

        C.exports = function(N, W, J, R, Z, Y) {
            var L = B(N, W);
            var P = [];
            var X = [];
            var H = [];
            var K = [];
            var a = [];
            var O = [];
            var d = [];
            var e = Y.dimensions;
            for (var M = 0; M < L.length; M++) {
                var G = L[M];
                var I = true;
                switch (G.cmd) {
                    case"=":
                        var F = N.getItemLayout(G.idx);
                        var V = W.getItemLayout(G.idx1);
                        if (isNaN(F[0]) || isNaN(F[1])) {
                            F = V.slice()
                        }
                        P.push(F);
                        X.push(V);
                        H.push(J[G.idx]);
                        K.push(R[G.idx1]);
                        d.push(W.getRawIndex(G.idx1));
                        break;
                    case"+":
                        var S = G.idx;
                        P.push(Z.dataToPoint([W.get(e[0], S, true), W.get(e[1], S, true)]));
                        X.push(W.getItemLayout(S).slice());
                        H.push(D(Z, W, S));
                        K.push(R[S]);
                        d.push(W.getRawIndex(S));
                        break;
                    case"-":
                        var S = G.idx;
                        var U = N.getRawIndex(S);
                        if (U !== S) {
                            P.push(N.getItemLayout(S));
                            X.push(Y.dataToPoint([N.get(e[0], S, true), N.get(e[1], S, true)]));
                            H.push(J[S]);
                            K.push(D(Y, N, S));
                            d.push(U)
                        } else {
                            I = false
                        }
                }
                if (I) {
                    a.push(G);
                    O.push(O.length)
                }
            }
            O.sort(function(h, g) {
                return d[h] - d[g]
            });
            var c = [];
            var b = [];
            var Q = [];
            var T = [];
            var f = [];
            for (var M = 0; M < O.length; M++) {
                var S = O[M];
                c[M] = P[S];
                b[M] = X[S];
                Q[M] = H[S];
                T[M] = K[S];
                f[M] = a[S]
            }
            return {current: c, next: b, stackedOnCurrent: Q, stackedOnNext: T, status: f}
        }
    }, function(N, O, F) {
        var G = F(20);
        var I = F(10);
        var C = I.min;
        var E = I.max;
        var H = I.scaleAndAdd;
        var K = I.copy;
        var D = [];
        var A = [];
        var M = [];

        function B(P) {
            return isNaN(P[0]) || isNaN(P[1])
        }

        function J(V, Z, j, b, U, T, a, f, d, e, h) {
            var c = 0;
            var i = j;
            for (var S = 0; S < b; S++) {
                var P = Z[i];
                if (i >= U || i < 0) {
                    break
                }
                if (B(P)) {
                    if (h) {
                        i += T;
                        continue
                    }
                    break
                }
                if (i === j) {
                    V[T > 0 ? "moveTo" : "lineTo"](P[0], P[1]);
                    K(A, P)
                } else {
                    if (d > 0) {
                        var l = i + T;
                        var W = Z[l];
                        if (h) {
                            while (W && B(Z[l])) {
                                l += T;
                                W = Z[l]
                            }
                        }
                        var Q = 0.5;
                        var g = Z[c];
                        var W = Z[l];
                        if (!W || B(W)) {
                            K(M, P)
                        } else {
                            if (B(W) && !h) {
                                W = P
                            }
                            I.sub(D, W, g);
                            var X;
                            var R;
                            if (e === "x" || e === "y") {
                                var Y = e === "x" ? 0 : 1;
                                X = Math.abs(P[Y] - g[Y]);
                                R = Math.abs(P[Y] - W[Y])
                            } else {
                                X = I.dist(P, g);
                                R = I.dist(P, W)
                            }
                            Q = R / (R + X);
                            H(M, P, D, -d * (1 - Q))
                        }
                        C(A, A, f);
                        E(A, A, a);
                        C(M, M, f);
                        E(M, M, a);
                        V.bezierCurveTo(A[0], A[1], M[0], M[1], P[0], P[1]);
                        H(A, P, D, d * Q)
                    } else {
                        V.lineTo(P[0], P[1])
                    }
                }
                c = i;
                i += T
            }
            return S
        }

        function L(S, U) {
            var Q = [Infinity, Infinity];
            var R = [-Infinity, -Infinity];
            if (U) {
                for (var P = 0; P < S.length; P++) {
                    var T = S[P];
                    if (T[0] < Q[0]) {
                        Q[0] = T[0]
                    }
                    if (T[1] < Q[1]) {
                        Q[1] = T[1]
                    }
                    if (T[0] > R[0]) {
                        R[0] = T[0]
                    }
                    if (T[1] > R[1]) {
                        R[1] = T[1]
                    }
                }
            }
            return {min: U ? Q : R, max: U ? R : Q}
        }

        N.exports = {
            Polyline: G.extend({
                type: "ec-polyline",
                shape: {points: [], smooth: 0, smoothConstraint: true, smoothMonotone: null, connectNulls: false},
                style: {fill: null, stroke: "#000"},
                buildPath: function(T, U) {
                    var R = U.points;
                    var P = 0;
                    var S = R.length;
                    var Q = L(R, U.smoothConstraint);
                    if (U.connectNulls) {
                        for (; S > 0; S--) {
                            if (!B(R[S - 1])) {
                                break
                            }
                        }
                        for (; P < S; P++) {
                            if (!B(R[P])) {
                                break
                            }
                        }
                    }
                    while (P < S) {
                        P += J(T, R, P, S, S, 1, Q.min, Q.max, U.smooth, U.smoothMonotone, U.connectNulls) + 1
                    }
                }
            }),
            Polygon: G.extend({
                type: "ec-polygon",
                shape: {
                    points: [],
                    stackedOnPoints: [],
                    smooth: 0,
                    stackedOnSmooth: 0,
                    smoothConstraint: true,
                    smoothMonotone: null,
                    connectNulls: false
                },
                buildPath: function(T, Q) {
                    var P = Q.points;
                    var V = Q.stackedOnPoints;
                    var U = 0;
                    var W = P.length;
                    var R = Q.smoothMonotone;
                    var X = L(P, Q.smoothConstraint);
                    var Y = L(V, Q.smoothConstraint);
                    if (Q.connectNulls) {
                        for (; W > 0; W--) {
                            if (!B(P[W - 1])) {
                                break
                            }
                        }
                        for (; U < W; U++) {
                            if (!B(P[U])) {
                                break
                            }
                        }
                    }
                    while (U < W) {
                        var S = J(T, P, U, W, W, 1, X.min, X.max, Q.smooth, R, Q.connectNulls);
                        J(T, V, U + S - 1, S, W, -1, Y.min, Y.max, Q.stackedOnSmooth, R, Q.connectNulls);
                        U += S + 1;
                        T.closePath()
                    }
                }
            })
        }
    }, function(A, B) {
        A.exports = function(F, C, E, D, G) {
            D.eachRawSeriesByType(F, function(H) {
                var K = H.getData();
                var I = H.get("symbol") || C;
                var J = H.get("symbolSize");
                K.setVisual({legendSymbol: E || I, symbol: I, symbolSize: J});
                if (!D.isSeriesFiltered(H)) {
                    if (typeof J === "function") {
                        K.each(function(M) {
                            var L = H.getRawValue(M);
                            var N = H.getDataParams(M);
                            K.setItemVisual(M, "symbolSize", J(L, N))
                        })
                    }
                    K.each(function(O) {
                        var L = K.getItemModel(O);
                        var M = L.getShallow("symbol", true);
                        var N = L.getShallow("symbolSize", true);
                        if (M != null) {
                            K.setItemVisual(O, "symbol", M)
                        }
                        if (N != null) {
                            K.setItemVisual(O, "symbolSize", N)
                        }
                    })
                }
            })
        }
    }, function(A, B) {
        A.exports = function(D, C) {
            C.eachSeriesByType(D, function(E) {
                var J = E.getData();
                var G = E.coordinateSystem;
                if (!G) {
                    return
                }
                var H = [];
                var I = G.dimensions;
                for (var F = 0; F < I.length; F++) {
                    H.push(E.coordDimToDataDim(G.dimensions[F])[0])
                }
                if (H.length === 1) {
                    J.each(H[0], function(K, L) {
                        J.setItemLayout(L, isNaN(K) ? [NaN, NaN] : G.dataToPoint(K))
                    })
                } else {
                    if (H.length === 2) {
                        J.each(H, function(L, M, K) {
                            J.setItemLayout(K, (isNaN(L) || isNaN(M)) ? [NaN, NaN] : G.dataToPoint([L, M]))
                        }, true)
                    }
                }
            })
        }
    }, function(C, D) {
        var B = {
            average: function(G) {
                var H = 0;
                var F = 0;
                for (var E = 0; E < G.length; E++) {
                    if (!isNaN(G[E])) {
                        H += G[E];
                        F++
                    }
                }
                return F === 0 ? NaN : H / F
            }, sum: function(F) {
                var G = 0;
                for (var E = 0; E < F.length; E++) {
                    G += F[E] || 0
                }
                return G
            }, max: function(F) {
                var G = -Infinity;
                for (var E = 0; E < F.length; E++) {
                    F[E] > G && (G = F[E])
                }
                return G
            }, min: function(G) {
                var E = Infinity;
                for (var F = 0; F < G.length; F++) {
                    G[F] < E && (E = G[F])
                }
                return E
            }, nearest: function(E) {
                return E[0]
            }
        };
        var A = function(F, E) {
            return Math.round(F.length / 2)
        };
        C.exports = function(F, E, G) {
            E.eachSeriesByType(F, function(Q) {
                var K = Q.getData();
                var I = Q.get("sampling");
                var J = Q.coordinateSystem;
                if (J.type === "cartesian2d" && I) {
                    var O = J.getBaseAxis();
                    var H = J.getOtherAxis(O);
                    var L = O.getExtent();
                    var M = L[1] - L[0];
                    var N = Math.round(K.count() / M);
                    if (N > 1) {
                        var P;
                        if (typeof I === "string") {
                            P = B[I]
                        } else {
                            if (typeof I === "function") {
                                P = I
                            }
                        }
                        if (P) {
                            K = K.downSample(H.dim, 1 / N, P, A);
                            Q.setData(K)
                        }
                    }
                }
            }, this)
        }
    }, function(D, F, C) {
        var A = C(18);
        var B = C(4);
        var E = C(1);
        C(125);
        C(133);
        E.extendComponentView({
            type: "grid", render: function(G, H) {
                this.group.removeAll();
                if (G.get("show")) {
                    this.group.add(new A.Rect({
                        shape: G.coordinateSystem.getRect(),
                        style: B.defaults({fill: G.get("backgroundColor")}, G.getItemStyle()),
                        silent: true,
                        z2: -1
                    }))
                }
            }
        });
        E.registerPreprocessor(function(G) {
            if (G.xAxis && G.yAxis && !G.grid) {
                G.grid = {}
            }
        })
    }, function(N, F, O) {
        var J = F;
        var H = O(71);
        var C = O(101);
        var E = O(4);
        var D = O(126);
        var K = O(128);
        var G = E.each;
        var L = C.ifAxisCrossZero;
        var B = C.niceScaleExtent;
        O(129);

        function I(W, U, V) {
            return W.getCoordSysModel() === U
        }

        function S(U) {
            var X = U.model;
            var c = X.getFormattedLabels();
            var a = X.getModel("axisLabel.textStyle");
            var V;
            var Y = 1;
            var b = c.length;
            if (b > 40) {
                Y = Math.ceil(b / 40)
            }
            for (var Z = 0; Z < b; Z += Y) {
                if (!U.isLabelIgnored(Z)) {
                    var W = a.getTextRect(c[Z]);
                    V ? V.union(W) : (V = W)
                }
            }
            return V
        }

        function T(U, V, W) {
            this._coordsMap = {};
            this._coordsList = [];
            this._axesMap = {};
            this._axesList = [];
            this._initCartesian(U, V, W);
            this.model = U
        }

        var Q = T.prototype;
        Q.type = "grid";
        Q.axisPointerEnabled = true;
        Q.getRect = function() {
            return this._rect
        };
        Q.update = function(W, X) {
            var V = this._axesMap;
            this._updateScale(W, this.model);

            function U(a) {
                var Y = V[a];
                for (var Z in Y) {
                    if (Y.hasOwnProperty(Z)) {
                        var b = Y[Z];
                        if (b && (b.type === "category" || b.type === "time" || !L(b))) {
                            return true
                        }
                    }
                }
                return false
            }

            G(V.x, function(Y) {
                B(Y.scale, Y.model)
            });
            G(V.y, function(Y) {
                B(Y.scale, Y.model)
            });
            G(V.x, function(Y) {
                if (U("y")) {
                    Y.onZero = false
                }
            });
            G(V.y, function(Y) {
                if (U("x")) {
                    Y.onZero = false
                }
            });
            this.resize(this.model, X)
        };
        Q.resize = function(U, Z, Y) {
            var W = H.getLayoutRect(U.getBoxLayoutParams(), {width: Z.getWidth(), height: Z.getHeight()});
            this._rect = W;
            var V = this._axesList;
            X();
            if (!Y && U.get("containLabel")) {
                G(V, function(d) {
                    if (!d.model.get("axisLabel.inside")) {
                        var b = S(d);
                        if (b) {
                            var c = d.isHorizontal() ? "height" : "width";
                            var a = d.model.get("axisLabel.margin");
                            W[c] -= b[c] + a;
                            if (d.position === "top") {
                                W.y += b.height + a
                            } else {
                                if (d.position === "left") {
                                    W.x += b.width + a
                                }
                            }
                        }
                    }
                });
                X()
            }

            function X() {
                G(V, function(d) {
                    var a = d.isHorizontal();
                    var b = a ? [0, W.width] : [0, W.height];
                    var c = d.inverse ? 1 : 0;
                    d.setExtent(b[c], b[1 - c]);
                    A(d, a ? W.x : W.y)
                })
            }
        };
        Q.getAxis = function(W, X) {
            var U = this._axesMap[W];
            if (U != null) {
                if (X == null) {
                    for (var V in U) {
                        if (U.hasOwnProperty(V)) {
                            return U[V]
                        }
                    }
                }
                return U[X]
            }
        };
        Q.getAxes = function() {
            return this._axesList.slice()
        };
        Q.getCartesian = function(Y, U) {
            if (Y != null && U != null) {
                var V = "x" + Y + "y" + U;
                return this._coordsMap[V]
            }
            if (E.isObject(Y)) {
                U = Y.yAxisIndex;
                Y = Y.xAxisIndex
            }
            for (var W = 0, X = this._coordsList; W < X.length; W++) {
                if (X[W].getAxis("x").index === Y || X[W].getAxis("y").index === U) {
                    return X[W]
                }
            }
        };
        Q.getCartesians = function() {
            return this._coordsList.slice()
        };
        Q.convertToPixel = function(U, X, W) {
            var V = this._findConvertTarget(U, X);
            return V.cartesian ? V.cartesian.dataToPoint(W) : V.axis ? V.axis.toGlobalCoord(V.axis.dataToCoord(W)) : null
        };
        Q.convertFromPixel = function(U, X, W) {
            var V = this._findConvertTarget(U, X);
            return V.cartesian ? V.cartesian.pointToData(W) : V.axis ? V.axis.coordToData(V.axis.toLocalCoord(W)) : null
        };
        Q._findConvertTarget = function(V, U) {
            var d = U.seriesModel;
            var X = U.xAxisModel || (d && d.getReferringComponents("xAxis")[0]);
            var c = U.yAxisModel || (d && d.getReferringComponents("yAxis")[0]);
            var W = U.gridModel;
            var b = this._coordsList;
            var Z;
            var Y;
            if (d) {
                Z = d.coordinateSystem;
                E.indexOf(b, Z) < 0 && (Z = null)
            } else {
                if (X && c) {
                    Z = this.getCartesian(X.componentIndex, c.componentIndex)
                } else {
                    if (X) {
                        Y = this.getAxis("x", X.componentIndex)
                    } else {
                        if (c) {
                            Y = this.getAxis("y", c.componentIndex)
                        } else {
                            if (W) {
                                var a = W.coordinateSystem;
                                if (a === this) {
                                    Z = this._coordsList[0]
                                }
                            }
                        }
                    }
                }
            }
            return {cartesian: Z, axis: Y}
        };
        Q.containPoint = function(U) {
            var V = this._coordsList[0];
            if (V) {
                return V.containPoint(U)
            }
        };
        Q._initCartesian = function(U, W, Z) {
            var Y = {left: false, right: false, top: false, bottom: false};
            var V = {x: {}, y: {}};
            var X = {x: 0, y: 0};
            W.eachComponent("xAxis", a("x"), this);
            W.eachComponent("yAxis", a("y"), this);
            if (!X.x || !X.y) {
                this._axesMap = {};
                this._axesList = [];
                return
            }
            this._axesMap = V;
            G(V.x, function(b, c) {
                G(V.y, function(f, d) {
                    var e = "x" + c + "y" + d;
                    var g = new D(e);
                    g.grid = this;
                    g.model = U;
                    this._coordsMap[e] = g;
                    this._coordsList.push(g);
                    g.addAxis(b);
                    g.addAxis(f)
                }, this)
            }, this);

            function a(b) {
                return function(d, e) {
                    if (!I(d, U, W)) {
                        return
                    }
                    var f = d.get("position");
                    if (b === "x") {
                        if (f !== "top" && f !== "bottom") {
                            f = "bottom";
                            if (Y[f]) {
                                f = f === "top" ? "bottom" : "top"
                            }
                        }
                    } else {
                        if (f !== "left" && f !== "right") {
                            f = "left";
                            if (Y[f]) {
                                f = f === "left" ? "right" : "left"
                            }
                        }
                    }
                    Y[f] = true;
                    var g = new K(b, C.createScaleByModel(d), [0, 0], d.get("type"), f);
                    var c = g.type === "category";
                    g.onBand = c && d.get("boundaryGap");
                    g.inverse = d.get("inverse");
                    g.onZero = d.get("axisLine.onZero");
                    d.axis = g;
                    g.model = d;
                    g.grid = this;
                    g.index = e;
                    this._axesList.push(g);
                    V[b][e] = g;
                    X[b]++
                }
            }
        };
        Q._updateScale = function(V, U) {
            E.each(this._axesList, function(X) {
                X.scale.setExtent(Infinity, -Infinity)
            });
            V.eachSeries(function(e) {
                if (P(e)) {
                    var d = R(e, V);
                    var Z = d[0];
                    var c = d[1];
                    if (!I(Z, U, V) || !I(c, U, V)) {
                        return
                    }
                    var a = this.getCartesian(Z.componentIndex, c.componentIndex);
                    var Y = e.getData();
                    var b = a.getAxis("x");
                    var X = a.getAxis("y");
                    if (Y.type === "list") {
                        W(Y, b, e);
                        W(Y, X, e)
                    }
                }
            }, this);

            function W(Z, Y, X) {
                G(X.coordDimToDataDim(Y.dim), function(a) {
                    Y.scale.unionExtentFromData(Z, a)
                })
            }
        };
        Q.getTooltipAxes = function(V) {
            var W = [];
            var U = [];
            G(this.getCartesians(), function(Z) {
                var Y = (V != null && V !== "auto") ? Z.getAxis(V) : Z.getBaseAxis();
                var X = Z.getOtherAxis(Y);
                E.indexOf(W, Y) < 0 && W.push(Y);
                E.indexOf(U, X) < 0 && U.push(X)
            });
            return {baseAxes: W, otherAxes: U}
        };

        function A(X, W) {
            var U = X.getExtent();
            var V = U[0] + U[1];
            X.toGlobalCoord = X.dim === "x" ? function(Y) {
                return Y + W
            } : function(Y) {
                return V - Y + W
            };
            X.toLocalCoord = X.dim === "x" ? function(Y) {
                return Y - W
            } : function(Y) {
                return V - Y + W
            }
        }

        var M = ["xAxis", "yAxis"];

        function R(U, V) {
            return E.map(M, function(X) {
                var W = U.getReferringComponents(X)[0];
                if (true) {
                    if (!W) {
                        throw new Error(X + ' "' + E.retrieve(U.get(X + "Index"), U.get(X + "Id"), 0) + '" not found')
                    }
                }
                return W
            })
        }

        function P(U) {
            return U.get("coordinateSystem") === "cartesian2d"
        }

        T.create = function(V, W) {
            var U = [];
            V.eachComponent("grid", function(X, Y) {
                var Z = new T(X, V, W);
                Z.name = "grid_" + Y;
                Z.resize(X, W, true);
                X.coordinateSystem = Z;
                U.push(Z)
            });
            V.eachSeries(function(Y) {
                if (!P(Y)) {
                    return
                }
                var b = R(Y, V);
                var a = b[0];
                var X = b[1];
                var Z = a.getCoordSysModel();
                if (true) {
                    if (!Z) {
                        throw new Error('Grid "' + E.retrieve(a.get("gridIndex"), a.get("gridId"), 0) + '" not found')
                    }
                    if (a.getCoordSysModel() !== X.getCoordSysModel()) {
                        throw new Error("xAxis and yAxis must use the same grid")
                    }
                }
                var c = Z.coordinateSystem;
                Y.coordinateSystem = c.getCartesian(a.componentIndex, X.componentIndex)
            });
            return U
        };
        T.dimensions = T.prototype.dimensions = D.prototype.dimensions;
        O(76).register("cartesian2d", T);
        N.exports = T
    }, function(D, F, C) {
        var B = C(4);
        var A = C(127);

        function E(G) {
            A.call(this, G)
        }

        E.prototype = {
            constructor: E, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function() {
                return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
            }, containPoint: function(H) {
                var I = this.getAxis("x");
                var G = this.getAxis("y");
                return I.contain(I.toLocalCoord(H[0])) && G.contain(G.toLocalCoord(H[1]))
            }, containData: function(G) {
                return this.getAxis("x").containData(G[0]) && this.getAxis("y").containData(G[1])
            }, dataToPoints: function(H, G) {
                return H.mapArray(["x", "y"], function(I, J) {
                    return this.dataToPoint([I, J])
                }, G, this)
            }, dataToPoint: function(J, I) {
                var G = this.getAxis("x");
                var H = this.getAxis("y");
                return [G.toGlobalCoord(G.dataToCoord(J[0], I)), H.toGlobalCoord(H.dataToCoord(J[1], I))]
            }, pointToData: function(H, I) {
                var G = this.getAxis("x");
                var J = this.getAxis("y");
                return [G.coordToData(G.toLocalCoord(H[0]), I), J.coordToData(J.toLocalCoord(H[1]), I)]
            }, getOtherAxis: function(G) {
                return this.getAxis(G.dim === "x" ? "y" : "x")
            }
        };
        B.inherits(E, A);
        D.exports = E
    }, function(D, E, C) {
        var B = C(4);

        function F(G) {
            return this._axes[G]
        }

        var A = function(G) {
            this._axes = {};
            this._dimList = [];
            this.name = G || ""
        };
        A.prototype = {
            constructor: A, type: "cartesian", getAxis: function(G) {
                return this._axes[G]
            }, getAxes: function() {
                return B.map(this._dimList, F, this)
            }, getAxesByScale: function(G) {
                G = G.toLowerCase();
                return B.filter(this.getAxes(), function(H) {
                    return H.scale.type === G
                })
            }, addAxis: function(H) {
                var G = H.dim;
                this._axes[G] = H;
                this._dimList.push(G)
            }, dataToCoord: function(G) {
                return this._dataCoordConvert(G, "dataToCoord")
            }, coordToData: function(G) {
                return this._dataCoordConvert(G, "coordToData")
            }, _dataCoordConvert: function(I, L) {
                var H = this._dimList;
                var M = I instanceof Array ? [] : {};
                for (var G = 0; G < H.length; G++) {
                    var J = H[G];
                    var K = this._axes[J];
                    M[J] = K[L](I[J])
                }
                return M
            }
        };
        D.exports = A
    }, function(C, F, B) {
        var A = B(4);
        var E = B(100);
        var D = function(I, J, H, K, G) {
            E.call(this, I, J, H);
            this.type = K || "value";
            this.position = G || "bottom"
        };
        D.prototype = {
            constructor: D, index: 0, onZero: false, model: null, isHorizontal: function() {
                var G = this.position;
                return G === "top" || G === "bottom"
            }, getGlobalExtent: function(G) {
                var H = this.getExtent();
                H[0] = this.toGlobalCoord(H[0]);
                H[1] = this.toGlobalCoord(H[1]);
                G && H[0] > H[1] && H.reverse();
                return H
            }, getOtherAxis: function() {
                this.grid.getOtherAxis()
            }, isLabelIgnored: function(H) {
                if (this.type === "category") {
                    var G = this.getLabelInterval();
                    return ((typeof G === "function") && !G(H, this.scale.getLabel(H))) || H % (G + 1)
                }
            }, pointToData: function(G, H) {
                return this.coordToData(this.toLocalCoord(G[this.dim === "x" ? 0 : 1]), H)
            }, toLocalCoord: null, toGlobalCoord: null
        };
        A.inherits(D, E);
        C.exports = D
    }, function(C, D, B) {
        B(130);
        var A = B(69);
        C.exports = A.extend({
            type: "grid",
            dependencies: ["xAxis", "yAxis"],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: false,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: false,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        })
    }, function(G, I, D) {
        var H = D(69);
        var C = D(4);
        var B = D(131);
        var E = H.extend({
            type: "cartesian2dAxis", axis: null, init: function() {
                E.superApply(this, "init", arguments);
                this.resetRange()
            }, mergeOption: function() {
                E.superApply(this, "mergeOption", arguments);
                this.resetRange()
            }, restoreData: function() {
                E.superApply(this, "restoreData", arguments);
                this.resetRange()
            }, getCoordSysModel: function() {
                return this.ecModel.queryComponents({mainType: "grid", index: this.option.gridIndex, id: this.option.gridId})[0]
            }
        });

        function A(K, J) {
            return J.type || (J.data ? "category" : "value")
        }

        C.merge(E.prototype, D(112));
        var F = {offset: 0};
        B("x", E, A, F);
        B("y", E, A, F);
        G.exports = E
    }, function(F, H, D) {
        var A = D(132);
        var C = D(4);
        var G = D(69);
        var E = D(71);
        var B = ["value", "category", "time", "log"];
        F.exports = function(L, I, J, K) {
            C.each(B, function(M) {
                I.extend({
                    type: L + "Axis." + M, mergeDefaultAndTheme: function(O, P) {
                        var R = this.layoutMode;
                        var N = R ? E.getLayoutParams(O) : {};
                        var Q = P.getTheme();
                        C.merge(O, Q.get(M + "Axis"));
                        C.merge(O, this.getDefaultOption());
                        O.type = J(L, O);
                        if (R) {
                            E.mergeLayoutParam(O, N, R)
                        }
                    }, defaultOption: C.mergeAll([{}, A[M + "Axis"], K], true)
                })
            });
            G.registerSubTypeDefaulter(L + "Axis", C.curry(J, L))
        }
    }, function(H, I, C) {
        var B = C(4);
        var E = {
            show: true,
            zlevel: 0,
            z: 0,
            inverse: false,
            name: "",
            nameLocation: "end",
            nameRotate: null,
            nameTruncate: {maxWidth: null, ellipsis: "...", placeholder: "."},
            nameTextStyle: {},
            nameGap: 15,
            silent: false,
            triggerEvent: false,
            tooltip: {show: false},
            axisPointer: {},
            axisLine: {show: true, onZero: true, lineStyle: {color: "#333", width: 1, type: "solid"}},
            axisTick: {show: true, inside: false, length: 5, lineStyle: {width: 1}},
            axisLabel: {show: true, inside: false, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, textStyle: {fontSize: 12}},
            splitLine: {show: true, lineStyle: {color: ["#ccc"], width: 1, type: "solid"}},
            splitArea: {show: false, areaStyle: {color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]}}
        };
        var D = B.merge({
            boundaryGap: true,
            splitLine: {show: false},
            axisTick: {alignWithLabel: false, interval: "auto"},
            axisLabel: {interval: "auto"}
        }, E);
        var G = B.merge({boundaryGap: [0, 0], splitNumber: 5}, E);
        var A = B.defaults({scale: true, min: "dataMin", max: "dataMax"}, G);
        var F = B.defaults({scale: true, logBase: 10}, G);
        H.exports = {categoryAxis: D, valueAxis: G, timeAxis: A, logAxis: F}
    }, function(B, C, A) {
        A(130);
        A(134)
    }, function(L, M, D) {
        var C = D(4);
        var F = D(18);
        var B = D(135);
        var J = D(136);
        var A = D(138);
        var I = B.ifIgnoreOnTick;
        var K = B.getInterval;
        var G = ["axisLine", "axisLabel", "axisTick", "axisName"];
        var H = ["splitArea", "splitLine"];
        var E = J.extend({
            type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function(Q, N, U, O) {
                this.group.removeAll();
                var R = this._axisGroup;
                this._axisGroup = new F.Group();
                this.group.add(this._axisGroup);
                if (!Q.get("show")) {
                    return
                }
                var P = Q.getCoordSysModel();
                var S = A.layout(P, Q);
                var T = new B(Q, S);
                C.each(G, T.add, T);
                this._axisGroup.add(T.getGroup());
                C.each(H, function(V) {
                    if (Q.get(V + ".show")) {
                        this["_" + V](Q, P, S.labelInterval)
                    }
                }, this);
                F.groupTransition(R, this._axisGroup, Q);
                E.superCall(this, "render", Q, N, U, O)
            }, _splitLine: function(W, O, e) {
                var c = W.axis;
                if (c.scale.isBlank()) {
                    return
                }
                var b = W.getModel("splitLine");
                var d = b.getModel("lineStyle");
                var X = d.get("color");
                var Y = K(b, e);
                X = C.isArray(X) ? X : [X];
                var V = O.coordinateSystem.getRect();
                var Z = c.isHorizontal();
                var a = 0;
                var P = c.getTicksCoords();
                var U = c.scale.getTicks();
                var f = [];
                var Q = [];
                var T = d.getLineStyle();
                for (var S = 0; S < P.length; S++) {
                    if (I(c, S, Y)) {
                        continue
                    }
                    var N = c.toGlobalCoord(P[S]);
                    if (Z) {
                        f[0] = N;
                        f[1] = V.y;
                        Q[0] = N;
                        Q[1] = V.y + V.height
                    } else {
                        f[0] = V.x;
                        f[1] = N;
                        Q[0] = V.x + V.width;
                        Q[1] = N
                    }
                    var R = (a++) % X.length;
                    this._axisGroup.add(new F.Line(F.subPixelOptimizeLine({
                        anid: "line_" + U[S],
                        shape: {x1: f[0], y1: f[1], x2: Q[0], y2: Q[1]},
                        style: C.defaults({stroke: X[R]}, T),
                        silent: true
                    })))
                }
            }, _splitArea: function(W, O, e) {
                var Z = W.axis;
                if (Z.scale.isBlank()) {
                    return
                }
                var c = W.getModel("splitArea");
                var T = c.getModel("areaStyle");
                var j = T.get("color");
                var V = O.coordinateSystem.getRect();
                var P = Z.getTicksCoords();
                var d = Z.scale.getTicks();
                var Y = Z.toGlobalCoord(P[0]);
                var X = Z.toGlobalCoord(P[0]);
                var S = 0;
                var b = K(c, e);
                var Q = T.getAreaStyle();
                j = C.isArray(j) ? j : [j];
                for (var U = 1; U < P.length; U++) {
                    if (I(Z, U, b)) {
                        continue
                    }
                    var N = Z.toGlobalCoord(P[U]);
                    var f;
                    var g;
                    var a;
                    var h;
                    if (Z.isHorizontal()) {
                        f = Y;
                        g = V.y;
                        a = N - f;
                        h = V.height
                    } else {
                        f = V.x;
                        g = X;
                        a = V.width;
                        h = N - g
                    }
                    var R = (S++) % j.length;
                    this._axisGroup.add(new F.Rect({
                        anid: "area_" + d[U],
                        shape: {x: f, y: g, width: a, height: h},
                        style: C.defaults({fill: j[R]}, Q),
                        silent: true
                    }));
                    Y = f + a;
                    X = g + h
                }
            }
        });
        E.extend({type: "xAxis"});
        E.extend({type: "yAxis"})
    }, function(Q, G, J) {
        var F = J(4);
        var X = J(6);
        var K = J(18);
        var W = J(12);
        var P = J(7);
        var M = P.remRadian;
        var A = P.isRadianAroundZero;
        var O = J(10);
        var I = J(11);
        var T = O.applyTransform;
        var B = F.retrieve;
        var H = Math.PI;

        function U(Z) {
            var a = {componentType: Z.mainType};
            a[Z.mainType + "Index"] = Z.componentIndex;
            return a
        }

        var V = function(a, Z) {
            this.opt = Z;
            this.axisModel = a;
            F.defaults(Z, {labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: true});
            this.group = new K.Group();
            var b = new K.Group({position: Z.position.slice(), rotation: Z.rotation});
            b.updateTransform();
            this._transform = b.transform;
            this._dumbGroup = b
        };
        V.prototype = {
            constructor: V, hasBuilder: function(Z) {
                return !!N[Z]
            }, add: function(Z) {
                N[Z].call(this)
            }, getGroup: function() {
                return this.group
            }
        };
        var N = {
            axisLine: function() {
                var b = this.opt;
                var c = this.axisModel;
                if (!c.get("axisLine.show")) {
                    return
                }
                var d = this.axisModel.axis.getExtent();
                var Z = this._transform;
                var a = [d[0], 0];
                var e = [d[1], 0];
                if (Z) {
                    T(a, a, Z);
                    T(e, e, Z)
                }
                this.group.add(new K.Line(K.subPixelOptimizeLine({
                    anid: "line",
                    shape: {x1: a[0], y1: a[1], x2: e[0], y2: e[1]},
                    style: F.extend({lineCap: "round"}, c.getModel("axisLine.lineStyle").getLineStyle()),
                    strokeContainThreshold: b.strokeContainThreshold || 5,
                    silent: true,
                    z2: 1
                })))
            }, axisTick: function() {
                var l = this.axisModel;
                var a = l.axis;
                if (!l.get("axisTick.show") || a.scale.isBlank()) {
                    return
                }
                var h = l.getModel("axisTick");
                var k = this.opt;
                var b = h.getModel("lineStyle");
                var g = h.get("length");
                var d = Y(h, k.labelInterval);
                var m = a.getTicksCoords(h.get("alignWithLabel"));
                var Z = a.scale.getTicks();
                var e = [];
                var n = [];
                var f = this._transform;
                for (var j = 0; j < m.length; j++) {
                    if (C(a, j, d)) {
                        continue
                    }
                    var c = m[j];
                    e[0] = c;
                    e[1] = 0;
                    n[0] = c;
                    n[1] = k.tickDirection * g;
                    if (f) {
                        T(e, e, f);
                        T(n, n, f)
                    }
                    this.group.add(new K.Line(K.subPixelOptimizeLine({
                        anid: "tick_" + Z[j],
                        shape: {x1: e[0], y1: e[1], x2: n[0], y2: n[1]},
                        style: F.defaults(b.getLineStyle(), {stroke: l.get("axisLine.lineStyle.color")}),
                        z2: 2,
                        silent: true
                    })))
                }
            }, axisLabel: function() {
                var b = this.opt;
                var c = this.axisModel;
                var a = c.axis;
                var n = B(b.axisLabelShow, c.get("axisLabel.show"));
                if (!n || a.scale.isBlank()) {
                    return
                }
                var f = c.getModel("axisLabel");
                var g = f.getModel("textStyle");
                var d = f.get("margin");
                var j = a.scale.getTicks();
                var m = c.getFormattedLabels();
                var i = (B(b.labelRotate, f.get("rotate")) || 0) * H / 180;
                var e = D(b.rotation, i, b.labelDirection);
                var k = c.get("data");
                var Z = [];
                var h = R(c);
                var l = c.get("triggerEvent");
                F.each(j, function(v, p) {
                    if (C(a, p, b.labelInterval)) {
                        return
                    }
                    var o = g;
                    if (k && k[v] && k[v].textStyle) {
                        o = new W(k[v].textStyle, g, c.ecModel)
                    }
                    var r = o.getTextColor() || c.get("axisLine.lineStyle.color");
                    var u = a.dataToCoord(v);
                    var s = [u, b.labelOffset + b.labelDirection * d];
                    var t = a.scale.getLabel(v);
                    var q = new K.Text({
                        anid: "label_" + v,
                        style: {
                            text: m[p],
                            textAlign: o.get("align", true) || e.textAlign,
                            textVerticalAlign: o.get("baseline", true) || e.textVerticalAlign,
                            textFont: o.getFont(),
                            fill: typeof r === "function" ? r(a.type === "category" ? t : a.type === "value" ? v + "" : v, p) : r
                        },
                        position: s,
                        rotation: e.rotation,
                        silent: h,
                        z2: 10
                    });
                    if (l) {
                        q.eventData = U(c);
                        q.eventData.targetType = "axisLabel";
                        q.eventData.value = t
                    }
                    this._dumbGroup.add(q);
                    q.updateTransform();
                    Z.push(q);
                    this.group.add(q);
                    q.decomposeTransform()
                }, this);
                S(c, Z)
            }, axisName: function() {
                var e = this.opt;
                var Z = this.axisModel;
                var s = B(e.axisName, Z.get("name"));
                if (!s) {
                    return
                }
                var a = Z.get("nameLocation");
                var u = e.nameDirection;
                var i = Z.getModel("nameTextStyle");
                var b = Z.get("nameGap") || 0;
                var l = this.axisModel.axis.getExtent();
                var g = l[0] > l[1] ? -1 : 1;
                var r = [a === "start" ? l[0] - g * b : a === "end" ? l[1] + g * b : (l[0] + l[1]) / 2, a === "middle" ? e.labelOffset + u * b : 0];
                var o;
                var c = Z.get("nameRotate");
                if (c != null) {
                    c = c * H / 180
                }
                var t;
                if (a === "middle") {
                    o = D(e.rotation, c != null ? c : e.rotation, u)
                } else {
                    o = E(e, a, c || 0, l);
                    t = e.axisNameAvailableWidth;
                    if (t != null) {
                        t = Math.abs(t / Math.sin(o.rotation));
                        !isFinite(t) && (t = null)
                    }
                }
                var p = i.getFont();
                var d = Z.get("nameTruncate", true) || {};
                var j = d.ellipsis;
                var f = B(e.nameTruncateMaxWidth, d.maxWidth, t);
                var k = (j != null && f != null) ? X.truncateText(s, f, p, j, {minChar: 2, placeholder: d.placeholder}) : s;
                var n = Z.get("tooltip", true);
                var h = Z.mainType;
                var m = {componentType: h, name: s, $vars: ["name"]};
                m[h + "Index"] = Z.componentIndex;
                var q = new K.Text({
                    anid: "name",
                    __fullText: s,
                    __truncatedText: k,
                    style: {
                        text: k,
                        textFont: p,
                        fill: i.getTextColor() || Z.get("axisLine.lineStyle.color"),
                        textAlign: o.textAlign,
                        textVerticalAlign: o.textVerticalAlign
                    },
                    position: r,
                    rotation: o.rotation,
                    silent: R(Z),
                    z2: 1,
                    tooltip: (n && n.show) ? F.extend({
                        content: s, formatter: function() {
                            return s
                        }, formatterParams: m
                    }, n) : null
                });
                if (Z.get("triggerEvent")) {
                    q.eventData = U(Z);
                    q.eventData.targetType = "axisName";
                    q.eventData.name = s
                }
                this._dumbGroup.add(q);
                q.updateTransform();
                this.group.add(q);
                q.decomposeTransform()
            }
        };
        var D = V.innerTextLayout = function(d, c, Z) {
            var a = M(c - d);
            var e;
            var b;
            if (A(a)) {
                b = Z > 0 ? "top" : "bottom";
                e = "center"
            } else {
                if (A(a - H)) {
                    b = Z > 0 ? "bottom" : "top";
                    e = "center"
                } else {
                    b = "middle";
                    if (a > 0 && a < H) {
                        e = Z > 0 ? "right" : "left"
                    } else {
                        e = Z > 0 ? "left" : "right"
                    }
                }
            }
            return {rotation: a, textAlign: e, textVerticalAlign: b}
        };

        function E(a, h, d, b) {
            var g = M(d - a.rotation);
            var Z;
            var c;
            var f = b[0] > b[1];
            var e = (h === "start" && !f) || (h !== "start" && f);
            if (A(g - H / 2)) {
                c = e ? "bottom" : "top";
                Z = "center"
            } else {
                if (A(g - H * 1.5)) {
                    c = e ? "top" : "bottom";
                    Z = "center"
                } else {
                    c = "middle";
                    if (g < H * 1.5 && g > H / 2) {
                        Z = e ? "left" : "right"
                    } else {
                        Z = e ? "right" : "left"
                    }
                }
            }
            return {rotation: g, textAlign: Z, textVerticalAlign: c}
        }

        function R(a) {
            var Z = a.get("tooltip");
            return a.get("silent") || !(a.get("triggerEvent") || (Z && Z.show))
        }

        function S(c, e) {
            var Z = c.get("axisLabel.showMinLabel");
            var b = c.get("axisLabel.showMaxLabel");
            var g = e[0];
            var f = e[1];
            var d = e[e.length - 1];
            var a = e[e.length - 2];
            if (Z === false) {
                g.ignore = true
            } else {
                if (c.getMin() != null && L(g, f)) {
                    Z ? (f.ignore = true) : (g.ignore = true)
                }
            }
            if (b === false) {
                d.ignore = true
            } else {
                if (c.getMax() != null && L(a, d)) {
                    b ? (a.ignore = true) : (d.ignore = true)
                }
            }
        }

        function L(d, c, a) {
            var e = d && d.getBoundingRect().clone();
            var Z = c && c.getBoundingRect().clone();
            if (!e || !Z) {
                return
            }
            var b = I.identity([]);
            I.rotate(b, b, -d.rotation);
            e.applyTransform(I.mul([], b, d.getLocalTransform()));
            Z.applyTransform(I.mul([], b, c.getLocalTransform()));
            return e.intersect(Z)
        }

        var C = V.ifIgnoreOnTick = function(d, Z, a) {
            var b;
            var c = d.scale;
            return c.type === "ordinal" && (typeof a === "function" ? (b = c.getTicks()[Z], !a(b, c.getLabel(b))) : Z % (a + 1))
        };
        var Y = V.getInterval = function(b, Z) {
            var a = b.get("interval");
            if (a == null || a == "auto") {
                a = Z
            }
            return a
        };
        Q.exports = V
    }, function(G, H, B) {
        var C = B(137);
        var E = B(1).extendComponentView({
            type: "axis", _axisPointer: null, axisPointerClass: null, render: function(J, I, L, K) {
                this.axisPointerClass && C.fixValue(J);
                E.superApply(this, "render", arguments);
                D(this, J, I, L, K, true)
            }, updateAxisPointer: function(J, I, M, K, L) {
                D(this, J, I, M, K, false)
            }, remove: function(I, K) {
                var J = this._axisPointer;
                J && J.remove(K);
                E.superApply(this, "remove", arguments)
            }, dispose: function(I, J) {
                A(this, J);
                E.superApply(this, "dispose", arguments)
            }
        });

        function D(K, M, I, O, J, P) {
            var N = E.getAxisPointerClass(K.axisPointerClass);
            if (!N) {
                return
            }
            var L = C.getAxisPointerModel(M);
            L ? (K._axisPointer || (K._axisPointer = new N())).render(M, L, O, P) : A(K, O)
        }

        function A(J, I, L) {
            var K = J._axisPointer;
            K && K.dispose(I, L);
            J._axisPointer = null
        }

        var F = [];
        E.registerAxisPointerClass = function(I, J) {
            if (true) {
                if (F[I]) {
                    throw new Error("axisPointer " + I + " exists")
                }
            }
            F[I] = J
        };
        E.getAxisPointerClass = function(I) {
            return I && F[I]
        };
        G.exports = E
    }, function(M, O, E) {
        var D = E(4);
        var L = E(12);
        var A = D.each;
        var C = D.curry;
        var K = {};
        K.collect = function(P, R) {
            var Q = {axesInfo: {}, seriesInvolved: false, coordSysAxesInfo: {}, coordSysMap: {}};
            B(Q, P, R);
            Q.seriesInvolved && I(Q, P);
            return Q
        };

        function B(Q, U, S) {
            var T = U.getComponent("tooltip");
            var P = U.getComponent("axisPointer");
            var V = P.get("link", true) || [];
            var R = [];
            A(S.getCoordinateSystems(), function(X) {
                if (!X.axisPointerEnabled) {
                    return
                }
                var c = J(X.model);
                var e = Q.coordSysAxesInfo[c] = {};
                Q.coordSysMap[c] = X;
                var b = X.model;
                var W = b.getModel("tooltip", T);
                A(X.getAxes(), C(Z, false, null));
                if (X.getTooltipAxes && T && W.get("show")) {
                    var Y = W.get("trigger") === "axis";
                    var d = W.get("axisPointer.type") === "cross";
                    var a = X.getTooltipAxes(W.get("axisPointer.axis"));
                    if (Y || d) {
                        A(a.baseAxes, C(Z, d ? "cross" : true, Y))
                    }
                    if (d) {
                        A(a.otherAxes, C(Z, "cross", false))
                    }
                }

                function Z(i, j, g) {
                    var h = g.model.getModel("axisPointer", P);
                    var p = h.get("show");
                    if (!p || (p === "auto" && !i && !F(h))) {
                        return
                    }
                    if (j == null) {
                        j = h.get("triggerTooltip")
                    }
                    h = i ? H(g, W, P, U, i, j) : h;
                    var o = h.get("snap");
                    var n = J(g.model);
                    var l = j || o || g.type === "category";
                    var m = Q.axesInfo[n] = {
                        key: n,
                        axis: g,
                        coordSys: X,
                        axisPointerModel: h,
                        triggerTooltip: j,
                        involveSeries: l,
                        snap: o,
                        useHandle: F(h),
                        seriesModels: []
                    };
                    e[n] = m;
                    Q.seriesInvolved |= l;
                    var f = G(V, g);
                    if (f != null) {
                        var k = R[f] || (R[f] = {axesInfo: {}});
                        k.axesInfo[n] = m;
                        k.mapper = V[f].mapper;
                        m.linkGroup = k
                    }
                }
            })
        }

        function H(Q, P, U, X, R, T) {
            var S = P.getModel("axisPointer");
            var Y = {};
            A(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(Z) {
                Y[Z] = D.clone(S.get(Z))
            });
            Y.snap = Q.type !== "category" && !!T;
            if (S.get("type") === "cross") {
                Y.type = "line"
            }
            var V = Y.label || (Y.label = {});
            V.show == null && (V.show = false);
            if (R === "cross") {
                V.show = true;
                if (!T) {
                    var W = Y.lineStyle = S.get("crossStyle");
                    W && D.defaults(V.textStyle || (V.textStyle = {}), W.textStyle)
                }
            }
            return Q.model.getModel("axisPointer", new L(Y, U, X))
        }

        function I(P, Q) {
            Q.eachSeries(function(R) {
                var T = R.coordinateSystem;
                var S = R.get("tooltip.trigger", true);
                var U = R.get("tooltip.show", true);
                if (!T || S === "none" || S === false || S === "item" || U === false || R.get("axisPointer.show", true) === false) {
                    return
                }
                A(P.coordSysAxesInfo[J(T.model)], function(V) {
                    var W = V.axis;
                    if (T.getAxis(W.dim) === W) {
                        V.seriesModels.push(R);
                        V.seriesDataCount == null && (V.seriesDataCount = 0);
                        V.seriesDataCount += R.getData().count()
                    }
                })
            }, this)
        }

        function G(Q, U) {
            var R = U.model;
            var S = U.dim;
            for (var P = 0; P < Q.length; P++) {
                var T = Q[P] || {};
                if (N(T[S + "AxisId"], R.id) || N(T[S + "AxisIndex"], R.componentIndex) || N(T[S + "AxisName"], R.name)) {
                    return P
                }
            }
        }

        function N(P, Q) {
            return P === "all" || (D.isArray(P) && D.indexOf(P, Q) >= 0) || P === Q
        }

        K.fixValue = function(S) {
            var V = K.getAxisInfo(S);
            if (!V) {
                return
            }
            var Q = V.axisPointerModel;
            var R = V.axis.scale;
            var X = Q.option;
            var W = Q.get("status");
            var U = Q.get("value");
            if (U != null) {
                U = R.parse(U)
            }
            var P = F(Q);
            if (W == null) {
                X.status = P ? "show" : "hide"
            }
            var T = R.getExtent().slice();
            T[0] > T[1] && T.reverse();
            if (U == null || U > T[1]) {
                U = T[1]
            }
            if (U < T[0]) {
                U = T[0]
            }
            X.value = U;
            if (P) {
                X.status = V.axis.scale.isBlank() ? "hide" : "show"
            }
        };
        K.getAxisInfo = function(Q) {
            var P = (Q.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
            return P && P.axesInfo[J(Q)]
        };
        K.getAxisPointerModel = function(Q) {
            var P = K.getAxisInfo(Q);
            return P && P.axisPointerModel
        };

        function F(P) {
            return !!P.get("handle.show")
        }

        var J = K.makeKey = function(P) {
            return P.type + "||" + P.id
        };
        M.exports = K
    }, function(C, E, B) {
        var A = B(4);
        var D = {};
        D.layout = function(P, J, I) {
            I = I || {};
            var U = P.coordinateSystem;
            var H = J.axis;
            var O = {};
            var M = H.position;
            var F = H.onZero ? "onZero" : M;
            var T = H.dim;
            var K = U.getRect();
            var Q = [K.x, K.x + K.width, K.y, K.y + K.height];
            var G = J.get("offset") || 0;
            var R = {x: {top: Q[2] - G, bottom: Q[3] + G}, y: {left: Q[0] - G, right: Q[1] + G}};
            R.x.onZero = Math.max(Math.min(S("y"), R.x.bottom), R.x.top);
            R.y.onZero = Math.max(Math.min(S("x"), R.y.right), R.y.left);

            function S(W, X) {
                var V = U.getAxis(W);
                return V.toGlobalCoord(V.dataToCoord(0))
            }

            O.position = [T === "y" ? R.y[F] : Q[0], T === "x" ? R.x[F] : Q[3]];
            O.rotation = Math.PI / 2 * (T === "x" ? 0 : 1);
            var N = {top: -1, bottom: 1, left: -1, right: 1};
            O.labelDirection = O.tickDirection = O.nameDirection = N[M];
            O.labelOffset = H.onZero ? R[T][M] - R[T].onZero : 0;
            if (J.get("axisTick.inside")) {
                O.tickDirection = -O.tickDirection
            }
            if (A.retrieve(I.labelInside, J.get("axisLabel.inside"))) {
                O.labelDirection = -O.labelDirection
            }
            var L = J.get("axisLabel.rotate");
            O.labelRotate = F === "top" ? -L : L;
            O.labelInterval = H.getLabelInterval();
            O.z2 = 1;
            return O
        };
        C.exports = D
    }, function(D, F, C) {
        var B = C(4);
        C(125);
        C(140);
        C(142);
        var E = C(145);
        var A = C(1);
        A.registerLayout(B.curry(E, "bar"));
        A.registerVisual(function(G) {
            G.eachSeriesByType("bar", function(H) {
                var I = H.getData();
                I.setVisual("legendSymbol", "roundRect")
            })
        });
        C(124)
    }, function(B, C, A) {
        B.exports = A(141).extend({type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect"})
    }, function(C, E, A) {
        var D = A(78);
        var B = A(109);
        C.exports = D.extend({
            type: "series.__base_bar__",
            getInitialData: function(F, G) {
                return B(F.data, this, G)
            },
            getMarkerPosition: function(J) {
                var I = this.coordinateSystem;
                if (I) {
                    var H = I.dataToPoint(J, true);
                    var L = this.getData();
                    var G = L.getLayout("offset");
                    var F = L.getLayout("size");
                    var K = I.getBaseAxis().isHorizontal() ? 0 : 1;
                    H[K] += G + F / 2;
                    return H
                }
                return [NaN, NaN]
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: true,
                barMinHeight: 0,
                barMinAngle: 0,
                itemStyle: {normal: {}, emphasis: {}}
            }
        })
    }, function(L, N, D) {
        var I = D(4);
        var G = D(18);
        var K = D(143);
        var C = ["itemStyle", "normal", "barBorderWidth"];
        I.extend(D(12).prototype, D(144));
        var E = D(1).extendChartView({
            type: "bar", render: function(O, Q, R) {
                var P = O.get("coordinateSystem");
                if (P === "cartesian2d" || P === "polar") {
                    this._render(O, Q, R)
                } else {
                    if (true) {
                        console.warn("Only cartesian2d and polar supported for bar.")
                    }
                }
                return this.group
            }, dispose: I.noop, _render: function(X, O, W) {
                var S = this.group;
                var P = X.getData();
                var Q = this._data;
                var T = X.coordinateSystem;
                var V = T.getBaseAxis();
                var U;
                if (T.type === "cartesian2d") {
                    U = V.isHorizontal()
                } else {
                    if (T.type === "polar") {
                        U = V.dim === "angle"
                    }
                }
                var R = X.isAnimationEnabled() ? X : null;
                P.diff(Q).add(function(Z) {
                    if (!P.hasValue(Z)) {
                        return
                    }
                    var a = P.getItemModel(Z);
                    var b = J[T.type](P, Z, a);
                    var Y = A[T.type](P, Z, a, b, U, R);
                    P.setItemGraphicEl(Z, Y);
                    S.add(Y);
                    F(Y, P, Z, a, b, X, U, T.type === "polar")
                }).update(function(c, a) {
                    var Y = Q.getItemGraphicEl(a);
                    if (!P.hasValue(c)) {
                        S.remove(Y);
                        return
                    }
                    var Z = P.getItemModel(c);
                    var b = J[T.type](P, c, Z);
                    if (Y) {
                        G.updateProps(Y, {shape: b}, R, c)
                    } else {
                        Y = A[T.type](P, c, Z, b, U, R, true)
                    }
                    P.setItemGraphicEl(c, Y);
                    S.add(Y);
                    F(Y, P, c, Z, b, X, U, T.type === "polar")
                }).remove(function(Z) {
                    var Y = Q.getItemGraphicEl(Z);
                    if (T.type === "cartesian2d") {
                        Y && H(Z, R, Y)
                    } else {
                        Y && B(Z, R, Y)
                    }
                }).execute();
                this._data = P
            }, remove: function(P, Q) {
                var O = this.group;
                var R = this._data;
                if (P.get("animation")) {
                    if (R) {
                        R.eachItemGraphicEl(function(S) {
                            if (S.type === "sector") {
                                B(S.dataIndex, P, S)
                            } else {
                                H(S.dataIndex, P, S)
                            }
                        })
                    }
                } else {
                    O.removeAll()
                }
            }
        });
        var A = {
            cartesian2d: function(R, W, P, U, Q, T, Y) {
                var S = new G.Rect({shape: I.extend({}, U)});
                if (T) {
                    var X = S.shape;
                    var V = Q ? "height" : "width";
                    var O = {};
                    X[V] = 0;
                    O[V] = U[V];
                    G[Y ? "updateProps" : "initProps"](S, {shape: O}, T, W)
                }
                return S
            }, polar: function(Q, V, O, T, R, S, Y) {
                var W = new G.Sector({shape: I.extend({}, T)});
                if (S) {
                    var X = W.shape;
                    var U = R ? "r" : "endAngle";
                    var P = {};
                    X[U] = R ? 0 : T.startAngle;
                    P[U] = T[U];
                    G[Y ? "updateProps" : "initProps"](W, {shape: P}, S, V)
                }
                return W
            }
        };

        function H(P, Q, O) {
            O.style.text = "";
            G.updateProps(O, {shape: {width: 0}}, Q, P, function() {
                O.parent && O.parent.remove(O)
            })
        }

        function B(P, Q, O) {
            O.style.text = "";
            G.updateProps(O, {shape: {r: O.shape.r0}}, Q, P, function() {
                O.parent && O.parent.remove(O)
            })
        }

        var J = {
            cartesian2d: function(U, O, P) {
                var S = U.getItemLayout(O);
                var T = M(P, S);
                var Q = S.width > 0 ? 1 : -1;
                var R = S.height > 0 ? 1 : -1;
                return {x: S.x + Q * T / 2, y: S.y + R * T / 2, width: S.width - Q * T, height: S.height - R * T}
            }, polar: function(R, O, P) {
                var Q = R.getItemLayout(O);
                return {cx: Q.cx, cy: Q.cy, r0: Q.r0, r: Q.r, startAngle: Q.startAngle, endAngle: Q.endAngle}
            }
        };

        function F(W, S, Z, Q, X, b, R, P) {
            var T = S.getItemVisual(Z, "color");
            var U = S.getItemVisual(Z, "opacity");
            var V = Q.getModel("itemStyle.normal");
            var Y = Q.getModel("itemStyle.emphasis").getBarItemStyle();
            if (!P) {
                W.setShape("r", V.get("barBorderRadius") || 0)
            }
            W.useStyle(I.defaults({fill: T, opacity: U}, V.getBarItemStyle()));
            var O = Q.getShallow("cursor");
            O && W.attr("cursor", O);
            var a = R ? (X.height > 0 ? "bottom" : "top") : (X.width > 0 ? "left" : "right");
            if (!P) {
                K.setLabel(W.style, Y, Q, T, b, Z, a)
            }
            G.setHoverStyle(W, Y)
        }

        function M(O, Q) {
            var P = O.get(C) || 0;
            return Math.min(P, Math.abs(Q.width), Math.abs(Q.height))
        }

        L.exports = E
    }, function(D, G, C) {
        var B = C(4);
        var A = C(18);
        var E = {};
        E.setLabel = function(L, I, H, J, P, M, O) {
            var K = H.getModel("label.normal");
            var N = H.getModel("label.emphasis");
            if (K.get("show")) {
                F(L, K, J, B.retrieve(P.getFormattedLabel(M, "normal"), P.getRawValue(M)), O)
            } else {
                L.text = ""
            }
            if (N.get("show")) {
                F(I, N, J, B.retrieve(P.getFormattedLabel(M, "emphasis"), P.getRawValue(M)), O)
            } else {
                I.text = ""
            }
        };

        function F(K, L, J, I, H) {
            A.setText(K, L, J);
            K.text = I;
            if (K.textPosition === "outside") {
                K.textPosition = H
            }
        }

        D.exports = E
    }, function(C, D, B) {
        var A = B(15)([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
        C.exports = {
            getBarItemStyle: function(F) {
                var E = A.call(this, F);
                if (this.getBorderLineDash) {
                    var G = this.getBorderLineDash();
                    G && (E.lineDash = G)
                }
                return E
            }
        }
    }, function(K, M, E) {
        var D = E(4);
        var H = E(7);
        var I = H.parsePercent;
        var A = "__ec_stack_";

        function J(N) {
            return N.get("stack") || A + N.seriesIndex
        }

        function L(N) {
            return N.dim + N.index
        }

        function F(P, U) {
            var R = [];
            var T = P.axis;
            var V = "axis0";
            if (T.type !== "category") {
                return
            }
            var N = T.getBandWidth();
            for (var Q = 0; Q < P.count || 0; Q++) {
                R.push(D.defaults({bandWidth: N, axisKey: V, stackId: A + Q}, P))
            }
            var S = B(R, U);
            var O = [];
            for (var Q = 0; Q < P.count; Q++) {
                var W = S[V][A + Q];
                W.offsetCenter = W.offset + W.width / 2;
                O.push(W)
            }
            return O
        }

        function C(O, P) {
            var N = D.map(O, function(Z) {
                var R = Z.getData();
                var U = Z.coordinateSystem;
                var X = U.getBaseAxis();
                var V = X.getExtent();
                var Q = X.type === "category" ? X.getBandWidth() : (Math.abs(V[1] - V[0]) / R.count());
                var S = I(Z.get("barWidth"), Q);
                var W = I(Z.get("barMaxWidth"), Q);
                var T = Z.get("barGap");
                var Y = Z.get("barCategoryGap");
                return {bandWidth: Q, barWidth: S, barMaxWidth: W, barGap: T, barCategoryGap: Y, axisKey: L(X), stackId: J(Z)}
            });
            return B(N, P)
        }

        function B(O, Q) {
            var P = {};
            D.each(O, function(V, U) {
                var b = V.axisKey;
                var R = V.bandWidth;
                var Z = P[b] || {bandWidth: R, remainedWidth: R, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {}};
                var X = Z.stacks;
                P[b] = Z;
                var W = V.stackId;
                if (!X[W]) {
                    Z.autoWidthCount++
                }
                X[W] = X[W] || {width: 0, maxWidth: 0};
                var T = V.barWidth;
                if (T && !X[W].width) {
                    T = Math.min(Z.remainedWidth, T);
                    X[W].width = T;
                    Z.remainedWidth -= T
                }
                var S = V.barMaxWidth;
                S && (X[W].maxWidth = S);
                var Y = V.barGap;
                (Y != null) && (Z.gap = Y);
                var a = V.barCategoryGap;
                (a != null) && (Z.categoryGap = a)
            });
            var N = {};
            D.each(P, function(Z, T) {
                N[T] = {};
                var X = Z.stacks;
                var R = Z.bandWidth;
                var U = I(Z.categoryGap, R);
                var S = I(Z.gap, 1);
                var V = Z.remainedWidth;
                var W = Z.autoWidthCount;
                var b = (V - U) / (W + (W - 1) * S);
                b = Math.max(b, 0);
                D.each(X, function(f, d) {
                    var e = f.maxWidth;
                    if (e && e < b) {
                        e = Math.min(e, V);
                        if (f.width) {
                            e = Math.min(e, f.width)
                        }
                        V -= e;
                        f.width = e;
                        W--
                    }
                });
                b = (V - U) / (W + (W - 1) * S);
                b = Math.max(b, 0);
                var a = 0;
                var c;
                D.each(X, function(e, d) {
                    if (!e.width) {
                        e.width = b
                    }
                    c = e;
                    a += e.width * (1 + S)
                });
                if (c) {
                    a -= c.width * S
                }
                var Y = -a / 2;
                D.each(X, function(e, d) {
                    N[T][d] = N[T][d] || {offset: Y, width: e.width};
                    Y += e.width * (1 + S)
                })
            });
            return N
        }

        function G(Q, O, R) {
            var S = C(D.filter(O.getSeriesByType(Q), function(T) {
                return !O.isSeriesFiltered(T) && T.coordinateSystem && T.coordinateSystem.type === "cartesian2d"
            }));
            var N = {};
            var P = {};
            O.eachSeriesByType(Q, function(e) {
                if (e.coordinateSystem.type !== "cartesian2d") {
                    return
                }
                var W = e.getData();
                var Y = e.coordinateSystem;
                var c = Y.getBaseAxis();
                var a = J(e);
                var Z = S[L(c)][a];
                var d = Z.offset;
                var X = Z.width;
                var T = Y.getOtherAxis(c);
                var U = e.get("barMinHeight") || 0;
                var V = c.onZero ? T.toGlobalCoord(T.dataToCoord(0)) : T.getGlobalExtent()[0];
                var b = Y.dataToPoints(W, true);
                N[a] = N[a] || [];
                P[a] = P[a] || [];
                W.setLayout({offset: d, size: X});
                W.each(T.dim, function(i, g) {
                    if (isNaN(i)) {
                        return
                    }
                    if (!N[a][g]) {
                        N[a][g] = {p: V, n: V};
                        P[a][g] = {p: V, n: V}
                    }
                    var o = i >= 0 ? "p" : "n";
                    var j = b[g];
                    var l = N[a][g][o];
                    var h = P[a][g][o];
                    var m;
                    var n;
                    var k;
                    var f;
                    if (T.isHorizontal()) {
                        m = l;
                        n = j[1] + d;
                        k = j[0] - h;
                        f = X;
                        P[a][g][o] += k;
                        if (Math.abs(k) < U) {
                            k = (k < 0 ? -1 : 1) * U
                        }
                        N[a][g][o] += k
                    } else {
                        m = j[0] + d;
                        n = l;
                        k = X;
                        f = j[1] - h;
                        P[a][g][o] += f;
                        if (Math.abs(f) < U) {
                            f = (f <= 0 ? -1 : 1) * U
                        }
                        N[a][g][o] += f
                    }
                    W.setItemLayout(g, {x: m, y: n, width: k, height: f})
                }, true)
            }, this)
        }

        G.getLayoutOnAxis = F;
        K.exports = G
    }, function(C, E, B) {
        var A = B(4);
        var D = B(1);
        B(147);
        B(149);
        B(150)("pie", [{type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected"}, {
            type: "pieSelect",
            event: "pieselected",
            method: "select"
        }, {type: "pieUnSelect", event: "pieunselected", method: "unSelect"}]);
        D.registerVisual(A.curry(B(151), "pie"));
        D.registerLayout(A.curry(B(152), "pie"));
        D.registerProcessor(A.curry(B(154), "pie"))
    }, function(H, J, D) {
        var I = D(98);
        var C = D(4);
        var B = D(5);
        var F = D(7);
        var A = D(110);
        var E = D(148);
        var G = D(1).extendSeriesModel({
            type: "series.pie",
            init: function(K) {
                G.superApply(this, "init", arguments);
                this.legendDataProvider = function() {
                    return this.getRawData()
                };
                this.updateSelectedMap(K.data);
                this._defaultLabelLine(K)
            },
            mergeOption: function(K) {
                G.superCall(this, "mergeOption", K);
                this.updateSelectedMap(this.option.data)
            },
            getInitialData: function(L, M) {
                var N = A(["value"], L.data);
                var K = new I(N, this);
                K.initData(L.data);
                return K
            },
            getDataParams: function(K) {
                var N = this.getData();
                var M = G.superCall(this, "getDataParams", K);
                var L = [];
                N.each("value", function(O) {
                    L.push(O)
                });
                M.percent = F.getPercentWithPrecision(L, K, N.hostModel.get("percentPrecision"));
                M.$vars.push("percent");
                return M
            },
            _defaultLabelLine: function(K) {
                B.defaultEmphasis(K.labelLine, ["show"]);
                var L = K.labelLine.normal;
                var M = K.labelLine.emphasis;
                L.show = L.show && K.label.normal.show;
                M.show = M.show && K.label.emphasis.show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: true,
                hoverAnimation: true,
                center: ["50%", "50%"],
                radius: [0, "75%"],
                clockwise: true,
                startAngle: 90,
                minAngle: 0,
                selectedOffset: 10,
                avoidLabelOverlap: true,
                percentPrecision: 2,
                stillShowZeroSum: true,
                label: {normal: {rotate: false, show: true, position: "outer"}, emphasis: {}},
                labelLine: {normal: {show: true, length: 15, length2: 15, smooth: false, lineStyle: {width: 1, type: "solid"}}},
                itemStyle: {normal: {borderWidth: 1}, emphasis: {}},
                animationType: "expansion",
                animationEasing: "cubicOut",
                data: []
            }
        });
        C.mixin(G, E);
        H.exports = G
    }, function(C, D, B) {
        var A = B(4);
        C.exports = {
            updateSelectedMap: function(E) {
                this._selectTargetMap = A.reduce(E || [], function(F, G) {
                    F.set(G.name, G);
                    return F
                }, A.createHashMap())
            }, select: function(G) {
                var E = this._selectTargetMap;
                var H = E.get(G);
                var F = this.get("selectedMode");
                if (F === "single") {
                    E.each(function(I) {
                        I.selected = false
                    })
                }
                H && (H.selected = true)
            }, unSelect: function(E) {
                var F = this._selectTargetMap.get(E);
                F && (F.selected = false)
            }, toggleSelected: function(E) {
                var F = this._selectTargetMap.get(E);
                if (F != null) {
                    this[F.selected ? "unSelect" : "select"](E);
                    return F.selected
                }
            }, isSelected: function(E) {
                var F = this._selectTargetMap.get(E);
                return F && F.selected
            }
        }
    }, function(J, K, D) {
        var E = D(18);
        var H = D(4);

        function C(O, S, N, R) {
            var M = S.getData();
            var P = this.dataIndex;
            var L = M.getName(P);
            var Q = S.get("selectedOffset");
            R.dispatchAction({type: "pieToggleSelect", from: O, name: L, seriesId: S.id});
            M.each(function(T) {
                G(M.getItemGraphicEl(T), M.getItemLayout(T), S.isSelected(M.getName(T)), Q, N)
            })
        }

        function G(N, O, U, T, M) {
            var S = (O.startAngle + O.endAngle) / 2;
            var R = Math.cos(S);
            var P = Math.sin(S);
            var L = U ? T : 0;
            var Q = [R * L, P * L];
            M ? N.animate().when(200, {position: Q}).start("bounceOut") : N.attr("position", Q)
        }

        function F(R, P) {
            E.Group.call(this);
            var L = new E.Sector({z2: 2});
            var O = new E.Polyline();
            var N = new E.Text();
            this.add(L);
            this.add(O);
            this.add(N);
            this.updateData(R, P, true);

            function Q() {
                O.ignore = O.hoverIgnore;
                N.ignore = N.hoverIgnore
            }

            function M() {
                O.ignore = O.normalIgnore;
                N.ignore = N.normalIgnore
            }

            this.on("emphasis", Q).on("normal", M).on("mouseover", Q).on("mouseout", M)
        }

        var I = F.prototype;

        function B(R, Q, O, N, L) {
            var M = N.getModel("textStyle");
            var P = L === "inside" || L === "inner";
            return {
                fill: M.getTextColor() || (P ? "#fff" : R.getItemVisual(Q, "color")),
                opacity: R.getItemVisual(Q, "opacity"),
                textFont: M.getFont(),
                text: H.retrieve(R.hostModel.getFormattedLabel(Q, O), R.getName(Q))
            }
        }

        I.updateData = function(O, Q, P) {
            var R = this.childAt(0);
            var Y = O.hostModel;
            var M = O.getItemModel(Q);
            var S = O.getItemLayout(Q);
            var U = H.extend({}, S);
            U.label = null;
            if (P) {
                R.setShape(U);
                var X = Y.getShallow("animationType");
                if (X === "scale") {
                    R.shape.r = S.r0;
                    E.initProps(R, {shape: {r: S.r}}, Y, Q)
                } else {
                    R.shape.endAngle = S.startAngle;
                    E.updateProps(R, {shape: {endAngle: S.endAngle}}, Y, Q)
                }
            } else {
                E.updateProps(R, {shape: U}, Y, Q)
            }
            var V = M.getModel("itemStyle");
            var W = O.getItemVisual(Q, "color");
            R.useStyle(H.defaults({lineJoin: "bevel", fill: W}, V.getModel("normal").getItemStyle()));
            R.hoverStyle = V.getModel("emphasis").getItemStyle();
            var L = M.getShallow("cursor");
            L && R.attr("cursor", L);
            G(this, O.getItemLayout(Q), M.get("selected"), Y.get("selectedOffset"), Y.get("animation"));

            function N() {
                R.stopAnimation(true);
                R.animateTo({shape: {r: S.r + 10}}, 300, "elasticOut")
            }

            function T() {
                R.stopAnimation(true);
                R.animateTo({shape: {r: S.r}}, 300, "elasticOut")
            }

            R.off("mouseover").off("mouseout").off("emphasis").off("normal");
            if (M.get("hoverAnimation") && Y.isAnimationEnabled()) {
                R.on("mouseover", N).on("mouseout", T).on("emphasis", N).on("normal", T)
            }
            this._updateLabel(O, Q);
            E.setHoverStyle(this)
        };
        I._updateLabel = function(P, S) {
            var M = this.childAt(1);
            var O = this.childAt(2);
            var Z = P.hostModel;
            var N = P.getItemModel(S);
            var V = P.getItemLayout(S);
            var R = V.label;
            var X = P.getItemVisual(S, "color");
            E.updateProps(M, {shape: {points: R.linePoints || [[R.x, R.y], [R.x, R.y], [R.x, R.y]]}}, Z, S);
            E.updateProps(O, {style: {x: R.x, y: R.y}}, Z, S);
            O.attr({
                style: {textVerticalAlign: R.verticalAlign, textAlign: R.textAlign, textFont: R.font},
                rotation: R.rotation,
                origin: [R.x, R.y],
                z2: 10
            });
            var U = N.getModel("label.normal");
            var T = N.getModel("label.emphasis");
            var Y = N.getModel("labelLine.normal");
            var L = N.getModel("labelLine.emphasis");
            var Q = U.get("position") || T.get("position");
            O.setStyle(B(P, S, "normal", U, Q));
            O.ignore = O.normalIgnore = !U.get("show");
            O.hoverIgnore = !T.get("show");
            M.ignore = M.normalIgnore = !Y.get("show");
            M.hoverIgnore = !L.get("show");
            M.setStyle({stroke: X, opacity: P.getItemVisual(S, "opacity")});
            M.setStyle(Y.getModel("lineStyle").getLineStyle());
            O.hoverStyle = B(P, S, "emphasis", T, Q);
            M.hoverStyle = L.getModel("lineStyle").getLineStyle();
            var W = Y.get("smooth");
            if (W && W === true) {
                W = 0.4
            }
            M.setShape({smooth: W})
        };
        H.inherits(F, E.Group);
        var A = D(80).extend({
            type: "pie", init: function() {
                var L = new E.Group();
                this._sectorGroup = L
            }, render: function(Z, N, X, O) {
                if (O && (O.from === this.uid)) {
                    return
                }
                var P = Z.getData();
                var R = this._data;
                var T = this.group;
                var S = N.get("animation");
                var V = !R;
                var Y = Z.get("animationType");
                var W = H.curry(C, this.uid, Z, S, X);
                var M = Z.get("selectedMode");
                P.diff(R).add(function(a) {
                    var b = new F(P, a);
                    if (V && Y !== "scale") {
                        b.eachChild(function(c) {
                            c.stopAnimation(true)
                        })
                    }
                    M && b.on("click", W);
                    P.setItemGraphicEl(a, b);
                    T.add(b)
                }).update(function(a, b) {
                    var c = R.getItemGraphicEl(b);
                    c.updateData(P, a);
                    c.off("click");
                    M && c.on("click", W);
                    T.add(c);
                    P.setItemGraphicEl(a, c)
                }).remove(function(a) {
                    var b = R.getItemGraphicEl(a);
                    T.remove(b)
                }).execute();
                if (S && V && P.count() > 0 && Y !== "scale") {
                    var L = P.getItemLayout(0);
                    var Q = Math.max(X.getWidth(), X.getHeight()) / 2;
                    var U = H.bind(T.removeClipPath, T);
                    T.setClipPath(this._createClipPath(L.cx, L.cy, Q, L.startAngle, L.clockwise, U, Z))
                }
                this._data = P
            }, dispose: function() {
            }, _createClipPath: function(Q, O, L, S, N, M, P) {
                var R = new E.Sector({shape: {cx: Q, cy: O, r0: 0, r: L, startAngle: S, endAngle: S, clockwise: N}});
                E.initProps(R, {shape: {endAngle: S + (N ? 1 : -1) * Math.PI * 2}}, P, M);
                return R
            }, containPoint: function(M, L) {
                var R = L.getData();
                var Q = R.getItemLayout(0);
                if (Q) {
                    var N = M[0] - Q.cx;
                    var P = M[1] - Q.cy;
                    var O = Math.sqrt(N * N + P * P);
                    return O <= Q.r && O >= Q.r0
                }
            }
        });
        J.exports = A
    }, function(C, E, B) {
        var D = B(1);
        var A = B(4);
        C.exports = function(G, F) {
            A.each(F, function(H) {
                H.update = "updateView";
                D.registerAction(H, function(J, I) {
                    var K = {};
                    I.eachComponent({mainType: "series", subType: G, query: J}, function(L) {
                        if (L[H.method]) {
                            L[H.method](J.name)
                        }
                        var M = L.getData();
                        M.each(function(O) {
                            var N = M.getName(O);
                            K[N] = L.isSelected(N) || false
                        })
                    });
                    return {name: J.name, selected: K}
                })
            })
        }
    }, function(A, B) {
        A.exports = function(D, C) {
            var E = {};
            C.eachRawSeriesByType(D, function(F) {
                var G = F.getRawData();
                var H = {};
                if (!C.isSeriesFiltered(F)) {
                    var I = F.getData();
                    I.each(function(K) {
                        var J = I.getRawIndex(K);
                        H[J] = K
                    });
                    G.each(function(J) {
                        var M = H[J];
                        var L = M != null && I.getItemVisual(M, "color", true);
                        if (!L) {
                            var K = G.getItemModel(J);
                            var N = K.get("itemStyle.normal.color") || F.getColorFromPalette(G.getName(J), E);
                            G.setItemVisual(J, "color", N);
                            if (M != null) {
                                I.setItemVisual(M, "color", N)
                            }
                        } else {
                            G.setItemVisual(J, "color", L)
                        }
                    })
                }
            })
        }
    }, function(H, I, D) {
        var E = D(7);
        var F = E.parsePercent;
        var B = D(153);
        var C = D(4);
        var A = Math.PI * 2;
        var G = Math.PI / 180;
        H.exports = function(L, J, M, K) {
            J.eachSeriesByType(L, function(U) {
                var k = U.get("center");
                var S = U.get("radius");
                if (!C.isArray(S)) {
                    S = [0, S]
                }
                if (!C.isArray(k)) {
                    k = [k, k]
                }
                var c = M.getWidth();
                var j = M.getHeight();
                var R = Math.min(c, j);
                var Q = F(k[0], c);
                var d = F(k[1], j);
                var Y = F(S[0], R / 2);
                var N = F(S[1], R / 2);
                var h = U.getData();
                var W = -U.get("startAngle") * G;
                var f = U.get("minAngle") * G;
                var O = 0;
                h.each("value", function(m) {
                    !isNaN(m) && O++
                });
                var X = h.getSum("value");
                var V = Math.PI / (X || O) * 2;
                var P = U.get("clockwise");
                var i = U.get("roseType");
                var b = U.get("stillShowZeroSum");
                var e = h.getDataExtent("value");
                e[0] = 0;
                var g = A;
                var T = 0;
                var a = W;
                var Z = P ? 1 : -1;
                h.each("value", function(o, n) {
                    var p;
                    if (isNaN(o)) {
                        h.setItemLayout(n, {angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: P, cx: Q, cy: d, r0: Y, r: i ? NaN : N});
                        return
                    }
                    if (i !== "area") {
                        p = (X === 0 && b) ? V : (o * V)
                    } else {
                        p = A / O
                    }
                    if (p < f) {
                        p = f;
                        g -= f
                    } else {
                        T += o
                    }
                    var m = a + Z * p;
                    h.setItemLayout(n, {
                        angle: p,
                        startAngle: a,
                        endAngle: m,
                        clockwise: P,
                        cx: Q,
                        cy: d,
                        r0: Y,
                        r: i ? E.linearMap(o, e, [Y, N]) : N
                    });
                    a = m
                }, true);
                if (g < A && O) {
                    if (g <= 0.001) {
                        var l = A / O;
                        h.each("value", function(n, m) {
                            if (!isNaN(n)) {
                                var o = h.getItemLayout(m);
                                o.angle = l;
                                o.startAngle = W + Z * m * l;
                                o.endAngle = W + Z * (m + 1) * l
                            }
                        })
                    } else {
                        V = g / T;
                        a = W;
                        h.each("value", function(o, m) {
                            if (!isNaN(o)) {
                                var p = h.getItemLayout(m);
                                var n = p.angle === f ? f : o * V;
                                p.startAngle = a;
                                p.endAngle = a + Z * n;
                                a += Z * n
                            }
                        })
                    }
                }
                B(U, N, c, j)
            })
        }
    }, function(C, F, B) {
        var E = B(8);

        function A(J, N, M, G, I, P, V) {
            J.sort(function(X, W) {
                return X.y - W.y
            });

            function R(Z, Y, X, W) {
                for (var a = Z; a < Y; a++) {
                    J[a].y += X;
                    if (a > Z && a + 1 < Y && J[a + 1].y > J[a].y + J[a].height) {
                        L(a, X / 2);
                        return
                    }
                }
                L(Y - 1, X / 2)
            }

            function L(X, W) {
                for (var Y = X; Y >= 0; Y--) {
                    J[Y].y -= W;
                    if (Y > 0 && J[Y].y > J[Y - 1].y + J[Y - 1].height) {
                        break
                    }
                }
            }

            function Q(Z, f, d, b, W, Y) {
                var a = Y > 0 ? f ? Number.MAX_VALUE : 0 : f ? Number.MAX_VALUE : 0;
                for (var e = 0, g = Z.length; e < g; e++) {
                    if (Z[e].position === "center") {
                        continue
                    }
                    var X = Math.abs(Z[e].y - b);
                    var c = Z[e].len;
                    var h = Z[e].len2;
                    var j = (X < W + c) ? Math.sqrt((W + c + h) * (W + c + h) - X * X) : Math.abs(Z[e].x - d);
                    if (f && j >= a) {
                        j = a - 10
                    }
                    if (!f && j <= a) {
                        j = a + 10
                    }
                    Z[e].x = d + j * Y;
                    a = j
                }
            }

            var T = 0;
            var S;
            var H = J.length;
            var O = [];
            var K = [];
            for (var U = 0; U < H; U++) {
                S = J[U].y - T;
                if (S < 0) {
                    R(U, H, -S, I)
                }
                T = J[U].y + J[U].height
            }
            if (V - T < 0) {
                L(H - 1, T - V)
            }
            for (var U = 0; U < H; U++) {
                if (J[U].y >= M) {
                    K.push(J[U])
                } else {
                    O.push(J[U])
                }
            }
            Q(O, false, N, M, G, I);
            Q(K, true, N, M, G, I)
        }

        function D(H, K, I, G, M, Q) {
            var P = [];
            var L = [];
            for (var O = 0; O < H.length; O++) {
                if (H[O].x < K) {
                    P.push(H[O])
                } else {
                    L.push(H[O])
                }
            }
            A(L, K, I, G, 1, M, Q);
            A(P, K, I, G, -1, M, Q);
            for (var O = 0; O < H.length; O++) {
                var J = H[O].linePoints;
                if (J) {
                    var N = J[1][0] - J[2][0];
                    if (H[O].x < K) {
                        J[2][0] = H[O].x + 3
                    } else {
                        J[2][0] = H[O].x - 3
                    }
                    J[1][1] = J[2][1] = H[O].y;
                    J[1][0] = J[2][0] + N
                }
            }
        }

        C.exports = function(O, G, L, N) {
            var I = O.getData();
            var H = [];
            var K;
            var J;
            var M = false;
            I.each(function(l) {
                var X = I.getItemLayout(l);
                var T = I.getItemModel(l);
                var Q = T.getModel("label.normal");
                var P = Q.get("position") || T.get("label.emphasis.position");
                var i = T.getModel("labelLine.normal");
                var g = i.get("length");
                var c = i.get("length2");
                var k = (X.startAngle + X.endAngle) / 2;
                var V = Math.cos(k);
                var f = Math.sin(k);
                var j;
                var d;
                var U;
                var Y;
                K = X.cx;
                J = X.cy;
                var W = P === "inside" || P === "inner";
                if (P === "center") {
                    j = X.cx;
                    d = X.cy;
                    Y = "center"
                } else {
                    var S = (W ? (X.r + X.r0) / 2 * V : X.r * V) + K;
                    var h = (W ? (X.r + X.r0) / 2 * f : X.r * f) + J;
                    j = S + V * 3;
                    d = h + f * 3;
                    if (!W) {
                        var m = S + V * (g + G - X.r);
                        var n = h + f * (g + G - X.r);
                        var e = m + ((V < 0 ? -1 : 1) * c);
                        var Z = n;
                        j = e + (V < 0 ? -5 : 5);
                        d = Z;
                        U = [[S, h], [m, n], [e, Z]]
                    }
                    Y = W ? "center" : (V > 0 ? "left" : "right")
                }
                var o = Q.getModel("textStyle").getFont();
                var R = Q.get("rotate") ? (V < 0 ? -k + Math.PI : -k) : 0;
                var b = O.getFormattedLabel(l, "normal") || I.getName(l);
                var a = E.getBoundingRect(b, o, Y, "top");
                M = !!R;
                X.label = {
                    x: j,
                    y: d,
                    position: P,
                    height: a.height,
                    len: g,
                    len2: c,
                    linePoints: U,
                    textAlign: Y,
                    verticalAlign: "middle",
                    font: o,
                    rotation: R
                };
                if (!W) {
                    H.push(X.label)
                }
            });
            if (!M && O.get("avoidLabelOverlap")) {
                D(H, K, J, G, L, N)
            }
        }
    }, function(A, B) {
        A.exports = function(D, C) {
            var E = C.findComponents({mainType: "legend"});
            if (!E || !E.length) {
                return
            }
            C.eachSeriesByType(D, function(F) {
                var G = F.getData();
                G.filterSelf(function(J) {
                    var I = G.getName(J);
                    for (var H = 0; H < E.length; H++) {
                        if (!E[H].isSelected(I)) {
                            return false
                        }
                    }
                    return true
                }, this)
            }, this)
        }
    }, function(C, E, B) {
        var A = B(4);
        var D = B(1);
        B(156);
        B(157);
        D.registerVisual(A.curry(B(121), "scatter", "circle", null));
        D.registerLayout(A.curry(B(122), "scatter"));
        B(124)
    }, function(C, E, A) {
        var B = A(109);
        var D = A(78);
        C.exports = D.extend({
            type: "series.scatter",
            dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
            getInitialData: function(F, G) {
                return B(F.data, this, G)
            },
            brushSelector: "point",
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: true,
                hoverAnimation: true,
                symbolSize: 10,
                large: false,
                largeThreshold: 2000,
                itemStyle: {normal: {opacity: 0.8}}
            }
        })
    }, function(C, E, B) {
        var A = B(116);
        var D = B(158);
        B(1).extendChartView({
            type: "scatter", init: function() {
                this._normalSymbolDraw = new A();
                this._largeSymbolDraw = new D()
            }, render: function(M, F, L) {
                var G = M.getData();
                var J = this._largeSymbolDraw;
                var H = this._normalSymbolDraw;
                var I = this.group;
                var K = M.get("large") && G.count() > M.get("largeThreshold") ? J : H;
                this._symbolDraw = K;
                K.updateData(G);
                I.add(K.group);
                I.remove(K === J ? H.group : J.group)
            }, updateLayout: function(F) {
                this._symbolDraw.updateLayout(F)
            }, remove: function(F, G) {
                this._symbolDraw && this._symbolDraw.remove(G, true)
            }, dispose: function() {
            }
        })
    }, function(B, H, C) {
        var E = C(18);
        var F = C(111);
        var A = E.extendShape({
            shape: {points: null, sizes: null}, symbolProxy: null, buildPath: function(P, J) {
                var Q = J.points;
                var N = J.sizes;
                var K = this.symbolProxy;
                var M = K.shape;
                for (var O = 0; O < Q.length; O++) {
                    var I = Q[O];
                    if (isNaN(I[0]) || isNaN(I[1])) {
                        continue
                    }
                    var L = N[O];
                    if (L[0] < 4) {
                        P.rect(I[0] - L[0] / 2, I[1] - L[1] / 2, L[0], L[1])
                    } else {
                        M.x = I[0] - L[0] / 2;
                        M.y = I[1] - L[1] / 2;
                        M.width = L[0];
                        M.height = L[1];
                        K.buildPath(P, M, true)
                    }
                }
            }, findDataIndex: function(Q, R) {
                var K = this.shape;
                var J = K.points;
                var P = K.sizes;
                for (var O = J.length - 1; O >= 0; O--) {
                    var I = J[O];
                    var N = P[O];
                    var L = I[0] - N[0] / 2;
                    var M = I[1] - N[1] / 2;
                    if (Q >= L && R >= M && Q <= L + N[0] && R <= M + N[1]) {
                        return O
                    }
                }
                return -1
            }
        });

        function G() {
            this.group = new E.Group();
            this._symbolEl = new A({})
        }

        var D = G.prototype;
        D.updateData = function(L) {
            this.group.removeAll();
            var K = this._symbolEl;
            var I = L.hostModel;
            K.setShape({
                points: L.mapArray(L.getItemLayout), sizes: L.mapArray(function(N) {
                    var M = L.getItemVisual(N, "symbolSize");
                    if (!(M instanceof Array)) {
                        M = [M, M]
                    }
                    return M
                })
            });
            K.symbolProxy = F.createSymbol(L.getVisual("symbol"), 0, 0, 0, 0);
            K.setColor = K.symbolProxy.setColor;
            K.useStyle(I.getModel("itemStyle.normal").getItemStyle(["color"]));
            var J = L.getVisual("color");
            if (J) {
                K.setColor(J)
            }
            K.seriesIndex = I.seriesIndex;
            K.on("mousemove", function(N) {
                K.dataIndex = null;
                var M = K.findDataIndex(N.offsetX, N.offsetY);
                if (M >= 0) {
                    K.dataIndex = M
                }
            });
            this.group.add(K)
        };
        D.updateLayout = function(I) {
            var J = I.getData();
            this._symbolEl.setShape({points: J.mapArray(J.getItemLayout)})
        };
        D.remove = function() {
            this.group.removeAll()
        };
        B.exports = G
    }, function(C, E, B) {
        var A = B(4);
        var D = B(1);
        B(160);
        B(165);
        B(166);
        D.registerVisual(A.curry(B(151), "radar"));
        D.registerVisual(A.curry(B(121), "radar", "circle", null));
        D.registerLayout(B(167));
        D.registerProcessor(A.curry(B(154), "radar"));
        D.registerPreprocessor(B(168))
    }, function(B, C, A) {
        A(161);
        A(163);
        A(164)
    }, function(H, I, D) {
        var G = D(4);
        var C = D(162);
        var A = D(104);
        var E = D(7);
        var F = D(101);

        function B(K, J, L) {
            this._model = K;
            this.dimensions = [];
            this._indicatorAxes = G.map(K.getIndicatorModels(), function(P, O) {
                var N = "indicator_" + O;
                var M = new C(N, new A());
                M.name = P.get("name");
                M.model = P;
                P.axis = M;
                this.dimensions.push(N);
                return M
            }, this);
            this.resize(K, L);
            this.cx;
            this.cy;
            this.r;
            this.startAngle
        }

        B.prototype.getIndicatorAxes = function() {
            return this._indicatorAxes
        };
        B.prototype.dataToPoint = function(K, L) {
            var J = this._indicatorAxes[L];
            return this.coordToPoint(J.dataToCoord(K), L)
        };
        B.prototype.coordToPoint = function(K, N) {
            var J = this._indicatorAxes[N];
            var O = J.angle;
            var L = this.cx + K * Math.cos(O);
            var M = this.cy - K * Math.sin(O);
            return [L, M]
        };
        B.prototype.pointToData = function(J) {
            var R = J[0] - this.cx;
            var O = J[1] - this.cy;
            var P = Math.sqrt(R * R + O * O);
            R /= P;
            O /= P;
            var M = Math.atan2(-O, R);
            var K = Infinity;
            var T;
            var S = -1;
            for (var N = 0; N < this._indicatorAxes.length; N++) {
                var Q = this._indicatorAxes[N];
                var L = Math.abs(M - Q.angle);
                if (L < K) {
                    T = Q;
                    S = N;
                    K = L
                }
            }
            return [S, +(T && T.coodToData(P))]
        };
        B.prototype.resize = function(N, O) {
            var K = N.get("center");
            var M = O.getWidth();
            var J = O.getHeight();
            var L = Math.min(M, J) / 2;
            this.cx = E.parsePercent(K[0], M);
            this.cy = E.parsePercent(K[1], J);
            this.startAngle = N.get("startAngle") * Math.PI / 180;
            this.r = E.parsePercent(N.get("radius"), L);
            G.each(this._indicatorAxes, function(P, Q) {
                P.setExtent(0, this.r);
                var R = (this.startAngle + Q * Math.PI * 2 / this._indicatorAxes.length);
                R = Math.atan2(Math.sin(R), Math.cos(R));
                P.angle = R
            }, this)
        };
        B.prototype.update = function(K, O) {
            var J = this._indicatorAxes;
            var L = this._model;
            G.each(J, function(P) {
                P.scale.setExtent(Infinity, -Infinity)
            });
            K.eachSeriesByType("radar", function(P, Q) {
                if (P.get("coordinateSystem") !== "radar" || K.getComponent("radar", P.get("radarIndex")) !== L) {
                    return
                }
                var R = P.getData();
                G.each(J, function(S) {
                    S.scale.unionExtentFromData(R, S.dim)
                })
            }, this);
            var M = L.get("splitNumber");

            function N(P) {
                var Q = Math.pow(10, Math.floor(Math.log(P) / Math.LN10));
                var R = P / Q;
                if (R === 2) {
                    R = 5
                } else {
                    R *= 2
                }
                return R * Q
            }

            G.each(J, function(Q, V) {
                var P = F.getScaleExtent(Q.scale, Q.model);
                F.niceScaleExtent(Q.scale, Q.model);
                var T = Q.model;
                var S = Q.scale;
                var a = T.getMin();
                var X = T.getMax();
                var Y = S.getInterval();
                if (a != null && X != null) {
                    S.setExtent(+a, +X);
                    S.setInterval((X - a) / M)
                } else {
                    if (a != null) {
                        var b;
                        do {
                            b = a + Y * M;
                            S.setExtent(+a, b);
                            S.setInterval(Y);
                            Y = N(Y)
                        } while (b < P[1] && isFinite(b) && isFinite(P[1]))
                    } else {
                        if (X != null) {
                            var R;
                            do {
                                R = X - Y * M;
                                S.setExtent(R, +X);
                                S.setInterval(Y);
                                Y = N(Y)
                            } while (R > P[0] && isFinite(R) && isFinite(P[0]))
                        } else {
                            var U = S.getTicks().length - 1;
                            if (U > M) {
                                Y = N(Y)
                            }
                            var Z = Math.round((P[0] + P[1]) / 2 / Y) * Y;
                            var W = Math.round(M / 2);
                            S.setExtent(E.round(Z - W * Y), E.round(Z + (M - W) * Y));
                            S.setInterval(Y)
                        }
                    }
                }
            })
        };
        B.dimensions = [];
        B.create = function(K, L) {
            var J = [];
            K.eachComponent("radar", function(M) {
                var N = new B(M, K, L);
                J.push(N);
                M.coordinateSystem = N
            });
            K.eachSeriesByType("radar", function(M) {
                if (M.get("coordinateSystem") === "radar") {
                    M.coordinateSystem = J[M.get("radarIndex") || 0]
                }
            });
            return J
        };
        D(76).register("radar", B);
        H.exports = B
    }, function(C, F, B) {
        var A = B(4);
        var E = B(100);

        function D(H, I, G) {
            E.call(this, H, I, G);
            this.type = "value";
            this.angle = 0;
            this.name = "";
            this.model
        }

        A.inherits(D, E);
        C.exports = D
    }, function(H, J, D) {
        var A = D(132);
        var F = A.valueAxis;
        var G = D(12);
        var C = D(4);
        var I = D(112);

        function B(K, L) {
            return C.defaults({show: L}, K)
        }

        var E = D(1).extendComponentModel({
            type: "radar",
            optionUpdated: function() {
                var P = this.get("boundaryGap");
                var R = this.get("splitNumber");
                var L = this.get("scale");
                var T = this.get("axisLine");
                var N = this.get("axisTick");
                var O = this.get("axisLabel");
                var K = this.get("name.textStyle");
                var S = this.get("name.show");
                var M = this.get("name.formatter");
                var U = this.get("nameGap");
                var V = this.get("triggerEvent");
                var Q = C.map(this.get("indicator") || [], function(W) {
                    if (W.max != null && W.max > 0 && !W.min) {
                        W.min = 0
                    } else {
                        if (W.min != null && W.min < 0 && !W.max) {
                            W.max = 0
                        }
                    }
                    W = C.merge(C.clone(W), {
                        boundaryGap: P,
                        splitNumber: R,
                        scale: L,
                        axisLine: T,
                        axisTick: N,
                        axisLabel: O,
                        name: W.text,
                        nameLocation: "end",
                        nameGap: U,
                        nameTextStyle: K,
                        triggerEvent: V
                    }, false);
                    if (!S) {
                        W.name = ""
                    }
                    if (typeof M === "string") {
                        var X = W.name;
                        W.name = M.replace("{value}", X != null ? X : "")
                    } else {
                        if (typeof M === "function") {
                            W.name = M(W.name, W)
                        }
                    }
                    var Y = C.extend(new G(W, null, this.ecModel), I);
                    Y.mainType = "radar";
                    Y.componentIndex = this.componentIndex;
                    return Y
                }, this);
                this.getIndicatorModels = function() {
                    return Q
                }
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                center: ["50%", "50%"],
                radius: "75%",
                startAngle: 90,
                name: {show: true},
                boundaryGap: [0, 0],
                splitNumber: 5,
                nameGap: 15,
                scale: false,
                shape: "polygon",
                axisLine: C.merge({lineStyle: {color: "#bbb"}}, F.axisLine),
                axisLabel: B(F.axisLabel, false),
                axisTick: B(F.axisTick, false),
                splitLine: B(F.splitLine, true),
                splitArea: B(F.splitArea, true),
                indicator: []
            }
        });
        H.exports = E
    }, function(D, G, C) {
        var F = C(135);
        var B = C(4);
        var A = C(18);
        var E = ["axisLine", "axisLabel", "axisTick", "axisName"];
        D.exports = C(1).extendComponentView({
            type: "radar", render: function(J, I, K) {
                var H = this.group;
                H.removeAll();
                this._buildAxes(J);
                this._buildSplitLineAndArea(J)
            }, _buildAxes: function(J) {
                var K = J.coordinateSystem;
                var I = K.getIndicatorAxes();
                var H = B.map(I, function(L) {
                    var M = new F(L.model, {position: [K.cx, K.cy], rotation: L.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1});
                    return M
                });
                B.each(H, function(L) {
                    B.each(E, L.add, L);
                    this.group.add(L.getGroup())
                }, this)
            }, _buildSplitLineAndArea: function(g) {
                var H = g.coordinateSystem;
                var W = H.getIndicatorAxes();
                if (!W.length) {
                    return
                }
                var V = g.get("shape");
                var Q = g.getModel("splitLine");
                var d = g.getModel("splitArea");
                var I = Q.getModel("lineStyle");
                var c = d.getModel("areaStyle");
                var f = Q.get("show");
                var e = d.get("show");
                var J = I.get("color");
                var X = c.get("color");
                J = B.isArray(J) ? J : [J];
                X = B.isArray(X) ? X : [X];
                var M = [];
                var Z = [];

                function a(i, j, k) {
                    var l = k % j.length;
                    i[l] = i[l] || [];
                    return l
                }

                if (V === "circle") {
                    var K = W[0].getTicksCoords();
                    var N = H.cx;
                    var b = H.cy;
                    for (var P = 0; P < K.length; P++) {
                        if (f) {
                            var S = a(M, J, P);
                            M[S].push(new A.Circle({shape: {cx: N, cy: b, r: K[P]}}))
                        }
                        if (e && P < K.length - 1) {
                            var S = a(Z, X, P);
                            Z[S].push(new A.Ring({shape: {cx: N, cy: b, r0: K[P], r: K[P + 1]}}))
                        }
                    }
                } else {
                    var T;
                    var O = B.map(W, function(i, k) {
                        var j = i.getTicksCoords();
                        T = T == null ? j.length - 1 : Math.min(j.length - 1, T);
                        return B.map(j, function(l) {
                            return H.coordToPoint(l, k)
                        })
                    });
                    var h = [];
                    for (var P = 0; P <= T; P++) {
                        var Y = [];
                        for (var U = 0; U < W.length; U++) {
                            Y.push(O[U][P])
                        }
                        if (Y[0]) {
                            Y.push(Y[0].slice())
                        } else {
                            if (true) {
                                console.error("Can't draw value axis " + P)
                            }
                        }
                        if (f) {
                            var S = a(M, J, P);
                            M[S].push(new A.Polyline({shape: {points: Y}}))
                        }
                        if (e && h) {
                            var S = a(Z, X, P - 1);
                            Z[S].push(new A.Polygon({shape: {points: Y.concat(h)}}))
                        }
                        h = Y.slice().reverse()
                    }
                }
                var R = I.getLineStyle();
                var L = c.getAreaStyle();
                B.each(Z, function(j, i) {
                    this.group.add(A.mergePath(j, {style: B.defaults({stroke: "none", fill: X[i % X.length]}, L), silent: true}))
                }, this);
                B.each(M, function(j, i) {
                    this.group.add(A.mergePath(j, {style: B.defaults({fill: "none", stroke: J[i % J.length]}, R), silent: true}))
                }, this)
            }
        })
    }, function(G, I, C) {
        var E = C(78);
        var H = C(98);
        var A = C(110);
        var B = C(4);
        var F = C(6).encodeHTML;
        var D = E.extend({
            type: "series.radar",
            dependencies: ["radar"],
            init: function(J) {
                D.superApply(this, "init", arguments);
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
            },
            getInitialData: function(K, L) {
                var N = K.data || [];
                var M = A([], N, {extraPrefix: "indicator_", extraFromZero: true});
                var J = new H(M, this);
                J.initData(N);
                return J
            },
            formatTooltip: function(J) {
                var N = this.getRawValue(J);
                var L = this.coordinateSystem;
                var K = L.getIndicatorAxes();
                var M = this.getData().getName(J);
                return F(M === "" ? this.name : M) + "<br/>" + B.map(K, function(P, O) {
                    return F(P.name + " : " + N[O])
                }).join("<br />")
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "radar",
                legendHoverLink: true,
                radarIndex: 0,
                lineStyle: {normal: {width: 2, type: "solid"}},
                label: {normal: {position: "top"}},
                symbol: "emptyCircle",
                symbolSize: 4
            }
        });
        G.exports = D
    }, function(D, G, C) {
        var A = C(18);
        var B = C(4);
        var F = C(111);

        function E(H) {
            if (!B.isArray(H)) {
                H = [+H, +H]
            }
            return H
        }

        D.exports = C(1).extendChartView({
            type: "radar", render: function(Q, J, P) {
                var I = Q.coordinateSystem;
                var N = this.group;
                var K = Q.getData();
                var L = this._data;

                function H(V, T) {
                    var R = V.getItemVisual(T, "symbol") || "circle";
                    var U = V.getItemVisual(T, "color");
                    if (R === "none") {
                        return
                    }
                    var S = F.createSymbol(R, -0.5, -0.5, 1, 1, U);
                    S.attr({style: {strokeNoScale: true}, z2: 100, scale: E(V.getItemVisual(T, "symbolSize"))});
                    return S
                }

                function M(X, U, Y, T, V, S) {
                    Y.removeAll();
                    for (var W = 0; W < U.length - 1; W++) {
                        var R = H(T, V);
                        if (R) {
                            R.__dimIdx = W;
                            if (X[W]) {
                                R.attr("position", X[W]);
                                A[S ? "initProps" : "updateProps"](R, {position: U[W]}, Q, V)
                            } else {
                                R.attr("position", U[W])
                            }
                            Y.add(R)
                        }
                    }
                }

                function O(R) {
                    return B.map(R, function(S) {
                        return [I.cx, I.cy]
                    })
                }

                K.diff(L).add(function(V) {
                    var T = K.getItemLayout(V);
                    if (!T) {
                        return
                    }
                    var W = new A.Polygon();
                    var U = new A.Polyline();
                    var S = {shape: {points: T}};
                    W.shape.points = O(T);
                    U.shape.points = O(T);
                    A.initProps(W, S, Q, V);
                    A.initProps(U, S, Q, V);
                    var R = new A.Group();
                    var X = new A.Group();
                    R.add(U);
                    R.add(W);
                    R.add(X);
                    M(U.shape.points, T, X, K, V, true);
                    K.setItemGraphicEl(V, R)
                }).update(function(S, U) {
                    var X = L.getItemGraphicEl(U);
                    var V = X.childAt(0);
                    var R = X.childAt(1);
                    var W = X.childAt(2);
                    var T = {shape: {points: K.getItemLayout(S)}};
                    if (!T.shape.points) {
                        return
                    }
                    M(V.shape.points, T.shape.points, W, K, S, false);
                    A.updateProps(V, T, Q);
                    A.updateProps(R, T, Q);
                    K.setItemGraphicEl(S, X)
                }).remove(function(R) {
                    N.remove(L.getItemGraphicEl(R))
                }).execute();
                K.eachItemGraphicEl(function(d, h) {
                    var T = K.getItemModel(h);
                    var b = d.childAt(0);
                    var V = d.childAt(1);
                    var Z = d.childAt(2);
                    var S = K.getItemVisual(h, "color");
                    N.add(d);
                    b.useStyle(B.defaults(T.getModel("lineStyle.normal").getLineStyle(), {fill: "none", stroke: S}));
                    b.hoverStyle = T.getModel("lineStyle.emphasis").getLineStyle();
                    var U = T.getModel("areaStyle.normal");
                    var Y = T.getModel("areaStyle.emphasis");
                    var f = U.isEmpty() && U.parentModel.isEmpty();
                    var c = Y.isEmpty() && Y.parentModel.isEmpty();
                    c = c && f;
                    V.ignore = f;
                    V.useStyle(B.defaults(U.getAreaStyle(), {fill: S, opacity: 0.7}));
                    V.hoverStyle = Y.getAreaStyle();
                    var g = T.getModel("itemStyle.normal").getItemStyle(["color"]);
                    var e = T.getModel("itemStyle.emphasis").getItemStyle();
                    var R = T.getModel("label.normal");
                    var a = T.getModel("label.emphasis");
                    Z.eachChild(function(j) {
                        j.setStyle(g);
                        j.hoverStyle = B.clone(e);
                        var i = K.get(K.dimensions[j.__dimIdx], h);
                        A.setText(j.style, R, S);
                        j.setStyle({text: R.get("show") ? B.retrieve(Q.getFormattedLabel(h, "normal", null, j.__dimIdx), i) : ""});
                        A.setText(j.hoverStyle, a, S);
                        j.hoverStyle.text = a.get("show") ? B.retrieve(Q.getFormattedLabel(h, "emphasis", null, j.__dimIdx), i) : ""
                    });

                    function W() {
                        V.attr("ignore", c)
                    }

                    function X() {
                        V.attr("ignore", f)
                    }

                    d.off("mouseover").off("mouseout").off("normal").off("emphasis");
                    d.on("emphasis", W).on("mouseover", W).on("normal", X).on("mouseout", X);
                    A.setHoverStyle(d)
                });
                this._data = K
            }, remove: function() {
                this.group.removeAll();
                this._data = null
            }, dispose: function() {
            }
        })
    }, function(A, B) {
        A.exports = function(C) {
            C.eachSeriesByType("radar", function(D) {
                var J = D.getData();
                var G = [];
                var F = D.coordinateSystem;
                if (!F) {
                    return
                }

                function I(L, K) {
                    G[K] = G[K] || [];
                    G[K][E] = F.dataToPoint(L, E)
                }

                for (var E = 0; E < F.getIndicatorAxes().length; E++) {
                    var H = J.dimensions[E];
                    J.each(H, I)
                }
                J.each(function(K) {
                    G[K][0] && G[K].push(G[K][0].slice());
                    J.setItemLayout(K, G[K])
                })
            })
        }
    }, function(C, D, B) {
        var A = B(4);
        C.exports = function(E) {
            var G = E.polar;
            if (G) {
                if (!A.isArray(G)) {
                    G = [G]
                }
                var F = [];
                A.each(G, function(I, H) {
                    if (I.indicator) {
                        if (I.type && !I.shape) {
                            I.shape = I.type
                        }
                        E.radar = E.radar || [];
                        if (!A.isArray(E.radar)) {
                            E.radar = [E.radar]
                        }
                        E.radar.push(I)
                    } else {
                        F.push(I)
                    }
                });
                E.polar = F
            }
            A.each(E.series, function(H) {
                if (H.type === "radar" && H.polarIndex) {
                    H.radarIndex = H.polarIndex
                }
            })
        }
    }, function(C, E, B) {
        var D = B(1);
        var A = D.PRIORITY;
        B(170);
        B(181);
        B(187);
        B(171);
        D.registerLayout(B(189));
        D.registerVisual(B(190));
        D.registerProcessor(A.PROCESSOR.STATISTIC, B(191));
        D.registerPreprocessor(B(192));
        B(150)("map", [{type: "mapToggleSelect", event: "mapselectchanged", method: "toggleSelected"}, {
            type: "mapSelect",
            event: "mapselected",
            method: "select"
        }, {type: "mapUnSelect", event: "mapunselected", method: "unSelect"}])
    }, function(K, M, D) {
        var L = D(98);
        var H = D(78);
        var C = D(4);
        var A = D(110);
        var G = D(6);
        var I = G.encodeHTML;
        var J = G.addCommas;
        var E = D(148);
        var B = D(171);
        var F = H.extend({
            type: "series.map",
            dependencies: ["geo"],
            layoutMode: "box",
            needsDrawMap: false,
            seriesGroup: [],
            init: function(N) {
                N = this._fillOption(N, this.getMapType());
                this.option = N;
                F.superApply(this, "init", arguments);
                this.updateSelectedMap(N.data)
            },
            getInitialData: function(N) {
                var P = A(["value"], N.data || []);
                var O = new L(P, this);
                O.initData(N.data);
                return O
            },
            mergeOption: function(N) {
                if (N.data) {
                    N = this._fillOption(N, this.getMapType())
                }
                F.superCall(this, "mergeOption", N);
                this.updateSelectedMap(this.option.data)
            },
            getHostGeoModel: function() {
                var N = this.option.geoIndex;
                return N != null ? this.dependentModels.geo[N] : null
            },
            getMapType: function() {
                return (this.getHostGeoModel() || this).option.map
            },
            _fillOption: function(N, O) {
                N = C.extend({}, N);
                N.data = B.getFilledRegions(N.data, O);
                return N
            },
            getRawValue: function(N) {
                return this.getData().get("value", N)
            },
            getRegionModel: function(N) {
                var O = this.getData();
                return O.getItemModel(O.indexOfName(N))
            },
            formatTooltip: function(U) {
                var Q = this.getData();
                var N = J(this.getRawValue(U));
                var O = Q.getName(U);
                var T = this.seriesGroup;
                var R = [];
                for (var S = 0; S < T.length; S++) {
                    var P = T[S].originalData.indexOfName(O);
                    if (!isNaN(T[S].originalData.get("value", P))) {
                        R.push(I(T[S].name))
                    }
                }
                return R.join(", ") + "<br />" + I(O + " : " + N)
            },
            getTooltipPosition: function(N) {
                if (N != null) {
                    var O = this.getData().getName(N);
                    var Q = this.coordinateSystem;
                    var P = Q.getRegion(O);
                    return P && Q.dataToPoint(P.center)
                }
            },
            setZoom: function(N) {
                this.option.zoom = N
            },
            setCenter: function(N) {
                this.option.center = N
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "geo",
                map: "",
                left: "center",
                top: "center",
                aspectScale: 0.75,
                showLegendSymbol: true,
                dataRangeHoverLink: true,
                boundingCoords: null,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {normal: {show: false, textStyle: {color: "#000"}}, emphasis: {show: true, textStyle: {color: "rgb(100,0,0)"}}},
                itemStyle: {normal: {borderWidth: 0.5, borderColor: "#444", areaColor: "#eee"}, emphasis: {areaColor: "rgba(255,215,0,0.8)"}}
            }
        });
        C.mixin(F, E);
        K.exports = F
    }, function(K, M, E) {
        var I = E(172);
        var H = E(71);
        var D = E(4);
        var G = E(7);
        var C = {};

        function A(b, Z) {
            var W = b.get("boundingCoords");
            if (W != null) {
                var X = W[0];
                var Y = W[1];
                if (isNaN(X[0]) || isNaN(X[1]) || isNaN(Y[0]) || isNaN(Y[1])) {
                    if (true) {
                        console.error("Invalid boundingCoords")
                    }
                } else {
                    this.setBoundingRect(X[0], X[1], Y[0] - X[0], Y[1] - X[1])
                }
            }
            var Q = this.getBoundingRect();
            var S;
            var N = b.get("layoutCenter");
            var V = b.get("layoutSize");
            var T = Z.getWidth();
            var O = Z.getHeight();
            var P = b.get("aspectScale") || 0.75;
            var U = Q.width / Q.height * P;
            var a = false;
            if (N && V) {
                N = [G.parsePercent(N[0], T), G.parsePercent(N[1], O)];
                V = G.parsePercent(V, Math.min(T, O));
                if (!isNaN(N[0]) && !isNaN(N[1]) && !isNaN(V)) {
                    a = true
                } else {
                    if (true) {
                        console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.")
                    }
                }
            }
            var R;
            if (a) {
                var R = {};
                if (U > 1) {
                    R.width = V;
                    R.height = V / U
                } else {
                    R.height = V;
                    R.width = V * U
                }
                R.y = N[1] - R.height / 2;
                R.x = N[0] - R.width / 2
            } else {
                S = b.getBoxLayoutParams();
                S.aspect = U;
                R = H.getLayoutRect(S, {width: T, height: O})
            }
            this.setViewRect(R.x, R.y, R.width, R.height);
            this.setCenter(b.get("center"));
            this.setZoom(b.get("zoom"))
        }

        function J(O, N) {
            D.each(N.get("geoCoord"), function(P, Q) {
                O.addGeoCoord(Q, P)
            })
        }

        if (true) {
            var F = function(N) {
                console.error("Map " + N + " not exists. You can download map file on http://echarts.baidu.com/download-map.html")
            }
        }
        var B = {
            dimensions: I.prototype.dimensions, create: function(O, P) {
                var Q = [];
                O.eachComponent("geo", function(R, U) {
                    var S = R.get("map");
                    var T = C[S];
                    if (true) {
                        if (!T) {
                            F(S)
                        }
                    }
                    var V = new I(S + U, S, T && T.geoJson, T && T.specialAreas, R.get("nameMap"));
                    V.zoomLimit = R.get("scaleLimit");
                    Q.push(V);
                    J(V, R);
                    R.coordinateSystem = V;
                    V.model = R;
                    V.resize = A;
                    V.resize(R, P)
                });
                O.eachSeries(function(R) {
                    var S = R.get("coordinateSystem");
                    if (S === "geo") {
                        var T = R.get("geoIndex") || 0;
                        R.coordinateSystem = Q[T]
                    }
                });
                var N = {};
                O.eachSeriesByType("map", function(R) {
                    if (!R.getHostGeoModel()) {
                        var S = R.getMapType();
                        N[S] = N[S] || [];
                        N[S].push(R)
                    }
                });
                D.each(N, function(S, T) {
                    var U = C[T];
                    if (true) {
                        if (!U) {
                            F(S[0].get("map"))
                        }
                    }
                    var R = D.map(S, function(W) {
                        return W.get("nameMap")
                    });
                    var V = new I(T, T, U && U.geoJson, U && U.specialAreas, D.mergeAll(R));
                    V.zoomLimit = D.retrieve.apply(null, D.map(S, function(W) {
                        return W.get("scaleLimit")
                    }));
                    Q.push(V);
                    V.resize = A;
                    V.resize(S[0], P);
                    D.each(S, function(W) {
                        W.coordinateSystem = V;
                        J(V, W)
                    })
                });
                return Q
            }, registerMap: function(P, N, O) {
                if (N.geoJson && !N.features) {
                    O = N.specialAreas;
                    N = N.geoJson
                }
                if (typeof N === "string") {
                    N = (typeof JSON !== "undefined" && JSON.parse) ? JSON.parse(N) : (new Function("return (" + N + ");"))()
                }
                C[P] = {geoJson: N, specialAreas: O}
            }, getMap: function(N) {
                return C[N]
            }, getFilledRegions: function(V, Q) {
                var S = (V || []).slice();
                var U = B.getMap(Q);
                var N = U && U.geoJson;
                if (!N) {
                    if (true) {
                        F(Q)
                    }
                    return V
                }
                var T = D.createHashMap();
                var P = N.features;
                for (var R = 0; R < S.length; R++) {
                    T.set(S[R].name, S[R])
                }
                for (var R = 0; R < P.length; R++) {
                    var O = P[R].properties.name;
                    if (!T.get(O)) {
                        S.push({name: O})
                    }
                }
                return S
            }
        };
        var L = E(1);
        L.registerMap = B.registerMap;
        L.getMap = B.getMap;
        L.parseGeoJSON = E(173);
        L.loadMap = function() {
        };
        L.registerCoordinateSystem("geo", B);
        K.exports = B
    }, function(A, J, D) {
        var I = D(173);
        var C = D(4);
        var E = D(9);
        var H = D(176);
        var B = [D(177), D(178), D(179), D(180)];

        function F(N, M, K, O, L) {
            H.call(this, N);
            this.map = M;
            this._nameCoordMap = C.createHashMap();
            this.loadGeoJson(K, O, L)
        }

        F.prototype = {
            constructor: F, type: "geo", dimensions: ["lng", "lat"], containCoord: function(M) {
                var K = this.regions;
                for (var L = 0; L < K.length; L++) {
                    if (K[L].contain(M)) {
                        return true
                    }
                }
                return false
            }, loadGeoJson: function(S, L, O) {
                try {
                    this.regions = S ? I(S) : []
                } catch (K) {
                    throw"Invalid geoJson format\n" + K.message
                }
                L = L || {};
                O = O || {};
                var Q = this.regions;
                var M = C.createHashMap();
                for (var N = 0; N < Q.length; N++) {
                    var R = Q[N].name;
                    R = O.hasOwnProperty(R) ? O[R] : R;
                    Q[N].name = R;
                    M.set(R, Q[N]);
                    this.addGeoCoord(R, Q[N].center);
                    var P = L[R];
                    if (P) {
                        Q[N].transformTo(P.left, P.top, P.width, P.height)
                    }
                }
                this._regionsMap = M;
                this._rect = null;
                C.each(B, function(T) {
                    T(this)
                }, this)
            }, transformTo: function(O, P, Q, L) {
                var N = this.getBoundingRect();
                N = N.clone();
                N.y = -N.y - N.height;
                var K = this._viewTransform;
                K.transform = N.calculateTransform(new E(O, P, Q, L));
                K.decomposeTransform();
                var M = K.scale;
                M[1] = -M[1];
                K.updateTransform();
                this._updateTransform()
            }, getRegion: function(K) {
                return this._regionsMap.get(K)
            }, getRegionByCoord: function(M) {
                var K = this.regions;
                for (var L = 0; L < K.length; L++) {
                    if (K[L].contain(M)) {
                        return K[L]
                    }
                }
            }, addGeoCoord: function(L, K) {
                this._nameCoordMap.set(L, K)
            }, getGeoCoord: function(K) {
                return this._nameCoordMap.get(K)
            }, getBoundingRect: function() {
                if (this._rect) {
                    return this._rect
                }
                var M;
                var N = this.regions;
                for (var K = 0; K < N.length; K++) {
                    var L = N[K].getBoundingRect();
                    M = M || L.clone();
                    M.union(L)
                }
                return (this._rect = M || new E(0, 0, 0, 0))
            }, dataToPoints: function(L) {
                var K = [];
                return L.mapArray(["lng", "lat"], function(M, N) {
                    K[0] = M;
                    K[1] = N;
                    return this.dataToPoint(K)
                }, this)
            }, dataToPoint: function(K) {
                if (typeof K === "string") {
                    K = this.getGeoCoord(K)
                }
                if (K) {
                    return H.prototype.dataToPoint.call(this, K)
                }
            }, convertToPixel: C.curry(G, "dataToPoint"), convertFromPixel: C.curry(G, "pointToData")
        };
        C.mixin(F, H);

        function G(N, M, P, O) {
            var K = P.geoModel;
            var L = P.seriesModel;
            var Q = K ? K.coordinateSystem : L ? (L.coordinateSystem || (L.getReferringComponents("geo")[0] || {}).coordinateSystem) : null;
            return Q === this ? Q[N](O) : null
        }

        A.exports = F
    }, function(E, F, D) {
        var B = D(4);
        var G = D(174);

        function A(J) {
            if (!J.UTF8Encoding) {
                return J
            }
            var Q = J.UTF8Scale;
            if (Q == null) {
                Q = 1024
            }
            var I = J.features;
            for (var R = 0; R < I.length; R++) {
                var S = I[R];
                var L = S.geometry;
                var H = L.coordinates;
                var O = L.encodeOffsets;
                for (var P = 0; P < H.length; P++) {
                    var M = H[P];
                    if (L.type === "Polygon") {
                        H[P] = C(M, O[P], Q)
                    } else {
                        if (L.type === "MultiPolygon") {
                            for (var K = 0; K < M.length; K++) {
                                var N = M[K];
                                M[K] = C(N, O[P][K], Q)
                            }
                        }
                    }
                }
            }
            J.UTF8Encoding = false;
            return J
        }

        function C(I, J, N) {
            var H = [];
            var P = J[0];
            var O = J[1];
            for (var K = 0; K < I.length; K += 2) {
                var L = I.charCodeAt(K) - 64;
                var M = I.charCodeAt(K + 1) - 64;
                L = (L >> 1) ^ (-(L & 1));
                M = (M >> 1) ^ (-(M & 1));
                L += P;
                M += O;
                P = L;
                O = M;
                H.push([L / N, M / N])
            }
            return H
        }

        E.exports = function(H) {
            A(H);
            return B.map(B.filter(H.features, function(I) {
                return I.geometry && I.properties && I.geometry.coordinates.length > 0
            }), function(M) {
                var J = M.properties;
                var N = M.geometry;
                var L = N.coordinates;
                var I = [];
                if (N.type === "Polygon") {
                    I.push({type: "polygon", exterior: L[0], interiors: L.slice(1)})
                }
                if (N.type === "MultiPolygon") {
                    B.each(L, function(O) {
                        if (O[0]) {
                            I.push({type: "polygon", exterior: O[0], interiors: O.slice(1)})
                        }
                    })
                }
                var K = new G(J.name, I, J.cp);
                K.properties = J;
                return K
            })
        }
    }, function(G, H, B) {
        var A = B(175);
        var E = B(9);
        var F = B(38);
        var D = B(10);

        function C(J, K, L) {
            this.name = J;
            this.geometries = K;
            if (!L) {
                var I = this.getBoundingRect();
                L = [I.x + I.width / 2, I.y + I.height / 2]
            } else {
                L = [L[0], L[1]]
            }
            this.center = L
        }

        C.prototype = {
            constructor: C, properties: null, getBoundingRect: function() {
                var J = this._rect;
                if (J) {
                    return J
                }
                var L = Number.MAX_VALUE;
                var Q = [L, L];
                var K = [-L, -L];
                var P = [];
                var O = [];
                var N = this.geometries;
                for (var M = 0; M < N.length; M++) {
                    if (N[M].type !== "polygon") {
                        continue
                    }
                    var I = N[M].exterior;
                    F.fromPoints(I, P, O);
                    D.min(Q, Q, P);
                    D.max(K, K, O)
                }
                if (M === 0) {
                    Q[0] = Q[1] = K[0] = K[1] = 0
                }
                return (this._rect = new E(Q[0], Q[1], K[0] - Q[0], K[1] - Q[1]))
            }, contain: function(L) {
                var I = this.getBoundingRect();
                var M = this.geometries;
                if (!I.contain(L[0], L[1])) {
                    return false
                }
                loopGeo:for (var K = 0, N = M.length; K < N; K++) {
                    if (M[K].type !== "polygon") {
                        continue
                    }
                    var O = M[K].exterior;
                    var P = M[K].interiors;
                    if (A.contain(O, L[0], L[1])) {
                        for (var J = 0; J < (P ? P.length : 0); J++) {
                            if (A.contain(P[J])) {
                                continue loopGeo
                            }
                        }
                        return true
                    }
                }
                return false
            }, transformTo: function(S, T, Q, J) {
                var K = this.getBoundingRect();
                var L = K.width / K.height;
                if (!Q) {
                    Q = L * J
                } else {
                    if (!J) {
                        J = Q / L
                    }
                }
                var R = new E(S, T, Q, J);
                var O = K.calculateTransform(R);
                var P = this.geometries;
                for (var N = 0; N < P.length; N++) {
                    if (P[N].type !== "polygon") {
                        continue
                    }
                    var U = P[N].exterior;
                    var V = P[N].interiors;
                    for (var I = 0; I < U.length; I++) {
                        D.applyTransform(U[I], U[I], O)
                    }
                    for (var M = 0; M < (V ? V.length : 0); M++) {
                        for (var I = 0; I < V[M].length; I++) {
                            D.applyTransform(V[M][I], V[M][I], O)
                        }
                    }
                }
                K = this._rect;
                K.copy(R);
                this.center = [K.x + K.width / 2, K.y + K.height / 2]
            }
        };
        G.exports = C
    }, function(E, G, C) {
        var F = C(45);
        var A = 1e-08;

        function B(I, H) {
            return Math.abs(I - H) < A
        }

        function D(J, N, O) {
            var K = 0;
            var I = J[0];
            if (!I) {
                return false
            }
            for (var L = 1; L < J.length; L++) {
                var M = J[L];
                K += F(I[0], I[1], M[0], M[1], N, O);
                I = M
            }
            var H = J[0];
            if (!B(I[0], H[0]) || !B(I[1], H[1])) {
                K += F(I[0], I[1], H[0], H[1], N, O)
            }
            return K !== 0
        }

        E.exports = {contain: D}
    }, function(K, L, D) {
        var C = D(10);
        var E = D(11);
        var A = D(26);
        var G = D(4);
        var H = D(9);
        var F = C.applyTransform;

        function B() {
            A.call(this)
        }

        G.mixin(B, A);

        function I(M) {
            this.name = M;
            this.zoomLimit;
            A.call(this);
            this._roamTransform = new B();
            this._viewTransform = new B();
            this._center;
            this._zoom
        }

        I.prototype = {
            constructor: I, type: "view", dimensions: ["x", "y"], setBoundingRect: function(N, O, P, M) {
                this._rect = new H(N, O, P, M);
                return this._rect
            }, getBoundingRect: function() {
                return this._rect
            }, setViewRect: function(N, O, P, M) {
                this.transformTo(N, O, P, M);
                this._viewRect = new H(N, O, P, M)
            }, transformTo: function(P, Q, R, N) {
                var O = this.getBoundingRect();
                var M = this._viewTransform;
                M.transform = O.calculateTransform(new H(P, Q, R, N));
                M.decomposeTransform();
                this._updateTransform()
            }, setCenter: function(M) {
                if (!M) {
                    return
                }
                this._center = M;
                this._updateCenterAndZoom()
            }, setZoom: function(N) {
                N = N || 1;
                var M = this.zoomLimit;
                if (M) {
                    if (M.max != null) {
                        N = Math.min(M.max, N)
                    }
                    if (M.min != null) {
                        N = Math.max(M.min, N)
                    }
                }
                this._zoom = N;
                this._updateCenterAndZoom()
            }, getDefaultCenter: function() {
                var M = this.getBoundingRect();
                var O = M.x + M.width / 2;
                var N = M.y + M.height / 2;
                return [O, N]
            }, getCenter: function() {
                return this._center || this.getDefaultCenter()
            }, getZoom: function() {
                return this._zoom || 1
            }, getRoamTransform: function() {
                return this._roamTransform
            }, _updateCenterAndZoom: function() {
                var O = this._viewTransform.getLocalTransform();
                var P = this._roamTransform;
                var N = this.getDefaultCenter();
                var M = this.getCenter();
                var Q = this.getZoom();
                M = C.applyTransform([], M, O);
                N = C.applyTransform([], N, O);
                P.origin = M;
                P.position = [N[0] - M[0], N[1] - M[1]];
                P.scale = [Q, Q];
                this._updateTransform()
            }, _updateTransform: function() {
                var N = this._roamTransform;
                var M = this._viewTransform;
                M.parent = N;
                N.updateTransform();
                M.updateTransform();
                M.transform && E.copy(this.transform || (this.transform = []), M.transform);
                if (this.transform) {
                    this.invTransform = this.invTransform || [];
                    E.invert(this.invTransform, this.transform)
                } else {
                    this.invTransform = null
                }
                this.decomposeTransform()
            }, getViewRect: function() {
                return this._viewRect
            }, getViewRectAfterRoam: function() {
                var M = this.getBoundingRect().clone();
                M.applyTransform(this.transform);
                return M
            }, dataToPoint: function(N) {
                var M = this.transform;
                return M ? F([], N, M) : [N[0], N[1]]
            }, pointToData: function(M) {
                var N = this.invTransform;
                return N ? F([], M, N) : [M[0], M[1]]
            }, convertToPixel: G.curry(J, "dataToPoint"), convertFromPixel: G.curry(J, "pointToData"), containPoint: function(M) {
                return this.getViewRectAfterRoam().contain(M[0], M[1])
            }
        };
        G.mixin(I, A);

        function J(O, N, Q, P) {
            var M = Q.seriesModel;
            var R = M ? M.coordinateSystem : null;
            return R === this ? R[O](P) : null
        }

        K.exports = I
    }, function(A, I, C) {
        var H = C(174);
        var B = C(4);
        var G = [126, 25];
        var F = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
        for (var E = 0; E < F.length; E++) {
            for (var D = 0; D < F[E].length; D++) {
                F[E][D][0] /= 10.5;
                F[E][D][1] /= -10.5 / 0.75;
                F[E][D][0] += G[0];
                F[E][D][1] += G[1]
            }
        }
        A.exports = function(J) {
            if (J.map === "china") {
                J.regions.push(new H("", B.map(F, function(K) {
                    return {type: "polygon", exterior: K}
                }), G))
            }
        }
    }, function(C, D, B) {
        var A = B(4);
        var E = {"": [32, 80], "": [0, -10], "": [10, 5], "": [-10, 10], "": [5, 5]};
        C.exports = function(F) {
            A.each(F.regions, function(G) {
                var H = E[G.name];
                if (H) {
                    var I = G.center;
                    I[0] += H[0] / 10.5;
                    I[1] += -H[1] / (10.5 / 0.75)
                }
            })
        }
    }, function(C, E, B) {
        var A = B(4);
        var D = {"Russia": [100, 60], "United States": [-99, 38], "United States of America": [-99, 38]};
        C.exports = function(F) {
            A.each(F.regions, function(H) {
                var G = D[H.name];
                if (G) {
                    var I = H.center;
                    I[0] = G[0];
                    I[1] = G[1]
                }
            })
        }
    }, function(D, F, C) {
        var G = C(174);
        var A = C(4);
        var E = [126, 25];
        var B = [[[123.451652526855, 25.7352716440226], [123.497314453125, 25.7352716440226], [123.497314453125, 25.7507340646009], [123.451652526855, 25.7507340646009], [123.451652526855, 25.7352716440226]]];
        D.exports = function(J) {
            if (J.map === "china") {
                for (var H = 0, I = J.regions.length; H < I; ++H) {
                    if (J.regions[H].name === "") {
                        J.regions[H].geometries.push({type: "polygon", exterior: B[0]})
                    }
                }
            }
        }
    }, function(D, E, B) {
        var A = B(18);
        var C = B(182);
        B(1).extendChartView({
            type: "map", render: function(F, G, K, H) {
                if (H && H.type === "mapToggleSelect" && H.from === this.uid) {
                    return
                }
                var J = this.group;
                J.removeAll();
                if (F.getHostGeoModel()) {
                    return
                }
                if (!(H && H.type === "geoRoam" && H.componentType === "series" && H.seriesId === F.id)) {
                    if (F.needsDrawMap) {
                        var I = this._mapDraw || new C(K, true);
                        J.add(I.group);
                        I.draw(F, G, K, this, H);
                        this._mapDraw = I
                    } else {
                        this._mapDraw && this._mapDraw.remove();
                        this._mapDraw = null
                    }
                } else {
                    var I = this._mapDraw;
                    I && J.add(I.group)
                }
                F.get("showLegendSymbol") && G.getComponent("legend") && this._renderSymbols(F, G, K)
            }, remove: function() {
                this._mapDraw && this._mapDraw.remove();
                this._mapDraw = null;
                this.group.removeAll()
            }, dispose: function() {
                this._mapDraw && this._mapDraw.remove();
                this._mapDraw = null
            }, _renderSymbols: function(F, G, J) {
                var I = F.originalData;
                var H = this.group;
                I.each("value", function(a, O) {
                    if (isNaN(a)) {
                        return
                    }
                    var R = I.getItemLayout(O);
                    if (!R || !R.point) {
                        return
                    }
                    var N = R.point;
                    var T = R.offset;
                    var V = new A.Circle({
                        style: {fill: F.getData().getVisual("color")},
                        shape: {cx: N[0] + T * 9, cy: N[1], r: 3},
                        silent: true,
                        z2: 10
                    });
                    if (!T) {
                        var X = F.mainSeries.getData();
                        var b = I.getName(O);
                        var Z = b;
                        var W = X.indexOfName(b);
                        var U = I.getItemModel(O);
                        var L = U.getModel("label.normal");
                        var M = U.getModel("label.emphasis");
                        var S = L.getModel("textStyle");
                        var Y = M.getModel("textStyle");
                        var K = X.getItemGraphicEl(W);
                        V.setStyle({textPosition: "bottom"});
                        var P = function() {
                            V.setStyle({text: M.get("show") ? Z : "", textFill: Y.getTextColor(), textFont: Y.getFont()})
                        };
                        var Q = function() {
                            V.setStyle({text: L.get("show") ? Z : "", textFill: S.getTextColor(), textFont: S.getFont()})
                        };
                        K.on("mouseover", P).on("mouseout", Q).on("emphasis", P).on("normal", Q);
                        Q()
                    }
                    H.add(V)
                })
            }
        })
    }, function(K, L, E) {
        var C = E(183);
        var A = E(185);
        var I = E(186);
        var F = E(18);
        var D = E(4);

        function G(P, O) {
            var N = P.getItemStyle();
            var M = P.get("areaColor");
            if (M != null) {
                N.fill = M
            }
            return N
        }

        function J(P, O, M, Q, N) {
            M.off("click");
            M.off("mousedown");
            if (O.get("selectedMode")) {
                M.on("mousedown", function() {
                    P._mouseDownFlag = true
                });
                M.on("click", function(S) {
                    if (!P._mouseDownFlag) {
                        return
                    }
                    P._mouseDownFlag = false;
                    var R = S.target;
                    while (!R.__regions) {
                        R = R.parent
                    }
                    if (!R) {
                        return
                    }
                    var T = {
                        type: (O.mainType === "geo" ? "geo" : "map") + "ToggleSelect", batch: D.map(R.__regions, function(U) {
                            return {name: U.name, from: N.uid}
                        })
                    };
                    T[O.mainType + "Id"] = O.id;
                    Q.dispatchAction(T);
                    H(O, M)
                })
            }
        }

        function H(N, M) {
            M.eachChild(function(O) {
                D.each(O.__regions, function(P) {
                    O.trigger(N.isSelected(P.name) ? "emphasis" : "normal")
                })
            })
        }

        function B(O, N) {
            var M = new F.Group();
            this._controller = new C(O.getZr());
            this._controllerHost = {target: N ? M : null};
            this.group = M;
            this._updateGroup = N;
            this._mouseDownFlag
        }

        B.prototype = {
            constructor: B, draw: function(V, O, Y, T, P) {
                var Q = V.mainType === "geo";
                var R = V.getData && V.getData();
                Q && O.eachComponent({mainType: "series", subType: "map"}, function(c) {
                    if (!R && c.getHostGeoModel() === V) {
                        R = c.getData()
                    }
                });
                var Z = V.coordinateSystem;
                var W = this.group;
                var N = Z.scale;
                var M = {position: Z.position, scale: N};
                if (!W.childAt(0) || P) {
                    W.attr(M)
                } else {
                    F.updateProps(W, M, V)
                }
                W.removeAll();
                var X = ["itemStyle", "normal"];
                var a = ["itemStyle", "emphasis"];
                var U = ["label", "normal"];
                var b = ["label", "emphasis"];
                var S = D.createHashMap();
                D.each(Z.regions, function(m) {
                    var p = S.get(m.name) || S.set(m.name, new F.Group());
                    var o = new F.CompoundPath({shape: {paths: []}});
                    p.add(o);
                    var q = V.getRegionModel(m.name) || V;
                    var w = q.getModel(X);
                    var c = q.getModel(a);
                    var v = G(w, N);
                    var l = G(c, N);
                    var d = q.getModel(U);
                    var e = q.getModel(b);
                    var j;
                    if (R) {
                        j = R.indexOfName(m.name);
                        var t = R.getItemVisual(j, "color", true);
                        if (t) {
                            v.fill = t
                        }
                    }
                    var y = d.getModel("textStyle");
                    var u = e.getModel("textStyle");
                    D.each(m.geometries, function(Aa) {
                        if (Aa.type !== "polygon") {
                            return
                        }
                        o.shape.paths.push(new F.Polygon({shape: {points: Aa.exterior}}));
                        for (var z = 0; z < (Aa.interiors ? Aa.interiors.length : 0); z++) {
                            o.shape.paths.push(new F.Polygon({shape: {points: Aa.interiors[z]}}))
                        }
                    });
                    o.setStyle(v);
                    o.style.strokeNoScale = true;
                    o.culling = true;
                    var i = d.get("show");
                    var g = e.get("show");
                    var k = R && isNaN(R.get("value", j));
                    var s = R && R.getItemLayout(j);
                    if ((Q || k && (i || g)) || (s && s.showLabel)) {
                        var n = R ? j : m.name;
                        var r = V.getFormattedLabel(n, "normal");
                        var f = V.getFormattedLabel(n, "emphasis");
                        var h = new F.Text({
                            style: {
                                text: i ? (r || m.name) : "",
                                fill: y.getTextColor(),
                                textFont: y.getFont(),
                                textAlign: "center",
                                textVerticalAlign: "middle"
                            },
                            hoverStyle: {text: g ? (f || m.name) : "", fill: u.getTextColor(), textFont: u.getFont()},
                            position: m.center.slice(),
                            scale: [1 / N[0], 1 / N[1]],
                            z2: 10,
                            silent: true
                        });
                        p.add(h)
                    }
                    if (R) {
                        R.setItemGraphicEl(j, p)
                    } else {
                        var q = V.getRegionModel(m.name);
                        o.eventData = {componentType: "geo", geoIndex: V.componentIndex, name: m.name, region: (q && q.option) || {}}
                    }
                    var x = p.__regions || (p.__regions = []);
                    x.push(m);
                    F.setHoverStyle(p, l, {hoverSilentOnTouch: !!V.get("selectedMode")});
                    W.add(p)
                });
                this._updateController(V, O, Y);
                J(this, V, W, Y, T);
                H(V, W)
            }, remove: function() {
                this.group.removeAll();
                this._controller.dispose();
                this._controllerHost = {}
            }, _updateController: function(O, N, R) {
                var T = O.coordinateSystem;
                var P = this._controller;
                var M = this._controllerHost;
                M.zoomLimit = O.get("scaleLimit");
                M.zoom = T.getZoom();
                P.enable(O.get("roam") || false);
                var S = O.mainType;

                function Q() {
                    var U = {type: "geoRoam", componentType: S};
                    U[S + "Id"] = O.id;
                    return U
                }

                P.off("pan").on("pan", function(U, V) {
                    this._mouseDownFlag = false;
                    A.updateViewOnPan(M, U, V);
                    R.dispatchAction(D.extend(Q(), {dx: U, dy: V}))
                }, this);
                P.off("zoom").on("zoom", function(Y, V, X) {
                    this._mouseDownFlag = false;
                    A.updateViewOnZoom(M, Y, V, X);
                    R.dispatchAction(D.extend(Q(), {zoom: Y, originX: V, originY: X}));
                    if (this._updateGroup) {
                        var U = this.group;
                        var W = U.scale;
                        U.traverse(function(Z) {
                            if (Z.type === "text") {
                                Z.attr("scale", [1 / W[0], 1 / W[1]])
                            }
                        })
                    }
                }, this);
                P.setPointerChecker(function(U, V, W) {
                    return T.getViewRectAfterRoam().contain(V, W) && !I.onIrrelevantElement(U, R, O)
                })
            }
        };
        K.exports = B
    }, function(N, O, E) {
        var H = E(25);
        var D = E(4);
        var F = E(88);
        var I = E(184);

        function C(P) {
            this.pointerChecker;
            this._zr = P;
            this._opt = {};
            var V = D.bind;
            var T = V(K, this);
            var Q = V(M, this);
            var S = V(J, this);
            var U = V(L, this);
            var R = V(B, this);
            H.call(this);
            this.setPointerChecker = function(W) {
                this.pointerChecker = W
            };
            this.enable = function(X, W) {
                this.disable();
                this._opt = D.defaults(D.clone(W) || {}, {zoomOnMouseWheel: true, moveOnMouseMove: true, preventDefaultMouseMove: true});
                if (X == null) {
                    X = true
                }
                if (X === true || (X === "move" || X === "pan")) {
                    P.on("mousedown", T);
                    P.on("mousemove", Q);
                    P.on("mouseup", S)
                }
                if (X === true || (X === "scale" || X === "zoom")) {
                    P.on("mousewheel", U);
                    P.on("pinch", R)
                }
            };
            this.disable = function() {
                P.off("mousedown", T);
                P.off("mousemove", Q);
                P.off("mouseup", S);
                P.off("mousewheel", U);
                P.off("pinch", R)
            };
            this.dispose = this.disable;
            this.isDragging = function() {
                return this._dragging
            };
            this.isPinching = function() {
                return this._pinching
            }
        }

        D.mixin(C, H);

        function K(P) {
            if (P.target && P.target.draggable) {
                return
            }
            var Q = P.offsetX;
            var R = P.offsetY;
            if (this.pointerChecker && this.pointerChecker(P, Q, R)) {
                this._x = Q;
                this._y = R;
                this._dragging = true
            }
        }

        function M(Q) {
            if (!G(this, "moveOnMouseMove", Q) || !this._dragging) {
                return
            }
            if (Q.gestureEvent === "pinch") {
                return
            }
            if (I.isTaken(this._zr, "globalPan")) {
                return
            }
            var S = Q.offsetX;
            var T = Q.offsetY;
            var P = this._x;
            var U = this._y;
            var R = S - P;
            var V = T - U;
            this._x = S;
            this._y = T;
            this._opt.preventDefaultMouseMove && F.stop(Q.event);
            this.trigger("pan", R, V, P, U, S, T)
        }

        function J(P) {
            this._dragging = false
        }

        function L(P) {
            if (!G(this, "zoomOnMouseWheel", P) || P.wheelDelta === 0) {
                return
            }
            var Q = P.wheelDelta > 0 ? 1.1 : 1 / 1.1;
            A.call(this, P, Q, P.offsetX, P.offsetY)
        }

        function B(P) {
            if (I.isTaken(this._zr, "globalPan")) {
                return
            }
            var Q = P.pinchScale > 1 ? 1.1 : 1 / 1.1;
            A.call(this, P, Q, P.pinchX, P.pinchY)
        }

        function A(Q, R, P, S) {
            if (this.pointerChecker && this.pointerChecker(Q, P, S)) {
                F.stop(Q.event);
                this.trigger("zoom", R, P, S)
            }
        }

        function G(P, R, Q) {
            var S = P._opt[R];
            return S && (!D.isString(S) || Q.event[S + "Key"])
        }

        N.exports = C
    }, function(B, E, A) {
        var F = "\0_ec_interaction_mutex";
        var C = {
            take: function(G, J, H) {
                var I = D(G);
                I[J] = H
            }, release: function(G, J, H) {
                var I = D(G);
                var K = I[J];
                if (K === H) {
                    I[J] = null
                }
            }, isTaken: function(G, H) {
                return !!D(G)[H]
            }
        };

        function D(G) {
            return G[F] || (G[F] = {})
        }

        A(1).registerAction({type: "takeGlobalCursor", event: "globalCursorTaken", update: "update"}, function() {
        });
        B.exports = C
    }, function(A, C) {
        var B = {};
        B.updateViewOnPan = function(E, D, F) {
            var G = E.target;
            var H = G.position;
            H[0] += D;
            H[1] += F;
            G.dirty()
        };
        B.updateViewOnZoom = function(N, M, I, L) {
            var K = N.target;
            var F = N.zoomLimit;
            var J = K.position;
            var E = K.scale;
            var H = N.zoom = N.zoom || 1;
            H *= M;
            if (F) {
                var O = F.min || 0;
                var D = F.max || Infinity;
                H = Math.max(Math.min(D, H), O)
            }
            var G = H / N.zoom;
            N.zoom = H;
            J[0] -= (I - J[0]) * (G - 1);
            J[1] -= (L - J[1]) * (G - 1);
            E[0] *= G;
            E[1] *= G;
            K.dirty()
        };
        A.exports = B
    }, function(A, D) {
        var B = {};
        var C = {"axisPointer": 1, "tooltip": 1, "brush": 1};
        B.onIrrelevantElement = function(E, I, G) {
            var H = I.getComponentByElement(E.topTarget);
            var F = H && H.coordinateSystem;
            return H && H !== G && !C[H.mainType] && (F && F.model !== G)
        };
        A.exports = B
    }, function(D, F, C) {
        var A = C(4);
        var B = C(188);
        var E = C(1);
        E.registerAction({type: "geoRoam", event: "geoRoam", update: "updateLayout"}, function(H, G) {
            var I = H.componentType || "series";
            G.eachComponent({mainType: I, query: H}, function(J) {
                var L = J.coordinateSystem;
                if (L.type !== "geo") {
                    return
                }
                var K = B.updateCenterAndZoom(L, H, J.get("scaleLimit"));
                J.setCenter && J.setCenter(K.center);
                J.setZoom && J.setZoom(K.zoom);
                if (I === "series") {
                    A.each(J.seriesGroup, function(M) {
                        M.setCenter(K.center);
                        M.setZoom(K.zoom)
                    })
                }
            })
        })
    }, function(B, C) {
        var A = {};
        A.updateCenterAndZoom = function(M, F, H) {
            var N = M.getZoom();
            var D = M.getCenter();
            var G = F.zoom;
            var I = M.dataToPoint(D);
            if (F.dx != null && F.dy != null) {
                I[0] -= F.dx;
                I[1] -= F.dy;
                var D = M.pointToData(I);
                M.setCenter(D)
            }
            if (G != null) {
                if (H) {
                    var L = H.min || 0;
                    var E = H.max || Infinity;
                    G = Math.max(Math.min(N * G, E), L) / N
                }
                M.scale[0] *= G;
                M.scale[1] *= G;
                var K = M.position;
                var J = (F.originX - K[0]) * (G - 1);
                var O = (F.originY - K[1]) * (G - 1);
                K[0] -= J;
                K[1] -= O;
                M.updateTransform();
                var D = M.pointToData(I);
                M.setCenter(D);
                M.setZoom(G * N)
            }
            return {center: M.getCenter(), zoom: M.getZoom()}
        };
        B.exports = A
    }, function(C, D, B) {
        var A = B(4);
        C.exports = function(F) {
            var E = {};
            F.eachSeriesByType("map", function(H) {
                var I = H.getMapType();
                if (H.getHostGeoModel() || E[I]) {
                    return
                }
                var G = {};
                A.each(H.seriesGroup, function(L) {
                    var M = L.coordinateSystem;
                    var K = L.originalData;
                    if (L.get("showLegendSymbol") && F.getComponent("legend")) {
                        K.each("value", function(Q, O) {
                            var P = K.getName(O);
                            var R = M.getRegion(P);
                            if (!R || isNaN(Q)) {
                                return
                            }
                            var N = G[P] || 0;
                            var S = M.dataToPoint(R.center);
                            G[P] = N + 1;
                            K.setItemLayout(O, {point: S, offset: N})
                        })
                    }
                });
                var J = H.getData();
                J.each(function(L) {
                    var K = J.getName(L);
                    var M = J.getItemLayout(L) || {};
                    M.showLabel = !G[K];
                    J.setItemLayout(L, M)
                });
                E[I] = true
            })
        }
    }, function(A, B) {
        A.exports = function(C) {
            C.eachSeriesByType("map", function(D) {
                var F = D.get("color");
                var G = D.getModel("itemStyle.normal");
                var E = G.get("areaColor");
                var H = G.get("color") || F[D.seriesIndex % F.length];
                D.getData().setVisual({"areaColor": E, "color": H})
            })
        }
    }, function(D, E, B) {
        var A = B(4);

        function C(H, F) {
            var G = {};
            var I = ["value"];
            A.each(H, function(J) {
                J.each(I, function(L, K) {
                    var M = "ec-" + J.getName(K);
                    G[M] = G[M] || [];
                    if (!isNaN(L)) {
                        G[M].push(L)
                    }
                })
            });
            return H[0].map(I, function(N, M) {
                var P = "ec-" + H[0].getName(M);
                var O = 0;
                var K = Infinity;
                var L = -Infinity;
                var R = G[P].length;
                for (var Q = 0; Q < R; Q++) {
                    K = Math.min(K, G[P][Q]);
                    L = Math.max(L, G[P][Q]);
                    O += G[P][Q]
                }
                var J;
                if (F === "min") {
                    J = K
                } else {
                    if (F === "max") {
                        J = L
                    } else {
                        if (F === "average") {
                            J = O / R
                        } else {
                            J = O
                        }
                    }
                }
                return R === 0 ? NaN : J
            })
        }

        D.exports = function(F) {
            var G = {};
            F.eachSeriesByType("map", function(I) {
                var J = I.getHostGeoModel();
                var H = J ? "o" + J.id : "i" + I.getMapType();
                (G[H] = G[H] || []).push(I)
            });
            A.each(G, function(H, I) {
                var K = C(A.map(H, function(L) {
                    return L.getData()
                }), H[0].get("mapValueCalculation"));
                for (var J = 0; J < H.length; J++) {
                    H[J].originalData = H[J].getData()
                }
                for (var J = 0; J < H.length; J++) {
                    H[J].seriesGroup = H;
                    H[J].needsDrawMap = J === 0 && !H[J].getHostGeoModel();
                    H[J].setData(K.cloneShallow());
                    H[J].mainSeries = H[0]
                }
            })
        }
    }, function(C, D, B) {
        var A = B(4);
        C.exports = function(E) {
            var F = [];
            A.each(E.series, function(G) {
                if (G.type === "map") {
                    F.push(G)
                }
            });
            A.each(F, function(G) {
                G.map = G.map || G.mapType;
                A.defaults(G, G.mapLocation)
            })
        }
    }, function(B, D, A) {
        var C = A(1);
        A(194);
        A(198);
        A(201);
        C.registerVisual(A(202));
        C.registerLayout(A(204))
    }, function(K, M, C) {
        var G = C(78);
        var E = C(195);
        var B = C(4);
        var J = C(12);
        var F = C(6);
        var I = C(197);
        var H = F.encodeHTML;
        var L = F.addCommas;
        K.exports = G.extend({
            type: "series.treemap",
            layoutMode: "box",
            dependencies: ["grid", "polar"],
            _viewRoot: null,
            defaultOption: {
                progressive: 0,
                hoverLayerThreshold: Infinity,
                left: "center",
                top: "middle",
                right: null,
                bottom: null,
                width: "80%",
                height: "80%",
                sort: true,
                clipWindow: "origin",
                squareRatio: 0.5 * (1 + Math.sqrt(5)),
                leafDepth: null,
                drillDownIcon: "",
                zoomToNodeRatio: 0.32 * 0.32,
                roam: true,
                nodeClick: "zoomToNode",
                animation: true,
                animationDurationUpdate: 900,
                animationEasing: "quinticInOut",
                breadcrumb: {
                    show: true,
                    height: 22,
                    left: "center",
                    top: "bottom",
                    emptyItemWidth: 25,
                    itemStyle: {
                        normal: {
                            color: "rgba(0,0,0,0.7)",
                            borderColor: "rgba(255,255,255,0.7)",
                            borderWidth: 1,
                            shadowColor: "rgba(150,150,150,1)",
                            shadowBlur: 3,
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            textStyle: {color: "#fff"}
                        }, emphasis: {textStyle: {}}
                    }
                },
                label: {normal: {show: true, position: "inside", textStyle: {color: "#fff", ellipsis: true}}},
                upperLabel: {
                    normal: {show: false, position: [0, "50%"], height: 20, textStyle: {color: "#fff", ellipsis: true, baseline: "middle"}},
                    emphasis: {show: true, position: [0, "50%"], textStyle: {color: "#fff", ellipsis: true, baseline: "middle"}}
                },
                itemStyle: {
                    normal: {
                        color: null,
                        colorAlpha: null,
                        colorSaturation: null,
                        borderWidth: 0,
                        gapWidth: 0,
                        borderColor: "#fff",
                        borderColorSaturation: null
                    }, emphasis: {}
                },
                visualDimension: 0,
                visualMin: null,
                visualMax: null,
                color: [],
                colorAlpha: null,
                colorSaturation: null,
                colorMappingBy: "index",
                visibleMin: 10,
                childrenVisibleMin: null,
                levels: []
            },
            getInitialData: function(O, Q) {
                var P = {name: O.name, children: O.data};
                A(P);
                var N = O.levels || [];
                N = O.levels = D(N, Q);
                return E.createTree(P, this, N).data
            },
            optionUpdated: function() {
                this.resetViewRoot()
            },
            formatTooltip: function(N) {
                var R = this.getData();
                var Q = this.getRawValue(N);
                var O = B.isArray(Q) ? L(Q[0]) : L(Q);
                var P = R.getName(N);
                return H(P + ": " + O)
            },
            getDataParams: function(N) {
                var P = G.prototype.getDataParams.apply(this, arguments);
                var O = this.getData().tree.getNodeByDataIndex(N);
                P.treePathInfo = I.wrapTreePathInfo(O, this);
                return P
            },
            setLayoutInfo: function(N) {
                this.layoutInfo = this.layoutInfo || {};
                B.extend(this.layoutInfo, N)
            },
            mapIdToIndex: function(P) {
                var N = this._idIndexMap;
                if (!N) {
                    N = this._idIndexMap = B.createHashMap();
                    this._idIndexMapCount = 0
                }
                var O = N.get(P);
                if (O == null) {
                    N.set(P, O = this._idIndexMapCount++)
                }
                return O
            },
            getViewRoot: function() {
                return this._viewRoot
            },
            resetViewRoot: function(N) {
                N ? (this._viewRoot = N) : (N = this._viewRoot);
                var O = this.getData().tree.root;
                if (!N || (N !== O && !O.contains(N))) {
                    this._viewRoot = O
                }
            }
        });

        function A(O) {
            var P = 0;
            B.each(O.children, function(Q) {
                A(Q);
                var R = Q.value;
                B.isArray(R) && (R = R[0]);
                P += R
            });
            var N = O.value;
            if (B.isArray(N)) {
                N = N[0]
            }
            if (N == null || isNaN(N)) {
                N = P
            }
            if (N < 0) {
                N = 0
            }
            B.isArray(O.value) ? (O.value[0] = N) : (O.value = N)
        }

        function D(N, Q) {
            var O = Q.get("color");
            if (!O) {
                return
            }
            N = N || [];
            var P;
            B.each(N, function(U) {
                var S = new J(U);
                var T = S.get("color");
                if (S.get("itemStyle.normal.color") || (T && T !== "none")) {
                    P = true
                }
            });
            if (!P) {
                var R = N[0] || (N[0] = {});
                R.color = O.slice()
            }
            return N
        }
    }, function(I, K, E) {
        var D = E(4);
        var H = E(12);
        var J = E(98);
        var C = E(196);
        var A = E(110);
        var B = function(M, L) {
            this.name = M || "";
            this.depth = 0;
            this.height = 0;
            this.parentNode = null;
            this.dataIndex = -1;
            this.children = [];
            this.viewChildren = [];
            this.hostTree = L
        };
        B.prototype = {
            constructor: B, isRemoved: function() {
                return this.dataIndex < 0
            }, eachNode: function(P, L, M) {
                if (typeof P === "function") {
                    M = L;
                    L = P;
                    P = null
                }
                P = P || {};
                if (D.isString(P)) {
                    P = {order: P}
                }
                var Q = P.order || "preorder";
                var R = this[P.attr || "children"];
                var O;
                Q === "preorder" && (O = L.call(M, this));
                for (var N = 0; !O && N < R.length; N++) {
                    R[N].eachNode(P, L, M)
                }
                Q === "postorder" && L.call(M, this)
            }, updateDepthAndHeight: function(O) {
                var M = 0;
                this.depth = O;
                for (var N = 0; N < this.children.length; N++) {
                    var L = this.children[N];
                    L.updateDepthAndHeight(O + 1);
                    if (L.height > M) {
                        M = L.height
                    }
                }
                this.height = M + 1
            }, getNodeById: function(P) {
                if (this.getId() === P) {
                    return this
                }
                for (var M = 0, L = this.children, O = L.length; M < O; M++) {
                    var N = L[M].getNodeById(P);
                    if (N) {
                        return N
                    }
                }
            }, contains: function(M) {
                if (M === this) {
                    return true
                }
                for (var L = 0, P = this.children, O = P.length; L < O; L++) {
                    var N = P[L].contains(M);
                    if (N) {
                        return N
                    }
                }
            }, getAncestors: function(M) {
                var N = [];
                var L = M ? this : this.parentNode;
                while (L) {
                    N.push(L);
                    L = L.parentNode
                }
                N.reverse();
                return N
            }, getValue: function(L) {
                var M = this.hostTree.data;
                return M.get(M.getDimension(L || "value"), this.dataIndex)
            }, setLayout: function(M, L) {
                this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, M, L)
            }, getLayout: function() {
                return this.hostTree.data.getItemLayout(this.dataIndex)
            }, getModel: function(O) {
                if (this.dataIndex < 0) {
                    return
                }
                var L = this.hostTree;
                var M = L.data.getItemModel(this.dataIndex);
                var N = this.getLevelModel();
                return M.getModel(O, (N || L.hostModel).getModel(O))
            }, getLevelModel: function() {
                return (this.hostTree.levelModels || [])[this.depth]
            }, setVisual: function(L, M) {
                this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, L, M)
            }, getVisual: function(L, M) {
                return this.hostTree.data.getItemVisual(this.dataIndex, L, M)
            }, getRawIndex: function() {
                return this.hostTree.data.getRawIndex(this.dataIndex)
            }, getId: function() {
                return this.hostTree.data.getId(this.dataIndex)
            }
        };

        function F(M, L) {
            this.root;
            this.data;
            this._nodes = [];
            this.hostModel = M;
            this.levelModels = D.map(L || [], function(N) {
                return new H(N, M, M.ecModel)
            })
        }

        F.prototype = {
            constructor: F, type: "tree", eachNode: function(N, L, M) {
                this.root.eachNode(N, L, M)
            }, getNodeByDataIndex: function(L) {
                var M = this.data.getRawIndex(L);
                return this._nodes[M]
            }, getNodeByName: function(L) {
                return this.root.getNodeByName(L)
            }, update: function() {
                var O = this.data;
                var M = this._nodes;
                for (var L = 0, N = M.length; L < N; L++) {
                    M[L].dataIndex = -1
                }
                for (var L = 0, N = O.count(); L < N; L++) {
                    M[O.getRawIndex(L)].dataIndex = L
                }
            }, clearLayouts: function() {
                this.data.clearItemLayouts()
            }
        };
        F.createTree = function(M, S, P) {
            var R = new F(S, P);
            var O = [];
            var Q = 1;
            T(M);

            function T(X, V) {
                var Y = X.value;
                Q = Math.max(Q, D.isArray(Y) ? Y.length : 1);
                O.push(X);
                var W = new B(X.name, R);
                V ? G(W, V) : (R.root = W);
                R._nodes.push(W);
                var Z = X.children;
                if (Z) {
                    for (var U = 0; U < Z.length; U++) {
                        T(Z[U], W)
                    }
                }
            }

            R.root.updateDepthAndHeight(0);
            var L = A([{name: "value"}], O, {dimCount: Q});
            var N = new J(L, S);
            N.initData(O);
            C({mainData: N, struct: R, structAttr: "tree"});
            R.update();
            return R
        };

        function G(M, L) {
            var N = L.children;
            if (M.parentNode === L) {
                return
            }
            N.push(M);
            M.parentNode = L
        }

        I.exports = F
    }, function(M, O, G) {
        var E = G(4);
        var A = E.each;
        var J = "\0__link_datas";
        var F = "\0__link_mainData";

        function C(P) {
            var R = P.mainData;
            var Q = P.datas;
            if (!Q) {
                Q = {main: R};
                P.datasAttr = {main: "data"}
            }
            P.datas = P.mainData = null;
            I(R, Q, P);
            A(Q, function(S) {
                A(R.TRANSFERABLE_METHODS, function(T) {
                    S.wrapMethod(T, E.curry(K, P))
                })
            });
            R.wrapMethod("cloneShallow", E.curry(D, P));
            A(R.CHANGABLE_METHODS, function(S) {
                R.wrapMethod(S, E.curry(L, P))
            });
            E.assert(Q[R.dataType] === R)
        }

        function K(Q, R) {
            if (H(this)) {
                var P = E.extend({}, this[J]);
                P[this.dataType] = R;
                I(R, P, Q)
            } else {
                N(R, this.dataType, this[F], Q)
            }
            return R
        }

        function L(P, Q) {
            P.struct && P.struct.update(this);
            return Q
        }

        function D(P, Q) {
            A(Q[J], function(S, R) {
                S !== Q && N(S.cloneShallow(), R, Q, P)
            });
            return Q
        }

        function B(P) {
            var Q = this[F];
            return (P == null || Q == null) ? Q : Q[J][P]
        }

        function H(P) {
            return P[F] === P
        }

        function I(R, Q, P) {
            R[J] = {};
            A(Q, function(T, S) {
                N(T, S, R, P)
            })
        }

        function N(S, Q, R, P) {
            R[J][Q] = S;
            S[F] = R;
            S.dataType = Q;
            if (P.struct) {
                S[P.structAttr] = P.struct;
                P.struct[P.datasAttr[Q]] = S
            }
            S.getLinkedData = B
        }

        M.exports = C
    }, function(C, E, B) {
        var A = B(4);
        var D = {
            retrieveTargetInfo: function(I, F) {
                if (I && (I.type === "treemapZoomToNode" || I.type === "treemapRootToNode")) {
                    var G = F.getData().tree.root;
                    var H = I.targetNode;
                    if (H && G.contains(H)) {
                        return {node: H}
                    }
                    var J = I.targetNodeId;
                    if (J != null && (H = G.getNodeById(J))) {
                        return {node: H}
                    }
                }
            }, getPathToRoot: function(F) {
                var G = [];
                while (F) {
                    F = F.parentNode;
                    F && G.push(F)
                }
                return G.reverse()
            }, aboveViewRoot: function(G, H) {
                var F = D.getPathToRoot(G);
                return A.indexOf(F, H) >= 0
            }, wrapTreePathInfo: function(I, F) {
                var H = [];
                while (I) {
                    var G = I.dataIndex;
                    H.push({name: I.name, dataIndex: G, value: F.getRawValue(G)});
                    I = I.parentNode
                }
                H.reverse();
                return H
            }
        };
        C.exports = D
    }, function(S, I, U) {
        var Z = U(4);
        var M = U(18);
        var K = U(99);
        var O = U(197);
        var G = U(199);
        var W = U(183);
        var X = U(9);
        var L = U(11);
        var a = U(200);
        var C = Z.bind;
        var F = M.Group;
        var J = M.Rect;
        var H = Z.each;
        var Q = 3;
        var A = ["label", "normal"];
        var N = ["label", "emphasis"];
        var B = ["upperLabel", "normal"];
        var Y = ["upperLabel", "emphasis"];
        var V = 10;
        var P = 1;
        var E = 2;
        S.exports = U(1).extendChartView({
            type: "treemap", init: function(b, c) {
                this._containerGroup;
                this._storage = D();
                this._oldTree;
                this._breadcrumb;
                this._controller;
                this._state = "ready";
                this._mayClick
            }, render: function(n, c, l, d) {
                var g = c.findComponents({mainType: "series", subType: "treemap", query: d});
                if (Z.indexOf(g, n) < 0) {
                    return
                }
                this.seriesModel = n;
                this.api = l;
                this.ecModel = c;
                var j = O.retrieveTargetInfo(d, n);
                var f = d && d.type;
                var i = n.layoutInfo;
                var e = !this._oldTree;
                var m = this._storage;
                var b = (f === "treemapRootToNode" && j && m) ? {rootNodeGroup: m.nodeGroup[j.node.getRawIndex()], direction: d.direction} : null;
                var k = this._giveContainerGroup(i);
                var h = this._doRender(k, n, b);
                (!e && (!f || f === "treemapZoomToNode" || f === "treemapRootToNode")) ? this._doAnimation(k, h, n, b) : h.renderFinally();
                this._resetController(l);
                this._renderBreadcrumb(n, l, j)
            }, _giveContainerGroup: function(c) {
                var b = this._containerGroup;
                if (!b) {
                    b = this._containerGroup = new F();
                    this._initEvents(b);
                    this.group.add(b)
                }
                b.attr("position", [c.x, c.y]);
                return b
            }, _doRender: function(g, o, c) {
                var k = o.getData().tree;
                var n = this._oldTree;
                var j = D();
                var m = D();
                var d = this._storage;
                var f = [];
                var i = Z.curry(T, o, m, d, c, j, f);
                e(k.root ? [k.root] : [], (n && n.root) ? [n.root] : [], g, k === n || !n, 0);
                var h = l(d);
                this._oldTree = k;
                this._storage = m;
                return {lastsForAnimation: j, willDeleteEls: h, renderFinally: b};

                function e(v, t, p, s, r) {
                    if (s) {
                        t = v;
                        H(v, function(w, x) {
                            !w.isRemoved() && q(x, x)
                        })
                    } else {
                        (new K(t, v, u, u)).add(q).update(q).remove(Z.curry(q, null)).execute()
                    }

                    function u(w) {
                        return w.getId()
                    }

                    function q(z, y) {
                        var Aa = z != null ? v[z] : null;
                        var w = y != null ? t[y] : null;
                        var x = i(Aa, w, p, r);
                        x && e(Aa && Aa.viewChildren || [], w && w.viewChildren || [], x, s, r + 1)
                    }
                }

                function l(p) {
                    var q = D();
                    p && H(p, function(r, s) {
                        var t = q[s];
                        H(r, function(u) {
                            u && (t.push(u), u.__tmWillDelete = 1)
                        })
                    });
                    return q
                }

                function b() {
                    H(h, function(p) {
                        H(p, function(q) {
                            q.parent && q.parent.remove(q)
                        })
                    });
                    H(f, function(p) {
                        p.invisible = true;
                        p.dirty()
                    })
                }
            }, _doAnimation: function(b, h, c, f) {
                if (!c.get("animation")) {
                    return
                }
                var g = c.get("animationDurationUpdate");
                var e = c.get("animationEasing");
                var d = a.createWrap();
                H(h.willDeleteEls, function(i, j) {
                    H(i, function(k, l) {
                        if (k.invisible) {
                            return
                        }
                        var o = k.parent;
                        var n;
                        if (f && f.direction === "drillDown") {
                            n = o === f.rootNodeGroup ? {
                                shape: {x: 0, y: 0, width: o.__tmNodeWidth, height: o.__tmNodeHeight},
                                style: {opacity: 0}
                            } : {style: {opacity: 0}}
                        } else {
                            var m = 0;
                            var p = 0;
                            if (!o.__tmWillDelete) {
                                m = o.__tmNodeWidth / 2;
                                p = o.__tmNodeHeight / 2
                            }
                            n = j === "nodeGroup" ? {position: [m, p], style: {opacity: 0}} : {
                                shape: {x: m, y: p, width: 0, height: 0},
                                style: {opacity: 0}
                            }
                        }
                        n && d.add(k, n, g, e)
                    })
                });
                H(this._storage, function(i, j) {
                    H(i, function(k, l) {
                        var m = h.lastsForAnimation[j][l];
                        var n = {};
                        if (!m) {
                            return
                        }
                        if (j === "nodeGroup") {
                            if (m.old) {
                                n.position = k.position.slice();
                                k.attr("position", m.old)
                            }
                        } else {
                            if (m.old) {
                                n.shape = Z.extend({}, k.shape);
                                k.setShape(m.old)
                            }
                            if (m.fadein) {
                                k.setStyle("opacity", 0);
                                n.style = {opacity: 1}
                            } else {
                                if (k.style.opacity !== 1) {
                                    n.style = {opacity: 1}
                                }
                            }
                        }
                        d.add(k, n, g, e)
                    })
                }, this);
                this._state = "animating";
                d.done(C(function() {
                    this._state = "ready";
                    h.renderFinally()
                }, this)).start()
            }, _resetController: function(c) {
                var d = this._controller;
                if (!d) {
                    d = this._controller = new W(c.getZr());
                    d.enable(this.seriesModel.get("roam"));
                    d.on("pan", C(this._onPan, this));
                    d.on("zoom", C(this._onZoom, this))
                }
                var b = new X(0, 0, c.getWidth(), c.getHeight());
                d.setPointerChecker(function(f, g, h) {
                    return b.contain(g, h)
                })
            }, _clearController: function() {
                var b = this._controller;
                if (b) {
                    b.dispose();
                    b = null
                }
            }, _onPan: function(d, e) {
                this._mayClick = false;
                if (this._state !== "animating" && (Math.abs(d) > Q || Math.abs(e) > Q)) {
                    var c = this.seriesModel.getData().tree.root;
                    if (!c) {
                        return
                    }
                    var b = c.getLayout();
                    if (!b) {
                        return
                    }
                    this.api.dispatchAction({
                        type: "treemapMove",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {x: b.x + d, y: b.y + e, width: b.width, height: b.height}
                    })
                }
            }, _onZoom: function(d, h, g) {
                this._mayClick = false;
                if (this._state !== "animating") {
                    var e = this.seriesModel.getData().tree.root;
                    if (!e) {
                        return
                    }
                    var b = e.getLayout();
                    if (!b) {
                        return
                    }
                    var c = new X(b.x, b.y, b.width, b.height);
                    var f = this.seriesModel.layoutInfo;
                    h -= f.x;
                    g -= f.y;
                    var i = L.create();
                    L.translate(i, i, [-h, -g]);
                    L.scale(i, i, [d, d]);
                    L.translate(i, i, [h, g]);
                    c.applyTransform(i);
                    this.api.dispatchAction({
                        type: "treemapRender",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {x: c.x, y: c.y, width: c.width, height: c.height}
                    })
                }
            }, _initEvents: function(b) {
                b.on("mousedown", function(d) {
                    this._state === "ready" && (this._mayClick = true)
                }, this);
                b.on("mouseup", function(d) {
                    if (this._mayClick) {
                        this._mayClick = false;
                        this._state === "ready" && c.call(this, d)
                    }
                }, this);

                function c(f) {
                    var k = this.seriesModel.get("nodeClick", true);
                    if (!k) {
                        return
                    }
                    var i = this.findTarget(f.offsetX, f.offsetY);
                    if (!i) {
                        return
                    }
                    var h = i.node;
                    if (h.getLayout().isLeafRoot) {
                        this._rootToNode(i)
                    } else {
                        if (k === "zoomToNode") {
                            this._zoomToNode(i)
                        } else {
                            if (k === "link") {
                                var g = h.hostTree.data.getItemModel(h.dataIndex);
                                var j = g.get("link", true);
                                var d = g.get("target", true) || "blank";
                                j && window.open(j, d)
                            }
                        }
                    }
                }
            }, _renderBreadcrumb: function(b, e, d) {
                if (!d) {
                    d = b.get("leafDepth", true) != null ? {node: b.getViewRoot()} : this.findTarget(e.getWidth() / 2, e.getHeight() / 2);
                    if (!d) {
                        d = {node: b.getData().tree.root}
                    }
                }
                (this._breadcrumb || (this._breadcrumb = new G(this.group))).render(b, e, d.node, C(c, this));

                function c(f) {
                    if (this._state !== "animating") {
                        O.aboveViewRoot(b.getViewRoot(), f) ? this._rootToNode({node: f}) : this._zoomToNode({node: f})
                    }
                }
            }, remove: function() {
                this._clearController();
                this._containerGroup && this._containerGroup.removeAll();
                this._storage = D();
                this._state = "ready";
                this._breadcrumb && this._breadcrumb.remove()
            }, dispose: function() {
                this._clearController()
            }, _zoomToNode: function(b) {
                this.api.dispatchAction({type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: b.node})
            }, _rootToNode: function(b) {
                this.api.dispatchAction({type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: b.node})
            }, findTarget: function(c, d) {
                var e;
                var b = this.seriesModel.getViewRoot();
                b.eachNode({attr: "viewChildren", order: "preorder"}, function(g) {
                    var h = this._storage.background[g.getRawIndex()];
                    if (h) {
                        var f = h.transformCoordToLocal(c, d);
                        var i = h.shape;
                        if (i.x <= f[0] && f[0] <= i.x + i.width && i.y <= f[1] && f[1] <= i.y + i.height) {
                            e = {node: g, offsetX: f[0], offsetY: f[1]}
                        } else {
                            return false
                        }
                    }
                }, this);
                return e
            }
        });

        function D() {
            return {nodeGroup: [], background: [], content: []}
        }

        function T(k, q, p, Ag, Ad, g, Ab, i, s, n) {
            if (!Ab) {
                return
            }
            var Aa = Ab.getLayout();
            if (!Aa || !Aa.isInView) {
                return
            }
            var r = Aa.width;
            var o = Aa.height;
            var m = Aa.borderWidth;
            var l = Aa.invisible;
            var Ae = Ab.getRawIndex();
            var c = i && i.getRawIndex();
            var t = Ab.viewChildren;
            var v = Aa.upperHeight;
            var u = t && t.length;
            var b = Ab.getModel("itemStyle.emphasis");
            var x = Af("nodeGroup", F);
            if (!x) {
                return
            }
            s.add(x);
            x.attr("position", [Aa.x || 0, Aa.y || 0]);
            x.__tmNodeWidth = r;
            x.__tmNodeHeight = o;
            if (Aa.isAboveViewRoot) {
                return x
            }
            var h = Af("background", J, n, P);
            h && d(x, h, u && Aa.upperHeight);
            if (!u) {
                var f = Af("content", J, n, E);
                f && j(x, f)
            }
            return x;

            function d(Ai, Ah, Ak) {
                Ah.dataIndex = Ab.dataIndex;
                Ah.seriesIndex = k.seriesIndex;
                Ah.setShape({x: 0, y: 0, width: r, height: o});
                var Aj = Ab.getVisual("borderColor", true);
                var Al = b.get("borderColor");
                z(Ah, function() {
                    var Ao = {fill: Aj};
                    var An = {fill: Al};
                    if (Ak) {
                        var Am = r - 2 * m;
                        Ac(Ao, An, Aj, Am, v, {x: m, y: 0, width: Am, height: v})
                    } else {
                        Ao.text = An.text = ""
                    }
                    Ah.setStyle(Ao);
                    M.setHoverStyle(Ah, An)
                });
                Ai.add(Ah)
            }

            function j(Ah, Ak) {
                Ak.dataIndex = Ab.dataIndex;
                Ak.seriesIndex = k.seriesIndex;
                var Al = Math.max(r - 2 * m, 0);
                var Aj = Math.max(o - 2 * m, 0);
                Ak.culling = true;
                Ak.setShape({x: m, y: m, width: Al, height: Aj});
                var Ai = Ab.getVisual("color", true);
                z(Ak, function() {
                    var An = {fill: Ai};
                    var Am = b.getItemStyle();
                    Ac(An, Am, Ai, Al, Aj);
                    Ak.setStyle(An);
                    M.setHoverStyle(Ak, Am)
                });
                Ah.add(Ak)
            }

            function z(Ai, Ah) {
                if (!l) {
                    Ah();
                    if (!Ai.__tmWillVisible) {
                        Ai.invisible = false
                    }
                } else {
                    !Ai.invisible && g.push(Ai)
                }
            }

            function Ac(Ak, Aj, Ap, Am, Ah, Al) {
                var Ai = Ab.getModel();
                var An = Z.retrieve(k.getFormattedLabel(Ab.dataIndex, "normal", null, null, Al ? "upperLabel" : "label"), Ai.get("name"));
                if (!Al && Aa.isLeafRoot) {
                    var Ao = k.get("drillDownIcon", true);
                    An = Ao ? Ao + " " + An : An
                }
                w(An, Ak, Ai, Al ? B : A, Ap, Am, Ah, Al);
                w(An, Aj, Ai, Al ? Y : N, Ap, Am, Ah, Al)
            }

            function w(An, Am, Aj, Ar, Aq, Ap, Ai, Ao) {
                var Al = Aj.getModel(Ar);
                var Ah = Al.getModel("textStyle");
                M.setText(Am, Al, Aq);
                Am.textAlign = Ah.get("align");
                Am.textVerticalAlign = Ah.get("baseline");
                Ao && (Am.textPositionRect = Z.clone(Ao));
                var Ak = Ah.getTextRect(An);
                if (!Al.getShallow("show") || Ak.height > Ai) {
                    Am.text = ""
                } else {
                    if (Ak.width > Ap) {
                        Am.text = Ah.get("ellipsis") ? Ah.truncateText(An, Ap, null, {minChar: 2}) : ""
                    } else {
                        Am.text = An
                    }
                }
            }

            function Af(Ah, Am, Al, Ai) {
                var Ak = c != null && p[Ah][c];
                var Aj = Ad[Ah];
                if (Ak) {
                    p[Ah][c] = null;
                    e(Aj, Ak, Ah)
                } else {
                    if (!l) {
                        Ak = new Am({z: R(Al, Ai)});
                        Ak.__tmDepth = Al;
                        Ak.__tmStorageName = Ah;
                        y(Aj, Ak, Ah)
                    }
                }
                return (q[Ah][Ae] = Ak)
            }

            function e(Ak, Aj, Ai) {
                var Ah = Ak[Ae] = {};
                Ah.old = Ai === "nodeGroup" ? Aj.position.slice() : Z.extend({}, Aj.shape)
            }

            function y(An, Ah, Am) {
                var Ai = An[Ae] = {};
                var Al = Ab.parentNode;
                if (Al && (!Ag || Ag.direction === "drillDown")) {
                    var Ak = 0;
                    var Aj = 0;
                    var Ao = Ad.background[Al.getRawIndex()];
                    if (!Ag && Ao && Ao.old) {
                        Ak = Ao.old.width;
                        Aj = Ao.old.height
                    }
                    Ai.old = Am === "nodeGroup" ? [0, Aj] : {x: Ak, y: Aj, width: 0, height: 0}
                }
                Ai.fadein = Am !== "nodeGroup"
            }
        }

        function R(b, c) {
            var d = b * V + c;
            return (d - 1) / d
        }
    }, function(L, M, E) {
        var J = E(18);
        var H = E(71);
        var D = E(4);
        var K = E(197);
        var G = 8;
        var A = 8;
        var B = 5;

        function I(N) {
            this.group = new J.Group();
            N.add(this.group)
        }

        I.prototype = {
            constructor: I, render: function(V, T, O, R) {
                var U = V.getModel("breadcrumb");
                var N = this.group;
                N.removeAll();
                if (!U.get("show") || !O) {
                    return
                }
                var S = U.getModel("itemStyle.normal");
                var P = S.getModel("textStyle");
                var Q = {
                    pos: {left: U.get("left"), right: U.get("right"), top: U.get("top"), bottom: U.get("bottom")},
                    box: {width: T.getWidth(), height: T.getHeight()},
                    emptyItemWidth: U.get("emptyItemWidth"),
                    totalWidth: 0,
                    renderList: []
                };
                this._prepare(O, Q, P);
                this._renderContent(V, Q, S, P, R);
                H.positionElement(N, Q.pos, Q.box)
            }, _prepare: function(P, Q, O) {
                for (var N = P; N; N = N.parentNode) {
                    var R = N.getModel().get("name");
                    var S = O.getTextRect(R);
                    var T = Math.max(S.width + G * 2, Q.emptyItemWidth);
                    Q.totalWidth += T + A;
                    Q.renderList.push({node: N, text: R, width: T})
                }
            }, _renderContent: function(Y, S, O, V, a) {
                var T = 0;
                var W = S.emptyItemWidth;
                var Z = Y.get("breadcrumb.height");
                var c = H.getAvailableSize(S.pos, S.box);
                var d = S.totalWidth;
                var U = S.renderList;
                for (var R = U.length - 1; R >= 0; R--) {
                    var P = U[R];
                    var X = P.node;
                    var Q = P.width;
                    var N = P.text;
                    if (d > c.width) {
                        d -= Q - W;
                        Q = W;
                        N = ""
                    }
                    var b = new J.Polygon({
                        shape: {points: F(T, 0, Q, Z, R === U.length - 1, R === 0)},
                        style: D.defaults(O.getItemStyle(), {lineJoin: "bevel", text: N, textFill: V.getTextColor(), textFont: V.getFont()}),
                        z: 10,
                        onclick: D.curry(a, X)
                    });
                    this.group.add(b);
                    C(b, Y, X);
                    T += Q + A
                }
            }, remove: function() {
                this.group.removeAll()
            }
        };

        function F(S, T, R, N, P, Q) {
            var O = [[P ? S : S - B, T], [S + R, T], [S + R, T + N], [P ? S : S - B, T + N]];
            !Q && O.splice(2, 0, [S + R + B, T + N / 2]);
            !P && O.push([S, T + N / 2]);
            return O
        }

        function C(N, O, P) {
            N.eventData = {
                componentType: "series",
                componentSubType: "treemap",
                seriesIndex: O.componentIndex,
                seriesName: O.name,
                seriesType: "treemap",
                selfType: "breadcrumb",
                nodeData: {dataIndex: P && P.dataIndex, name: P && P.name},
                treePathInfo: P && K.wrapTreePathInfo(P, O)
            }
        }

        L.exports = I
    }, function(D, E, B) {
        var A = B(4);

        function C() {
            var F = [];
            var G = {};
            var H;
            return {
                add: function(I, L, K, M, J) {
                    if (A.isString(M)) {
                        J = M;
                        M = 0
                    }
                    if (G[I.id]) {
                        return false
                    }
                    G[I.id] = 1;
                    F.push({el: I, target: L, time: K, delay: M, easing: J});
                    return true
                }, done: function(I) {
                    H = I;
                    return this
                }, start: function() {
                    var J = F.length;
                    for (var I = 0, M = F.length; I < M; I++) {
                        var L = F[I];
                        L.el.animateTo(L.target, L.time, L.delay, L.easing, K)
                    }
                    return this;

                    function K() {
                        J--;
                        if (!J) {
                            F.length = 0;
                            G = {};
                            H && H()
                        }
                    }
                }
            }
        }

        D.exports = {createWrap: C}
    }, function(G, H, C) {
        var B = C(1);
        var F = C(197);
        var E = function() {
        };
        var A = ["treemapZoomToNode", "treemapRender", "treemapMove"];
        for (var D = 0; D < A.length; D++) {
            B.registerAction({type: A[D], update: "updateView"}, E)
        }
        B.registerAction({type: "treemapRootToNode", update: "updateView"}, function(K, J) {
            J.eachComponent({mainType: "series", subType: "treemap", query: K}, I);

            function I(N, M) {
                var L = F.retrieveTargetInfo(K, N);
                if (L) {
                    var O = N.getViewRoot();
                    if (O) {
                        K.direction = F.aboveViewRoot(O, L.node) ? "rollUp" : "drillDown"
                    }
                    N.resetViewRoot(L.node)
                }
            }
        })
    }, function(N, P, D) {
        var A = D(203);
        var I = D(31);
        var C = D(4);
        var B = C.isArray;
        var E = "itemStyle.normal";
        N.exports = function(Q, T, R) {
            var S = {mainType: "series", subType: "treemap", query: R};
            Q.eachComponent(S, function(U) {
                var W = U.getData().tree;
                var V = W.root;
                var X = U.getModel(E);
                if (V.isRemoved()) {
                    return
                }
                var Y = C.map(W.levelModels, function(Z) {
                    return Z ? Z.get(E) : null
                });
                K(V, {}, Y, X, U.getViewRoot().getAncestors(), U)
            })
        };

        function K(Y, c, a, R, d, f) {
            var S = Y.getModel();
            var W = Y.getLayout();
            if (!W || W.invisible || !W.isInView) {
                return
            }
            var T = Y.getModel(E);
            var e = a[Y.depth];
            var U = G(T, c, e, R);
            var b = T.get("borderColor");
            var X = T.get("borderColorSaturation");
            var V;
            if (X != null) {
                V = H(U, Y);
                b = L(X, V)
            }
            Y.setVisual("borderColor", b);
            var Q = Y.viewChildren;
            if (!Q || !Q.length) {
                V = H(U, Y);
                Y.setVisual("color", V)
            } else {
                var Z = J(Y, S, W, T, U, Q);
                C.each(Q, function(g, h) {
                    if (g.depth >= d.length || g === d[g.depth]) {
                        var i = F(S, U, g, h, Z, f);
                        K(g, i, a, R, d, f)
                    }
                })
            }
        }

        function G(S, U, T, R) {
            var Q = C.extend({}, U);
            C.each(["color", "colorAlpha", "colorSaturation"], function(V) {
                var W = S.get(V, true);
                W == null && T && (W = T[V]);
                W == null && (W = U[V]);
                W == null && (W = R.get(V));
                W != null && (Q[V] = W)
            });
            return Q
        }

        function H(S) {
            var T = O(S, "color");
            if (T) {
                var Q = O(S, "colorAlpha");
                var R = O(S, "colorSaturation");
                if (R) {
                    T = I.modifyHSL(T, null, null, R)
                }
                if (Q) {
                    T = I.modifyAlpha(T, Q)
                }
                return T
            }
        }

        function L(Q, R) {
            return R != null ? I.modifyHSL(R, null, null, Q) : null
        }

        function O(S, R) {
            var Q = S[R];
            if (Q != null && Q !== "none") {
                return Q
            }
        }

        function J(W, Q, V, R, T, a) {
            if (!a || !a.length) {
                return
            }
            var Z = M(Q, "color") || (T.color != null && T.color !== "none" && (M(Q, "colorAlpha") || M(Q, "colorSaturation")));
            if (!Z) {
                return
            }
            var U = Q.get("visualMin");
            var S = Q.get("visualMax");
            var b = V.dataExtent.slice();
            U != null && U < b[0] && (b[0] = U);
            S != null && S > b[1] && (b[1] = S);
            var Y = Q.get("colorMappingBy");
            var X = {type: Z.name, dataExtent: b, visual: Z.range};
            if (X.type === "color" && (Y === "index" || Y === "id")) {
                X.mappingMethod = "category";
                X.loop = true
            } else {
                X.mappingMethod = "linear"
            }
            var c = new A(X);
            c.__drColorMappingBy = Y;
            return c
        }

        function M(Q, R) {
            var S = Q.get(R);
            return (B(S) && S.length) ? {name: R, range: S} : null
        }

        function F(X, S, W, R, Z, Y) {
            var U = C.extend({}, S);
            if (Z) {
                var T = Z.type;
                var Q = T === "color" && Z.__drColorMappingBy;
                var V = Q === "index" ? R : Q === "id" ? Y.mapIdToIndex(W.getId()) : W.getValue(X.get("visualDimension"));
                U[T] = Z.mapValueToVisual(V)
            }
            return U
        }
    }, function(T, J, U) {
        var H = U(4);
        var A = U(31);
        var P = U(7).linearMap;
        var K = H.each;
        var R = H.isObject;
        var E = -1;
        var G = function(Y) {
            var a = Y.mappingMethod;
            var Z = Y.type;
            var c = this.option = H.clone(Y);
            this.type = Z;
            this.mappingMethod = a;
            this._normalizeData = I[a];
            var b = L[Z];
            this.applyVisual = b.applyVisual;
            this.getColorMapper = b.getColorMapper;
            this._doMap = b._doMap[a];
            if (a === "piecewise") {
                N(c);
                F(c)
            } else {
                if (a === "category") {
                    c.categories ? B(c) : N(c, true)
                } else {
                    H.assert(a !== "linear" || c.dataExtent);
                    N(c)
                }
            }
        };
        G.prototype = {
            constructor: G, mapValueToVisual: function(Y) {
                var Z = this._normalizeData(Y);
                return this._doMap(Z, Y)
            }, getNormalizer: function() {
                return H.bind(this._normalizeData, this)
            }
        };
        var L = G.visualHandlers = {
            color: {
                applyVisual: O("color"), getColorMapper: function() {
                    var Y = this.option;
                    return H.bind(Y.mappingMethod === "category" ? function(a, Z) {
                        !Z && (a = this._normalizeData(a));
                        return D.call(this, a)
                    } : function(c, a, b) {
                        var Z = !!b;
                        !a && (c = this._normalizeData(c));
                        b = A.fastMapToColor(c, Y.parsedVisual, b);
                        return Z ? b : A.stringify(b, "rgba")
                    }, this)
                }, _doMap: {
                    linear: function(Y) {
                        return A.stringify(A.fastMapToColor(Y, this.option.parsedVisual), "rgba")
                    }, category: D, piecewise: function(a, Z) {
                        var Y = C.call(this, Z);
                        if (Y == null) {
                            Y = A.stringify(A.fastMapToColor(a, this.option.parsedVisual), "rgba")
                        }
                        return Y
                    }, fixed: W
                }
            }, colorHue: Q(function(Z, Y) {
                return A.modifyHSL(Z, Y)
            }), colorSaturation: Q(function(Z, Y) {
                return A.modifyHSL(Z, null, Y)
            }), colorLightness: Q(function(Z, Y) {
                return A.modifyHSL(Z, null, null, Y)
            }), colorAlpha: Q(function(Z, Y) {
                return A.modifyAlpha(Z, Y)
            }), opacity: {applyVisual: O("opacity"), _doMap: M([0, 1])}, symbol: {
                applyVisual: function(b, a, c) {
                    var Y = this.mapValueToVisual(b);
                    if (H.isString(Y)) {
                        c("symbol", Y)
                    } else {
                        if (R(Y)) {
                            for (var Z in Y) {
                                if (Y.hasOwnProperty(Z)) {
                                    c(Z, Y[Z])
                                }
                            }
                        }
                    }
                }, _doMap: {
                    linear: S, category: D, piecewise: function(a, Z) {
                        var Y = C.call(this, Z);
                        if (Y == null) {
                            Y = S.call(this, a)
                        }
                        return Y
                    }, fixed: W
                }
            }, symbolSize: {applyVisual: O("symbolSize"), _doMap: M([0, 1])}
        };

        function F(Z) {
            var Y = Z.pieceList;
            Z.hasSpecialVisual = false;
            H.each(Y, function(a, b) {
                a.originIndex = b;
                if (a.visual != null) {
                    Z.hasSpecialVisual = true
                }
            })
        }

        function B(d) {
            var c = d.categories;
            var b = d.visual;
            var a = d.categoryMap = {};
            K(c, function(e, f) {
                a[e] = f
            });
            if (!H.isArray(b)) {
                var Y = [];
                if (H.isObject(b)) {
                    K(b, function(f, e) {
                        var g = a[e];
                        Y[g != null ? g : E] = f
                    })
                } else {
                    Y[E] = b
                }
                b = V(d, Y)
            }
            for (var Z = c.length - 1; Z >= 0; Z--) {
                if (b[Z] == null) {
                    delete a[c[Z]];
                    c.pop()
                }
            }
        }

        function N(c, Z) {
            var a = c.visual;
            var Y = [];
            if (H.isObject(a)) {
                K(a, function(d) {
                    Y.push(d)
                })
            } else {
                if (a != null) {
                    Y.push(a)
                }
            }
            var b = {color: 1, symbol: 1};
            if (!Z && Y.length === 1 && !b.hasOwnProperty(c.type)) {
                Y[1] = Y[0]
            }
            V(c, Y)
        }

        function Q(Y) {
            return {
                applyVisual: function(a, Z, b) {
                    a = this.mapValueToVisual(a);
                    b("color", Y(Z("color"), a))
                }, _doMap: M([0, 1])
            }
        }

        function S(Z) {
            var Y = this.option.visual;
            return Y[Math.round(P(Z, [0, 1], [0, Y.length - 1], true))] || {}
        }

        function O(Y) {
            return function(a, Z, b) {
                b(Y, this.mapValueToVisual(a))
            }
        }

        function D(Z) {
            var Y = this.option.visual;
            return Y[(this.option.loop && Z !== E) ? Z % Y.length : Z]
        }

        function W() {
            return this.option.visual[0]
        }

        function M(Y) {
            return {
                linear: function(Z) {
                    return P(Z, Y, this.option.visual, true)
                }, category: D, piecewise: function(b, a) {
                    var Z = C.call(this, a);
                    if (Z == null) {
                        Z = P(b, Y, this.option.visual, true)
                    }
                    return Z
                }, fixed: W
            }
        }

        function C(a) {
            var c = this.option;
            var Z = c.pieceList;
            if (c.hasSpecialVisual) {
                var b = G.findPieceIndex(a, Z);
                var Y = Z[b];
                if (Y && Y.visual) {
                    return Y.visual[this.type]
                }
            }
        }

        function V(Z, Y) {
            Z.visual = Y;
            if (Z.type === "color") {
                Z.parsedVisual = H.map(Y, function(a) {
                    return A.parse(a)
                })
            }
            return Y
        }

        var I = {
            linear: function(Y) {
                return P(Y, this.option.dataExtent, [0, 1], true)
            }, piecewise: function(Y) {
                var a = this.option.pieceList;
                var Z = G.findPieceIndex(Y, a, true);
                if (Z != null) {
                    return P(Z, [0, a.length - 1], [0, 1], true)
                }
            }, category: function(Z) {
                var Y = this.option.categories ? this.option.categoryMap[Z] : Z;
                return Y == null ? E : Y
            }, fixed: H.noop
        };
        G.listVisualTypes = function() {
            var Y = [];
            H.each(L, function(a, Z) {
                Y.push(Z)
            });
            return Y
        };
        G.addVisualHandler = function(Z, Y) {
            L[Z] = Y
        };
        G.isValidType = function(Y) {
            return L.hasOwnProperty(Y)
        };
        G.eachVisual = function(a, Y, Z) {
            if (H.isObject(a)) {
                H.each(a, Y, Z)
            } else {
                Y.call(Z, a)
            }
        };
        G.mapVisual = function(c, Y, Z) {
            var a;
            var b = H.isArray(c) ? [] : H.isObject(c) ? {} : (a = true, null);
            G.eachVisual(c, function(e, d) {
                var f = Y.call(Z, e, d);
                a ? (b = f) : (b[d] = f)
            });
            return b
        };
        G.retrieveVisuals = function(Z) {
            var a = {};
            var Y;
            Z && K(L, function(b, c) {
                if (Z.hasOwnProperty(c)) {
                    a[c] = Z[c];
                    Y = true
                }
            });
            return Y ? a : null
        };
        G.prepareVisualTypes = function(Z) {
            if (R(Z)) {
                var Y = [];
                K(Z, function(b, a) {
                    Y.push(a)
                });
                Z = Y
            } else {
                if (H.isArray(Z)) {
                    Z = Z.slice()
                } else {
                    return []
                }
            }
            Z.sort(function(b, a) {
                return (a === "color" && b !== "color" && b.indexOf("color") === 0) ? 1 : -1
            });
            return Z
        };
        G.dependsOn = function(Y, Z) {
            return Z === "color" ? !!(Y && Y.indexOf(Z) === 0) : Y === Z
        };
        G.findPieceIndex = function(d, Z, Y) {
            var j;
            var f = Infinity;
            for (var e = 0, h = Z.length; e < h; e++) {
                var g = Z[e].value;
                if (g != null) {
                    if (g === d || (typeof g === "string" && g === d + "")) {
                        return e
                    }
                    Y && b(g, e)
                }
            }
            for (var e = 0, h = Z.length; e < h; e++) {
                var k = Z[e];
                var a = k.interval;
                var c = k.close;
                if (a) {
                    if (a[0] === -Infinity) {
                        if (X(c[1], d, a[1])) {
                            return e
                        }
                    } else {
                        if (a[1] === Infinity) {
                            if (X(c[0], a[0], d)) {
                                return e
                            }
                        } else {
                            if (X(c[0], a[0], d) && X(c[1], d, a[1])) {
                                return e
                            }
                        }
                    }
                    Y && b(a[0], e);
                    Y && b(a[1], e)
                }
            }
            if (Y) {
                return d === Infinity ? Z.length - 1 : d === -Infinity ? 0 : j
            }

            function b(m, l) {
                var i = Math.abs(m - d);
                if (i < f) {
                    f = i;
                    j = l
                }
            }
        };

        function X(c, Z, Y) {
            return c ? Z <= Y : Z < Y
        }

        T.exports = G
    }, function(T, G, W) {
        var F = W(4);
        var R = W(7);
        var J = W(71);
        var P = W(197);
        var Z = W(9);
        var P = W(197);
        var Q = Math.max;
        var Y = Math.min;
        var E = R.parsePercent;
        var D = F.retrieve;
        var I = F.each;
        var L = ["itemStyle", "normal", "borderWidth"];
        var H = ["itemStyle", "normal", "gapWidth"];
        var U = ["upperLabel", "normal", "show"];
        var A = ["upperLabel", "normal", "height"];

        function V(d, g, e) {
            var f = {mainType: "series", subType: "treemap", query: e};
            d.eachComponent(f, function(l) {
                var j = g.getWidth();
                var o = g.getHeight();
                var t = l.option;
                var p = J.getLayoutRect(l.getBoxLayoutParams(), {width: g.getWidth(), height: g.getHeight()});
                var k = t.size || [];
                var x = E(D(p.width, k[0]), j);
                var h = E(D(p.height, k[1]), o);
                var u = e && e.type;
                var y = P.retrieveTargetInfo(e, l);
                var i = (u === "treemapRender" || u === "treemapMove") ? e.rootRect : null;
                var s = l.getViewRoot();
                var m = P.getPathToRoot(s);
                if (u !== "treemapMove") {
                    var n = u === "treemapZoomToNode" ? M(l, y, s, x, h) : i ? [i.width, i.height] : [x, h];
                    var r = t.sort;
                    if (r && r !== "asc" && r !== "desc") {
                        r = "desc"
                    }
                    var q = {squareRatio: t.squareRatio, sort: r, leafDepth: t.leafDepth};
                    s.hostTree.clearLayouts();
                    var v = {x: 0, y: 0, width: n[0], height: n[1], area: n[0] * n[1]};
                    s.setLayout(v);
                    b(s, q, false, 0);
                    var v = s.getLayout();
                    I(m, function(z, Aa) {
                        var Ab = (m[Aa + 1] || s).getValue();
                        z.setLayout(F.extend({dataExtent: [Ab, Ab], borderWidth: 0, upperHeight: 0}, v))
                    })
                }
                var w = l.getData().tree.root;
                w.setLayout(B(p, i, y), true);
                l.setLayoutInfo(p);
                O(w, new Z(-p.x, -p.y, j, o), m, s, 0)
            })
        }

        function b(v, w, p, o) {
            var s;
            var r;
            if (v.isRemoved()) {
                return
            }
            var x = v.getLayout();
            s = x.width;
            r = x.height;
            var Ab = v.getModel();
            var n = Ab.get(L);
            var Aa = Ab.get(H) / 2;
            var Ac = c(Ab);
            var z = Math.max(n, Ac);
            var q = n - Aa;
            var e = z - Aa;
            var Ab = v.getModel();
            v.setLayout({borderWidth: n, upperHeight: z, upperLabelHeight: Ac}, true);
            s = Q(s - 2 * q, 0);
            r = Q(r - q - e, 0);
            var u = s * r;
            var k = C(v, Ab, u, w, p, o);
            if (!k.length) {
                return
            }
            var m = {x: q, y: e, width: s, height: r};
            var g = Y(s, r);
            var t = Infinity;
            var f = [];
            f.area = 0;
            for (var j = 0, y = k.length; j < y;) {
                var h = k[j];
                f.push(h);
                f.area += h.getLayout().area;
                var d = N(f, g, w.squareRatio);
                if (d <= t) {
                    j++;
                    t = d
                } else {
                    f.area -= f.pop().getLayout().area;
                    X(f, g, m, Aa, false);
                    g = Y(m.width, m.height);
                    f.length = f.area = 0;
                    t = Infinity
                }
            }
            if (f.length) {
                X(f, g, m, Aa, true)
            }
            if (!p) {
                var l = Ab.get("childrenVisibleMin");
                if (l != null && u < l) {
                    p = true
                }
            }
            for (var j = 0, y = k.length; j < y; j++) {
                b(k[j], w, p, o + 1)
            }
        }

        function C(m, f, n, k, q, l) {
            var p = m.children || [];
            var e = k.sort;
            e !== "asc" && e !== "desc" && (e = null);
            var h = k.leafDepth != null && k.leafDepth <= l;
            if (q && !h) {
                return (m.viewChildren = [])
            }
            p = F.filter(p, function(i) {
                return !i.isRemoved()
            });
            S(p, e);
            var d = K(f, p, e);
            if (d.sum === 0) {
                return (m.viewChildren = [])
            }
            d.sum = a(f, n, d.sum, e, p);
            if (d.sum === 0) {
                return (m.viewChildren = [])
            }
            for (var j = 0, o = p.length; j < o; j++) {
                var g = p[j].getValue() / d.sum * n;
                p[j].setLayout({area: g})
            }
            if (h) {
                p.length && m.setLayout({isLeafRoot: true}, true);
                p.length = 0
            }
            m.viewChildren = p;
            m.setLayout({dataExtent: d.dataExtent}, true);
            return p
        }

        function a(f, k, h, m, n) {
            if (!m) {
                return h
            }
            var e = f.get("visibleMin");
            var l = n.length;
            var d = l;
            for (var j = l - 1; j >= 0; j--) {
                var g = n[m === "asc" ? l - j - 1 : j].getValue();
                if (g / h * k < e) {
                    d = j;
                    h -= g
                }
            }
            m === "asc" ? n.splice(0, l - d) : n.splice(d, l - d);
            return h
        }

        function S(e, d) {
            if (d) {
                e.sort(function(g, f) {
                    var h = d === "asc" ? g.getValue() - f.getValue() : f.getValue() - g.getValue();
                    return h === 0 ? (d === "asc" ? g.dataIndex - f.dataIndex : f.dataIndex - g.dataIndex) : h
                })
            }
            return e
        }

        function K(d, f, k) {
            var g = 0;
            for (var h = 0, j = f.length; h < j; h++) {
                g += f[h].getValue()
            }
            var l = d.get("visualDimension");
            var e;
            if (!f || !f.length) {
                e = [NaN, NaN]
            } else {
                if (l === "value" && k) {
                    e = [f[f.length - 1].getValue(), f[0].getValue()];
                    k === "asc" && e.reverse()
                } else {
                    var e = [Infinity, -Infinity];
                    I(f, function(i) {
                        var m = i.getValue(l);
                        m < e[0] && (e[0] = m);
                        m > e[1] && (e[1] = m)
                    })
                }
            }
            return {sum: g, dataExtent: e}
        }

        function N(k, g, d) {
            var l = 0;
            var o = Infinity;
            for (var j = 0, e, m = k.length; j < m; j++) {
                e = k[j].getLayout().area;
                if (e) {
                    e < o && (o = e);
                    e > l && (l = e)
                }
            }
            var h = k.area * k.area;
            var n = g * g * d;
            return h ? Q((n * l) / h, h / (n * o)) : Infinity
        }

        function X(w, x, o, v, s) {
            var d = x === o.width ? 0 : 1;
            var n = 1 - d;
            var g = ["x", "y"];
            var h = ["width", "height"];
            var t = o[g[d]];
            var l = x ? w.area / x : 0;
            if (s || l > o[h[n]]) {
                l = o[h[n]]
            }
            for (var k = 0, u = w.length; k < u; k++) {
                var r = w[k];
                var m = {};
                var f = l ? r.getLayout().area / l : 0;
                var q = m[h[n]] = Q(l - 2 * v, 0);
                var j = o[g[d]] + o[h[d]] - t;
                var e = (k === u - 1 || j < f) ? j : f;
                var p = m[h[d]] = Q(e - 2 * v, 0);
                m[g[n]] = o[g[n]] + Y(v, q / 2);
                m[g[d]] = t + Y(v, p / 2);
                t += e;
                r.setLayout(m, true)
            }
            o[g[n]] += l;
            o[h[n]] -= l
        }

        function M(j, w, s, v, n) {
            var q = (w || {}).node;
            var f = [v, n];
            if (!q || q === s) {
                return f
            }
            var r;
            var t = v * n;
            var u = t * j.option.zoomToNodeRatio;
            while (r = q.parentNode) {
                var m = 0;
                var d = r.children;
                for (var h = 0, e = d.length; h < e; h++) {
                    m += d[h].getValue()
                }
                var k = q.getValue();
                if (k === 0) {
                    return f
                }
                u *= m / k;
                var g = r.getModel();
                var l = g.get(L);
                var p = Math.max(l, c(g, l));
                u += 4 * l * l + (3 * l + p) * Math.pow(u, 0.5);
                u > R.MAX_SAFE_INTEGER && (u = R.MAX_SAFE_INTEGER);
                q = r
            }
            u < t && (u = t);
            var o = Math.pow(u / t, 0.5);
            return [v * o, n * o]
        }

        function B(e, k, j) {
            if (k) {
                return {x: k.x, y: k.y}
            }
            var l = {x: 0, y: 0};
            if (!j) {
                return l
            }
            var d = j.node;
            var f = d.getLayout();
            if (!f) {
                return l
            }
            var h = [f.width / 2, f.height / 2];
            var g = d;
            while (g) {
                var i = g.getLayout();
                h[0] += i.x;
                h[1] += i.y;
                g = g.parentNode
            }
            return {x: e.width / 2 - h[0], y: e.height / 2 - h[1]}
        }

        function O(k, i, g, h, l) {
            var j = k.getLayout();
            var f = g[l];
            var e = f && f === k;
            if ((f && !e) || (l === g.length && k !== h)) {
                return
            }
            k.setLayout({isInView: true, invisible: !e && !i.intersect(j), isAboveViewRoot: e}, true);
            var d = new Z(i.x - j.x, i.y - j.y, i.width, i.height);
            I(k.viewChildren || [], function(m) {
                O(m, d, g, h, l + 1)
            })
        }

        function c(d) {
            return d.get(U) ? d.get(A) : 0
        }

        T.exports = V
    }, function(C, E, B) {
        var D = B(1);
        var A = B(4);
        B(206);
        B(209);
        B(214);
        D.registerProcessor(B(215));
        D.registerVisual(A.curry(B(121), "graph", "circle", null));
        D.registerVisual(B(216));
        D.registerVisual(B(217));
        D.registerLayout(B(218));
        D.registerLayout(B(221));
        D.registerLayout(B(223));
        D.registerCoordinateSystem("graphView", {create: B(225)})
    }, function(H, J, C) {
        var I = C(98);
        var B = C(4);
        var A = C(5);
        var G = C(12);
        var E = C(6);
        var F = C(207);
        var D = C(1).extendSeriesModel({
            type: "series.graph",
            init: function(K) {
                D.superApply(this, "init", arguments);
                this.legendDataProvider = function() {
                    return this._categoriesData
                };
                this.fillDataTextStyle(K.edges || K.links);
                this._updateCategoriesData()
            },
            mergeOption: function(K) {
                D.superApply(this, "mergeOption", arguments);
                this.fillDataTextStyle(K.edges || K.links);
                this._updateCategoriesData()
            },
            mergeDefaultAndTheme: function(K) {
                D.superApply(this, "mergeDefaultAndTheme", arguments);
                A.defaultEmphasis(K.edgeLabel, A.LABEL_OPTIONS)
            },
            getInitialData: function(K, M) {
                var L = K.edges || K.links || [];
                var N = K.data || K.nodes || [];
                var O = this;
                if (N && L) {
                    return F(N, L, this, true, P).data
                }

                function P(U, R) {
                    U.wrapMethod("getItemModel", function(Y) {
                        var X = O._categoriesModels;
                        var W = Y.getShallow("category");
                        var V = X[W];
                        if (V) {
                            V.parentModel = Y.parentModel;
                            Y.parentModel = V
                        }
                        return Y
                    });
                    var T = O.getModel("edgeLabel");
                    var S = new G({label: T.option}, T.parentModel, M);
                    R.wrapMethod("getItemModel", function(V) {
                        V.customizeGetParent(Q);
                        return V
                    });

                    function Q(V) {
                        V = this.parsePath(V);
                        return (V && V[0] === "label") ? S : this.parentModel
                    }
                }
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            getCategoriesData: function() {
                return this._categoriesData
            },
            formatTooltip: function(M, K, L) {
                if (L === "edge") {
                    var N = this.getData();
                    var P = this.getDataParams(M, L);
                    var Q = N.graph.getEdgeByIndex(M);
                    var R = N.getName(Q.node1.dataIndex);
                    var O = N.getName(Q.node2.dataIndex);
                    var S = [];
                    R != null && S.push(R);
                    O != null && S.push(O);
                    S = E.encodeHTML(S.join(" > "));
                    if (P.value) {
                        S += " : " + E.encodeHTML(P.value)
                    }
                    return S
                } else {
                    return D.superApply(this, "formatTooltip", arguments)
                }
            },
            _updateCategoriesData: function() {
                var L = B.map(this.option.categories || [], function(M) {
                    return M.value != null ? M : B.extend({value: 0}, M)
                });
                var K = new I(["value"], this);
                K.initData(L);
                this._categoriesData = K;
                this._categoriesModels = K.mapArray(function(M) {
                    return K.getItemModel(M, true)
                })
            },
            setZoom: function(K) {
                this.option.zoom = K
            },
            setCenter: function(K) {
                this.option.center = K
            },
            isAnimationEnabled: function() {
                return D.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"))
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                legendHoverLink: true,
                hoverAnimation: true,
                layout: null,
                focusNodeAdjacency: false,
                circular: {rotateLabel: false},
                force: {initLayout: null, repulsion: [0, 50], gravity: 0.1, edgeLength: 30, layoutAnimation: true},
                left: "center",
                top: "center",
                symbol: "circle",
                symbolSize: 10,
                edgeSymbol: ["none", "none"],
                edgeSymbolSize: 10,
                edgeLabel: {normal: {position: "middle"}, emphasis: {}},
                draggable: false,
                roam: false,
                center: null,
                zoom: 1,
                nodeScaleRatio: 0.6,
                label: {normal: {show: false, formatter: "{b}"}, emphasis: {show: true}},
                itemStyle: {normal: {}, emphasis: {}},
                lineStyle: {normal: {color: "#aaa", width: 1, curveness: 0, opacity: 0.5}, emphasis: {}}
            }
        });
        H.exports = D
    }, function(H, J, D) {
        var I = D(98);
        var B = D(208);
        var F = D(196);
        var A = D(110);
        var G = D(76);
        var C = D(4);
        var E = D(109);
        H.exports = function(N, Z, K, M, V) {
            var X = new B(M);
            for (var O = 0; O < N.length; O++) {
                X.addNode(C.retrieve(N[O].id, N[O].name, O), O)
            }
            var L = [];
            var Q = [];
            var P = 0;
            for (var O = 0; O < Z.length; O++) {
                var U = Z[O];
                var T = U.source;
                var Y = U.target;
                if (X.addEdge(T, Y, P)) {
                    Q.push(U);
                    L.push(C.retrieve(U.id, T + " > " + Y));
                    P++
                }
            }
            var S = K.get("coordinateSystem");
            var R;
            if (S === "cartesian2d" || S === "polar") {
                R = E(N, K, K.ecModel)
            } else {
                var b = G.get(S);
                var W = A(((b && b.type !== "view") ? (b.dimensions || []) : []).concat(["value"]), N);
                R = new I(W, K);
                R.initData(N)
            }
            var a = new I(["value"], K);
            a.initData(Q, L);
            V && V(R, a);
            F({mainData: R, struct: X, structAttr: "graph", datas: {node: R, edge: a}, datasAttr: {node: "data", edge: "edgeData"}});
            X.update();
            return X
        }
    }, function(I, J, C) {
        var B = C(4);

        function H(K) {
            return "_EC_" + K
        }

        var A = function(K) {
            this._directed = K || false;
            this.nodes = [];
            this.edges = [];
            this._nodesMap = {};
            this._edgesMap = {};
            this.data;
            this.edgeData
        };
        var F = A.prototype;
        F.type = "graph";
        F.isDirected = function() {
            return this._directed
        };
        F.addNode = function(N, K) {
            N = N || ("" + K);
            var M = this._nodesMap;
            if (M[H(N)]) {
                if (true) {
                    console.error("Graph nodes have duplicate name or id")
                }
                return
            }
            var L = new E(N, K);
            L.hostGraph = this;
            this.nodes.push(L);
            M[H(N)] = L;
            return L
        };
        F.getNodeByIndex = function(K) {
            var L = this.data.getRawIndex(K);
            return this.nodes[L]
        };
        F.getNodeById = function(K) {
            return this._nodesMap[H(K)]
        };
        F.addEdge = function(N, O, L) {
            var P = this._nodesMap;
            var K = this._edgesMap;
            if (typeof N === "number") {
                N = this.nodes[N]
            }
            if (typeof O === "number") {
                O = this.nodes[O]
            }
            if (!(N instanceof E)) {
                N = P[H(N)]
            }
            if (!(O instanceof E)) {
                O = P[H(O)]
            }
            if (!N || !O) {
                return
            }
            var Q = N.id + "-" + O.id;
            if (K[Q]) {
                return
            }
            var M = new G(N, O, L);
            M.hostGraph = this;
            if (this._directed) {
                N.outEdges.push(M);
                O.inEdges.push(M)
            }
            N.edges.push(M);
            if (N !== O) {
                O.edges.push(M)
            }
            this.edges.push(M);
            K[Q] = M;
            return M
        };
        F.getEdgeByIndex = function(K) {
            var L = this.edgeData.getRawIndex(K);
            return this.edges[L]
        };
        F.getEdge = function(K, L) {
            if (K instanceof E) {
                K = K.id
            }
            if (L instanceof E) {
                L = L.id
            }
            var M = this._edgesMap;
            if (this._directed) {
                return M[K + "-" + L]
            } else {
                return M[K + "-" + L] || M[L + "-" + K]
            }
        };
        F.eachNode = function(K, L) {
            var N = this.nodes;
            var O = N.length;
            for (var M = 0; M < O; M++) {
                if (N[M].dataIndex >= 0) {
                    K.call(L, N[M], M)
                }
            }
        };
        F.eachEdge = function(K, L) {
            var M = this.edges;
            var O = M.length;
            for (var N = 0; N < O; N++) {
                if (M[N].dataIndex >= 0 && M[N].node1.dataIndex >= 0 && M[N].node2.dataIndex >= 0) {
                    K.call(L, M[N], N)
                }
            }
        };
        F.breadthFirstTraverse = function(O, N, L, Q) {
            if (!(N instanceof E)) {
                N = this._nodesMap[H(N)]
            }
            if (!N) {
                return
            }
            var R = L === "out" ? "outEdges" : (L === "in" ? "inEdges" : "edges");
            for (var S = 0; S < this.nodes.length; S++) {
                this.nodes[S].__visited = false
            }
            if (O.call(Q, N, null)) {
                return
            }
            var P = [N];
            while (P.length) {
                var T = P.shift();
                var M = T[R];
                for (var S = 0; S < M.length; S++) {
                    var K = M[S];
                    var U = K.node1 === T ? K.node2 : K.node1;
                    if (!U.__visited) {
                        if (O.call(Q, U, T)) {
                            return
                        }
                        P.push(U);
                        U.__visited = true
                    }
                }
            }
        };
        F.update = function() {
            var P = this.data;
            var M = this.edgeData;
            var N = this.nodes;
            var L = this.edges;
            for (var K = 0, O = N.length; K < O; K++) {
                N[K].dataIndex = -1
            }
            for (var K = 0, O = P.count(); K < O; K++) {
                N[P.getRawIndex(K)].dataIndex = K
            }
            M.filterSelf(function(R) {
                var Q = L[M.getRawIndex(R)];
                return Q.node1.dataIndex >= 0 && Q.node2.dataIndex >= 0
            });
            for (var K = 0, O = L.length; K < O; K++) {
                L[K].dataIndex = -1
            }
            for (var K = 0, O = M.count(); K < O; K++) {
                L[M.getRawIndex(K)].dataIndex = K
            }
        };
        F.clone = function() {
            var M = new A(this._directed);
            var N = this.nodes;
            var L = this.edges;
            for (var K = 0; K < N.length; K++) {
                M.addNode(N[K].id, N[K].dataIndex)
            }
            for (var K = 0; K < L.length; K++) {
                var O = L[K];
                M.addEdge(O.node1.id, O.node2.id, O.dataIndex)
            }
            return M
        };

        function E(L, K) {
            this.id = L == null ? "" : L;
            this.inEdges = [];
            this.outEdges = [];
            this.edges = [];
            this.hostGraph;
            this.dataIndex = K == null ? -1 : K
        }

        E.prototype = {
            constructor: E, degree: function() {
                return this.edges.length
            }, inDegree: function() {
                return this.inEdges.length
            }, outDegree: function() {
                return this.outEdges.length
            }, getModel: function(M) {
                if (this.dataIndex < 0) {
                    return
                }
                var L = this.hostGraph;
                var K = L.data.getItemModel(this.dataIndex);
                return K.getModel(M)
            }
        };

        function G(L, M, K) {
            this.node1 = L;
            this.node2 = M;
            this.dataIndex = K == null ? -1 : K
        }

        G.prototype.getModel = function(M) {
            if (this.dataIndex < 0) {
                return
            }
            var L = this.hostGraph;
            var K = L.edgeData.getItemModel(this.dataIndex);
            return K.getModel(M)
        };
        var D = function(K, L) {
            return {
                getValue: function(M) {
                    var N = this[K][L];
                    return N.get(N.getDimension(M || "value"), this.dataIndex)
                }, setVisual: function(M, N) {
                    this.dataIndex >= 0 && this[K][L].setItemVisual(this.dataIndex, M, N)
                }, getVisual: function(M, N) {
                    return this[K][L].getItemVisual(this.dataIndex, M, N)
                }, setLayout: function(N, M) {
                    this.dataIndex >= 0 && this[K][L].setItemLayout(this.dataIndex, N, M)
                }, getLayout: function() {
                    return this[K][L].getItemLayout(this.dataIndex)
                }, getGraphicEl: function() {
                    return this[K][L].getItemGraphicEl(this.dataIndex)
                }, getRawIndex: function() {
                    return this[K][L].getRawIndex(this.dataIndex)
                }
            }
        };
        B.mixin(E, D("hostGraph", "data"));
        B.mixin(G, D("hostGraph", "edgeData"));
        A.Node = E;
        A.Edge = G;
        I.exports = A
    }, function(L, N, G) {
        var H = G(116);
        var C = G(210);
        var D = G(183);
        var K = G(185);
        var A = G(186);
        var J = G(18);
        var M = G(213);
        var F = G(4);
        var I = ["itemStyle", "normal", "opacity"];
        var B = ["lineStyle", "normal", "opacity"];

        function E(P, O) {
            return P.getVisual("opacity") || P.getModel().get(O)
        }

        G(1).extendChartView({
            type: "graph", init: function(Q, S) {
                var R = new H();
                var O = new C();
                var P = this.group;
                this._controller = new D(S.getZr());
                this._controllerHost = {target: P};
                P.add(R.group);
                P.add(O.group);
                this._symbolDraw = R;
                this._lineDraw = O;
                this._firstRender = true
            }, render: function(c, P, a) {
                var Q = c.coordinateSystem;
                this._model = c;
                this._nodeScaleRatio = c.get("nodeScaleRatio");
                var Z = this._symbolDraw;
                var U = this._lineDraw;
                var X = this.group;
                if (Q.type === "view") {
                    var O = {position: Q.position, scale: Q.scale};
                    if (this._firstRender) {
                        X.attr(O)
                    } else {
                        J.updateProps(X, O, c)
                    }
                }
                M(c.getGraph(), this._getNodeGlobalScale(c));
                var S = c.getData();
                Z.updateData(S);
                var Y = c.getEdgeData();
                U.updateData(Y);
                this._updateNodeAndLinkScale();
                this._updateController(c, P, a);
                clearTimeout(this._layoutTimeout);
                var T = c.forceLayout;
                var b = c.get("force.layoutAnimation");
                if (T) {
                    this._startForceLayoutIteration(T, b)
                }
                S.eachItemGraphicEl(function(d, g) {
                    var f = S.getItemModel(g);
                    d.off("drag").off("dragend");
                    var e = S.getItemModel(g).get("draggable");
                    if (e) {
                        d.on("drag", function() {
                            if (T) {
                                T.warmUp();
                                !this._layouting && this._startForceLayoutIteration(T, b);
                                T.setFixed(g);
                                S.setItemLayout(g, d.position)
                            }
                        }, this).on("dragend", function() {
                            if (T) {
                                T.setUnfixed(g)
                            }
                        }, this)
                    }
                    d.setDraggable(e && T);
                    d.off("mouseover", d.__focusNodeAdjacency);
                    d.off("mouseout", d.__unfocusNodeAdjacency);
                    if (f.get("focusNodeAdjacency")) {
                        d.on("mouseover", d.__focusNodeAdjacency = function() {
                            a.dispatchAction({type: "focusNodeAdjacency", seriesId: c.id, dataIndex: d.dataIndex})
                        });
                        d.on("mouseout", d.__unfocusNodeAdjacency = function() {
                            a.dispatchAction({type: "unfocusNodeAdjacency", seriesId: c.id})
                        })
                    }
                }, this);
                var R = c.get("layout") === "circular" && c.get("circular.rotateLabel");
                var W = S.getLayout("cx");
                var V = S.getLayout("cy");
                S.eachItemGraphicEl(function(d, i) {
                    var f = d.getSymbolPath();
                    if (R) {
                        var g = S.getItemLayout(i);
                        var e = Math.atan2(g[1] - V, g[0] - W);
                        if (e < 0) {
                            e = Math.PI * 2 + e
                        }
                        var h = g[0] < W;
                        if (h) {
                            e = e - Math.PI
                        }
                        var j = h ? "left" : "right";
                        f.setStyle({textRotation: e, textPosition: j});
                        f.hoverStyle && (f.hoverStyle.textPosition = j)
                    } else {
                        f.setStyle({textRotation: 0})
                    }
                });
                this._firstRender = false
            }, dispose: function() {
                this._controller && this._controller.dispose();
                this._controllerHost = {}
            }, focusNodeAdjacency: function(Z, P, Y, Q) {
                var S = this._model.getData();
                var X = Q.dataIndex;
                var U = S.getItemGraphicEl(X);
                if (!U) {
                    return
                }
                var R = S.graph;
                var V = U.dataType;

                function T(d, c) {
                    var b = E(d, c);
                    var a = d.getGraphicEl();
                    if (b == null) {
                        b = 1
                    }
                    a.traverse(function(e) {
                        e.trigger("normal");
                        if (e.type !== "group") {
                            e.setStyle("opacity", b * 0.1)
                        }
                    })
                }

                function O(d, c) {
                    var b = E(d, c);
                    var a = d.getGraphicEl();
                    a.traverse(function(e) {
                        e.trigger("emphasis");
                        if (e.type !== "group") {
                            e.setStyle("opacity", b)
                        }
                    })
                }

                if (X !== null && V !== "edge") {
                    R.eachNode(function(a) {
                        T(a, I)
                    });
                    R.eachEdge(function(a) {
                        T(a, B)
                    });
                    var W = R.getNodeByIndex(X);
                    O(W, I);
                    F.each(W.edges, function(a) {
                        if (a.dataIndex < 0) {
                            return
                        }
                        O(a, B);
                        O(a.node1, I);
                        O(a.node2, I)
                    })
                }
            }, unfocusNodeAdjacency: function(O, P, S, R) {
                var Q = this._model.getData().graph;
                Q.eachNode(function(T) {
                    var U = E(T, I);
                    T.getGraphicEl().traverse(function(V) {
                        V.trigger("normal");
                        if (V.type !== "group") {
                            V.setStyle("opacity", U)
                        }
                    })
                });
                Q.eachEdge(function(T) {
                    var U = E(T, B);
                    T.getGraphicEl().traverse(function(V) {
                        V.trigger("normal");
                        if (V.type !== "group") {
                            V.setStyle("opacity", U)
                        }
                    })
                })
            }, _startForceLayoutIteration: function(P, R) {
                var Q = this;
                (function O() {
                    P.step(function(S) {
                        Q.updateLayout(Q._model);
                        (Q._layouting = !S) && (R ? (Q._layoutTimeout = setTimeout(O, 16)) : O())
                    })
                })()
            }, _updateController: function(O, P, S) {
                var T = this._controller;
                var Q = this._controllerHost;
                var R = this.group;
                T.setPointerChecker(function(U, W, X) {
                    var V = R.getBoundingRect();
                    V.applyTransform(R.transform);
                    return V.contain(W, X) && !A.onIrrelevantElement(U, S, O)
                });
                if (O.coordinateSystem.type !== "view") {
                    T.disable();
                    return
                }
                T.enable(O.get("roam"));
                Q.zoomLimit = O.get("scaleLimit");
                Q.zoom = O.coordinateSystem.getZoom();
                T.off("pan").off("zoom").on("pan", function(U, V) {
                    K.updateViewOnPan(Q, U, V);
                    S.dispatchAction({seriesId: O.id, type: "graphRoam", dx: U, dy: V})
                }).on("zoom", function(W, U, V) {
                    K.updateViewOnZoom(Q, W, U, V);
                    S.dispatchAction({seriesId: O.id, type: "graphRoam", zoom: W, originX: U, originY: V});
                    this._updateNodeAndLinkScale();
                    M(O.getGraph(), this._getNodeGlobalScale(O));
                    this._lineDraw.updateLayout()
                }, this)
            }, _updateNodeAndLinkScale: function() {
                var O = this._model;
                var R = O.getData();
                var P = this._getNodeGlobalScale(O);
                var Q = [P, P];
                R.eachItemGraphicEl(function(S, T) {
                    S.attr("scale", Q)
                })
            }, _getNodeGlobalScale: function(O) {
                var Q = O.coordinateSystem;
                if (Q.type !== "view") {
                    return 1
                }
                var P = this._nodeScaleRatio;
                var S = Q.scale;
                var U = (S && S[0]) || 1;
                var R = Q.getZoom();
                var T = (R - 1) * P + 1;
                return T / U
            }, updateLayout: function(O) {
                M(O.getGraph(), this._getNodeGlobalScale(O));
                this._symbolDraw.updateLayout();
                this._lineDraw.updateLayout()
            }, remove: function(O, P) {
                this._symbolDraw && this._symbolDraw.remove();
                this._lineDraw && this._lineDraw.remove()
            }
        })
    }, function(H, I, C) {
        var E = C(18);
        var F = C(211);

        function G(J) {
            return isNaN(J[0]) || isNaN(J[1])
        }

        function B(J) {
            return !G(J[0]) && !G(J[1])
        }

        function A(J) {
            this._ctor = J || F;
            this.group = new E.Group()
        }

        var D = A.prototype;
        D.updateData = function(J) {
            var M = this._lineData;
            var N = this.group;
            var K = this._ctor;
            var L = J.hostModel;
            var O = {
                lineStyle: L.getModel("lineStyle.normal").getLineStyle(),
                hoverLineStyle: L.getModel("lineStyle.emphasis").getLineStyle(),
                labelModel: L.getModel("label.normal"),
                hoverLabelModel: L.getModel("label.emphasis")
            };
            J.diff(M).add(function(Q) {
                if (!B(J.getItemLayout(Q))) {
                    return
                }
                var P = new K(J, Q, O);
                J.setItemGraphicEl(Q, P);
                N.add(P)
            }).update(function(Q, R) {
                var P = M.getItemGraphicEl(R);
                if (!B(J.getItemLayout(Q))) {
                    N.remove(P);
                    return
                }
                if (!P) {
                    P = new K(J, Q, O)
                } else {
                    P.updateData(J, Q, O)
                }
                J.setItemGraphicEl(Q, P);
                N.add(P)
            }).remove(function(P) {
                N.remove(M.getItemGraphicEl(P))
            }).execute();
            this._lineData = J
        };
        D.updateLayout = function() {
            var J = this._lineData;
            J.eachItemGraphicEl(function(K, L) {
                K.updateLayout(J, L)
            }, this)
        };
        D.remove = function() {
            this.group.removeAll()
        };
        H.exports = A
    }, function(O, G, P) {
        var Q = P(111);
        var L = P(10);
        var M = P(212);
        var I = P(18);
        var F = P(4);
        var H = P(7);
        var A = ["fromSymbol", "toSymbol"];

        function D(R) {
            return "_" + R + "Type"
        }

        function B(U, R, V) {
            var X = R.getItemVisual(V, "color");
            var S = R.getItemVisual(V, U);
            var W = R.getItemVisual(V, U + "Size");
            if (!S || S === "none") {
                return
            }
            if (!F.isArray(W)) {
                W = [W, W]
            }
            var T = Q.createSymbol(S, -W[0] / 2, -W[1] / 2, W[0], W[1], X);
            T.name = U;
            return T
        }

        function C(R) {
            var S = new M({name: "line"});
            J(S.shape, R);
            return S
        }

        function J(V, T) {
            var R = T[0];
            var U = T[1];
            var S = T[2];
            V.x1 = R[0];
            V.y1 = R[1];
            V.x2 = U[0];
            V.y2 = U[1];
            V.percent = 1;
            if (S) {
                V.cpx1 = S[0];
                V.cpy1 = S[1]
            } else {
                V.cpx1 = NaN;
                V.cpy1 = NaN
            }
        }

        function E() {
            var S = this;
            var l = S.childOfName("fromSymbol");
            var a = S.childOfName("toSymbol");
            var i = S.childOfName("label");
            if (!l && !a && i.ignore) {
                return
            }
            var e = 1;
            var c = this.parent;
            while (c) {
                if (c.scale) {
                    e /= c.scale[0]
                }
                c = c.parent
            }
            var T = S.childOfName("line");
            if (!this.__dirty && !T.__dirty) {
                return
            }
            var Z = T.shape.percent;
            var W = T.pointAt(0);
            var j = T.pointAt(Z);
            var Y = L.sub([], j, W);
            L.normalize(Y, Y);
            if (l) {
                l.attr("position", W);
                var R = T.tangentAt(0);
                l.attr("rotation", Math.PI / 2 - Math.atan2(R[1], R[0]));
                l.attr("scale", [e * Z, e * Z])
            }
            if (a) {
                a.attr("position", j);
                var R = T.tangentAt(1);
                a.attr("rotation", -Math.PI / 2 - Math.atan2(R[1], R[0]));
                a.attr("scale", [e * Z, e * Z])
            }
            if (!i.ignore) {
                i.attr("position", j);
                var g;
                var X;
                var h;
                var k = 5 * e;
                if (i.__position === "end") {
                    g = [Y[0] * k + j[0], Y[1] * k + j[1]];
                    X = Y[0] > 0.8 ? "left" : (Y[0] < -0.8 ? "right" : "center");
                    h = Y[1] > 0.8 ? "top" : (Y[1] < -0.8 ? "bottom" : "middle")
                } else {
                    if (i.__position === "middle") {
                        var b = Z / 2;
                        var R = T.tangentAt(b);
                        var U = [R[1], -R[0]];
                        var f = T.pointAt(b);
                        if (U[1] > 0) {
                            U[0] = -U[0];
                            U[1] = -U[1]
                        }
                        g = [f[0] + U[0] * k, f[1] + U[1] * k];
                        X = "center";
                        h = "bottom";
                        var V = -Math.atan2(R[1], R[0]);
                        if (j[0] < W[0]) {
                            V = Math.PI + V
                        }
                        i.attr("rotation", V)
                    } else {
                        g = [-Y[0] * k + W[0], -Y[1] * k + W[1]];
                        X = Y[0] > 0.8 ? "right" : (Y[0] < -0.8 ? "left" : "center");
                        h = Y[1] > 0.8 ? "bottom" : (Y[1] < -0.8 ? "top" : "middle")
                    }
                }
                i.attr({style: {textVerticalAlign: i.__verticalAlign || h, textAlign: i.__textAlign || X}, position: g, scale: [e, e]})
            }
        }

        function N(R, S, T) {
            I.Group.call(this);
            this._createLine(R, S, T)
        }

        var K = N.prototype;
        K.beforeUpdate = E;
        K._createLine = function(S, U, W) {
            var T = S.hostModel;
            var R = S.getItemLayout(U);
            var V = C(R);
            V.shape.percent = 0;
            I.initProps(V, {shape: {percent: 1}}, T, U);
            this.add(V);
            var X = new I.Text({name: "label"});
            this.add(X);
            F.each(A, function(Z) {
                var Y = B(Z, S, U);
                this.add(Y);
                this[D(Z)] = S.getItemVisual(U, Z)
            }, this);
            this._updateCommonStl(S, U, W)
        };
        K.updateData = function(S, V, X) {
            var T = S.hostModel;
            var W = this.childOfName("line");
            var R = S.getItemLayout(V);
            var U = {shape: {}};
            J(U.shape, R);
            I.updateProps(W, U, T, V);
            F.each(A, function(b) {
                var Z = S.getItemVisual(V, b);
                var Y = D(b);
                if (this[Y] !== Z) {
                    this.remove(this.childOfName(b));
                    var a = B(b, S, V);
                    this.add(a)
                }
                this[Y] = Z
            }, this);
            this._updateCommonStl(S, V, X)
        };
        K._updateCommonStl = function(T, k, S) {
            var a = T.hostModel;
            var Y = this.childOfName("line");
            var b = S && S.lineStyle;
            var f = S && S.hoverLineStyle;
            var R = S && S.labelModel;
            var Z = S && S.hoverLabelModel;
            if (!S || T.hasItemOption) {
                var i = T.getItemModel(k);
                b = i.getModel("lineStyle.normal").getLineStyle();
                f = i.getModel("lineStyle.emphasis").getLineStyle();
                R = i.getModel("label.normal");
                Z = i.getModel("label.emphasis")
            }
            var h = T.getItemVisual(k, "color");
            var e = F.retrieve(T.getItemVisual(k, "opacity"), b.opacity, 1);
            Y.useStyle(F.defaults({strokeNoScale: true, fill: "none", stroke: h, opacity: e}, b));
            Y.hoverStyle = f;
            F.each(A, function(m) {
                var l = this.childOfName(m);
                if (l) {
                    l.setColor(h);
                    l.setStyle({opacity: e})
                }
            }, this);
            var W = R.getShallow("show");
            var V = Z.getShallow("show");
            var j = this.childOfName("label");
            var g;
            var d;
            if (W || V) {
                var U = a.getRawValue(k);
                d = U == null ? d = T.getName(k) : isFinite(U) ? H.round(U) : U;
                g = h || "#000"
            }
            if (W) {
                var X = R.getModel("textStyle");
                j.setStyle({text: F.retrieve(a.getFormattedLabel(k, "normal", T.dataType), d), textFont: X.getFont(), fill: X.getTextColor() || g});
                j.__textAlign = X.get("align");
                j.__verticalAlign = X.get("baseline");
                j.__position = R.get("position")
            } else {
                j.setStyle("text", "")
            }
            if (V) {
                var c = Z.getModel("textStyle");
                j.hoverStyle = {
                    text: F.retrieve(a.getFormattedLabel(k, "emphasis", T.dataType), d),
                    textFont: c.getFont(),
                    fill: c.getTextColor() || g
                }
            } else {
                j.hoverStyle = {text: ""}
            }
            j.ignore = !W && !V;
            I.setHoverStyle(this)
        };
        K.updateLayout = function(R, S) {
            this.setLinePoints(R.getItemLayout(S))
        };
        K.setLinePoints = function(R) {
            var S = this.childOfName("line");
            J(S.shape, R);
            S.dirty()
        };
        F.inherits(N, I.Group);
        O.exports = N
    }, function(G, H, B) {
        var E = B(18);
        var D = B(10);
        var F = E.Line.prototype;
        var A = E.BezierCurve.prototype;

        function C(I) {
            return isNaN(+I.cpx1) || isNaN(+I.cpy1)
        }

        G.exports = E.extendShape({
            type: "ec-line",
            style: {stroke: "#000", fill: null},
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null},
            buildPath: function(I, J) {
                (C(J) ? F : A).buildPath(I, J)
            },
            pointAt: function(I) {
                return C(this.shape) ? F.pointAt.call(this, I) : A.pointAt.call(this, I)
            },
            tangentAt: function(J) {
                var K = this.shape;
                var I = C(K) ? [K.x2 - K.x1, K.y2 - K.y1] : A.tangentAt.call(this, J);
                return D.normalize(I, I)
            }
        })
    }, function(J, L, B) {
        var F = B(37);
        var D = B(10);
        var E = [];
        var G = [];
        var K = [];
        var I = F.quadraticAt;
        var A = D.distSquare;
        var H = Math.abs;

        function C(Z, M, V) {
            var N = Z[0];
            var T = Z[1];
            var W = Z[2];
            var a = Infinity;
            var P;
            var Y = V * V;
            var O = 0.1;
            for (var R = 0.1; R <= 0.9; R += 0.1) {
                E[0] = I(N[0], T[0], W[0], R);
                E[1] = I(N[1], T[1], W[1], R);
                var Q = H(A(E, M) - Y);
                if (Q < a) {
                    a = Q;
                    P = R
                }
            }
            for (var S = 0; S < 32; S++) {
                var U = P + O;
                G[0] = I(N[0], T[0], W[0], P);
                G[1] = I(N[1], T[1], W[1], P);
                K[0] = I(N[0], T[0], W[0], U);
                K[1] = I(N[1], T[1], W[1], U);
                var Q = A(G, M) - Y;
                if (H(Q) < 0.01) {
                    break
                }
                var X = A(K, M) - Y;
                O /= 2;
                if (Q < 0) {
                    if (X >= 0) {
                        P = P + O
                    } else {
                        P = P - O
                    }
                } else {
                    if (X >= 0) {
                        P = P - O
                    } else {
                        P = P + O
                    }
                }
            }
            return P
        }

        J.exports = function(Q, P) {
            var R = [];
            var N = F.quadraticSubdivide;
            var M = [[], [], []];
            var S = [[], []];
            var O = [];
            P /= 2;

            function T(U) {
                var V = U.getVisual("symbolSize");
                if (V instanceof Array) {
                    V = (V[0] + V[1]) / 2
                }
                return V
            }

            Q.eachEdge(function(b, Y) {
                var Z = b.getLayout();
                var V = b.getVisual("fromSymbol");
                var W = b.getVisual("toSymbol");
                if (!Z.__original) {
                    Z.__original = [D.clone(Z[0]), D.clone(Z[1])];
                    if (Z[2]) {
                        Z.__original.push(D.clone(Z[2]))
                    }
                }
                var a = Z.__original;
                if (Z[2] != null) {
                    D.copy(M[0], a[0]);
                    D.copy(M[1], a[2]);
                    D.copy(M[2], a[1]);
                    if (V && V != "none") {
                        var U = T(b.node1);
                        var X = C(M, a[0], U * P);
                        N(M[0][0], M[1][0], M[2][0], X, R);
                        M[0][0] = R[3];
                        M[1][0] = R[4];
                        N(M[0][1], M[1][1], M[2][1], X, R);
                        M[0][1] = R[3];
                        M[1][1] = R[4]
                    }
                    if (W && W != "none") {
                        var U = T(b.node2);
                        var X = C(M, a[1], U * P);
                        N(M[0][0], M[1][0], M[2][0], X, R);
                        M[1][0] = R[1];
                        M[2][0] = R[2];
                        N(M[0][1], M[1][1], M[2][1], X, R);
                        M[1][1] = R[1];
                        M[2][1] = R[2]
                    }
                    D.copy(Z[0], M[0]);
                    D.copy(Z[1], M[2]);
                    D.copy(Z[2], M[1])
                } else {
                    D.copy(S[0], a[0]);
                    D.copy(S[1], a[1]);
                    D.sub(O, S[1], S[0]);
                    D.normalize(O, O);
                    if (V && V != "none") {
                        var U = T(b.node1);
                        D.scaleAndAdd(S[0], S[0], O, U * P)
                    }
                    if (W && W != "none") {
                        var U = T(b.node2);
                        D.scaleAndAdd(S[1], S[1], O, -U * P)
                    }
                    D.copy(Z[0], S[0]);
                    D.copy(Z[1], S[1])
                }
            })
        }
    }, function(D, F, B) {
        var E = B(1);
        var A = B(188);
        var C = {type: "graphRoam", event: "graphRoam", update: "none"};
        E.registerAction(C, function(H, G) {
            G.eachComponent({mainType: "series", query: H}, function(I) {
                var J = I.coordinateSystem;
                var K = A.updateCenterAndZoom(J, H);
                I.setCenter && I.setCenter(K.center);
                I.setZoom && I.setZoom(K.zoom)
            })
        });
        E.registerAction({type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series.graph:focusNodeAdjacency"}, function() {
        });
        E.registerAction({type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series.graph:unfocusNodeAdjacency"}, function() {
        })
    }, function(A, B) {
        A.exports = function(C) {
            var D = C.findComponents({mainType: "legend"});
            if (!D || !D.length) {
                return
            }
            C.eachSeriesByType("graph", function(H) {
                var G = H.getCategoriesData();
                var F = H.getGraph();
                var I = F.data;
                var E = G.mapArray(G.getName);
                I.filterSelf(function(L) {
                    var M = I.getItemModel(L);
                    var K = M.getShallow("category");
                    if (K != null) {
                        if (typeof K === "number") {
                            K = E[K]
                        }
                        for (var J = 0; J < D.length; J++) {
                            if (!D[J].isSelected(K)) {
                                return false
                            }
                        }
                    }
                    return true
                })
            }, this)
        }
    }, function(A, B) {
        A.exports = function(C) {
            var D = {};
            C.eachSeriesByType("graph", function(E) {
                var G = E.getCategoriesData();
                var H = E.getData();
                var F = {};
                G.each(function(K) {
                    var J = G.getName(K);
                    F["ec-" + J] = K;
                    var I = G.getItemModel(K);
                    var L = I.get("itemStyle.normal.color") || E.getColorFromPalette(J, D);
                    G.setItemVisual(K, "color", L)
                });
                if (G.count()) {
                    H.each(function(J) {
                        var K = H.getItemModel(J);
                        var I = K.getShallow("category");
                        if (I != null) {
                            if (typeof I === "string") {
                                I = F["ec-" + I]
                            }
                            if (!H.getItemVisual(J, "color", true)) {
                                H.setItemVisual(J, "color", G.getItemVisual(I, "color"))
                            }
                        }
                    })
                }
            })
        }
    }, function(B, C) {
        function A(D) {
            if (!(D instanceof Array)) {
                D = [D, D]
            }
            return D
        }

        B.exports = function(D) {
            D.eachSeriesByType("graph", function(E) {
                var H = E.getGraph();
                var G = E.getEdgeData();
                var I = A(E.get("edgeSymbol"));
                var J = A(E.get("edgeSymbolSize"));
                var K = "lineStyle.normal.color".split(".");
                var F = "lineStyle.normal.opacity".split(".");
                G.setVisual("fromSymbol", I && I[0]);
                G.setVisual("toSymbol", I && I[1]);
                G.setVisual("fromSymbolSize", J && J[0]);
                G.setVisual("toSymbolSize", J && J[1]);
                G.setVisual("color", E.get(K));
                G.setVisual("opacity", E.get(F));
                G.each(function(P) {
                    var M = G.getItemModel(P);
                    var N = H.getEdgeByIndex(P);
                    var L = A(M.getShallow("symbol", true));
                    var Q = A(M.getShallow("symbolSize", true));
                    var R = M.get(K);
                    var O = M.get(F);
                    switch (R) {
                        case"source":
                            R = N.node1.getVisual("color");
                            break;
                        case"target":
                            R = N.node2.getVisual("color");
                            break
                    }
                    L[0] && N.setVisual("fromSymbol", L[0]);
                    L[1] && N.setVisual("toSymbol", L[1]);
                    Q[0] && N.setVisual("fromSymbolSize", Q[0]);
                    Q[1] && N.setVisual("toSymbolSize", Q[1]);
                    N.setVisual("color", R);
                    N.setVisual("opacity", O)
                })
            })
        }
    }, function(C, E, B) {
        var A = B(219);
        var D = B(220);
        C.exports = function(F, G) {
            F.eachSeriesByType("graph", function(H) {
                var K = H.get("layout");
                var I = H.coordinateSystem;
                if (I && I.type !== "view") {
                    var L = H.getData();
                    var J = I.dimensions;
                    L.each(J, function() {
                        var M;
                        var Q = arguments;
                        var P = [];
                        for (var N = 0; N < J.length; N++) {
                            if (!isNaN(Q[N])) {
                                M = true
                            }
                            P.push(Q[N])
                        }
                        var O = Q[Q.length - 1];
                        if (M) {
                            L.setItemLayout(O, I.dataToPoint(P))
                        } else {
                            L.setItemLayout(O, [NaN, NaN])
                        }
                    });
                    D(L.graph)
                } else {
                    if (!K || K === "none") {
                        A(H)
                    }
                }
            })
        }
    }, function(B, D, A) {
        var C = A(220);
        B.exports = function(E) {
            var F = E.coordinateSystem;
            if (F && F.type !== "view") {
                return
            }
            var G = E.getGraph();
            G.eachNode(function(H) {
                var I = H.getModel();
                H.setLayout([+I.get("x"), +I.get("y")])
            });
            C(G)
        }
    }, function(C, D, B) {
        var A = B(10);
        C.exports = function(E) {
            E.eachEdge(function(G) {
                var H = G.getModel().get("lineStyle.normal.curveness") || 0;
                var F = A.clone(G.node1.getLayout());
                var I = A.clone(G.node2.getLayout());
                var J = [F, I];
                if (+H) {
                    J.push([(F[0] + I[0]) / 2 - (F[1] - I[1]) * H, (F[1] + I[1]) / 2 - (I[0] - F[0]) * H])
                }
                G.setLayout(J)
            })
        }
    }, function(B, C, A) {
        var D = A(222);
        B.exports = function(E) {
            E.eachSeriesByType("graph", function(F) {
                if (F.get("layout") === "circular") {
                    D(F)
                }
            })
        }
    }, function(C, D, B) {
        var A = B(10);
        C.exports = function(O) {
            var F = O.coordinateSystem;
            if (F && F.type !== "view") {
                return
            }
            var G = F.getBoundingRect();
            var J = O.getData();
            var I = J.graph;
            var N = 0;
            var L = J.getSum("value");
            var M = Math.PI * 2 / (L || J.count());
            var H = G.width / 2 + G.x;
            var K = G.height / 2 + G.y;
            var E = Math.min(G.width, G.height) / 2;
            I.eachNode(function(P) {
                var Q = P.getValue("value");
                N += M * (L ? Q : 1) / 2;
                P.setLayout([E * Math.cos(N) + H, E * Math.sin(N) + K]);
                N += M * (L ? Q : 1) / 2
            });
            J.setLayout({cx: H, cy: K});
            I.eachEdge(function(S) {
                var T = S.getModel().get("lineStyle.normal.curveness") || 0;
                var Q = A.clone(S.node1.getLayout());
                var U = A.clone(S.node2.getLayout());
                var R;
                var P = (Q[0] + U[0]) / 2;
                var V = (Q[1] + U[1]) / 2;
                if (+T) {
                    T *= 3;
                    R = [H * T + P * (1 - T), K * T + V * (1 - T)]
                }
                S.setLayout([Q, U, R])
            })
        }
    }, function(G, I, D) {
        var H = D(224);
        var E = D(7);
        var B = D(219);
        var A = D(222);
        var F = D(10);
        var C = D(4);
        G.exports = function(J) {
            J.eachSeriesByType("graph", function(Y) {
                var S = Y.coordinateSystem;
                if (S && S.type !== "view") {
                    return
                }
                if (Y.get("layout") === "force") {
                    var P = Y.preservedPoints || {};
                    var T = Y.getGraph();
                    var U = T.data;
                    var Z = T.edgeData;
                    var W = Y.getModel("force");
                    var K = W.get("initLayout");
                    if (Y.preservedPoints) {
                        U.each(function(b) {
                            var c = U.getId(b);
                            U.setItemLayout(b, P[c] || [NaN, NaN])
                        })
                    } else {
                        if (!K || K === "none") {
                            B(Y)
                        } else {
                            if (K === "circular") {
                                A(Y)
                            }
                        }
                    }
                    var N = U.getDataExtent("value");
                    var V = Z.getDataExtent("value");
                    var a = W.get("repulsion");
                    var R = W.get("edgeLength");
                    if (!C.isArray(a)) {
                        a = [a, a]
                    }
                    if (!C.isArray(R)) {
                        R = [R, R]
                    }
                    R = [R[1], R[0]];
                    var M = U.mapArray("value", function(e, d) {
                        var b = U.getItemLayout(d);
                        var c = E.linearMap(e, N, a);
                        if (isNaN(c)) {
                            c = (a[0] + a[1]) / 2
                        }
                        return {w: c, rep: c, fixed: U.getItemModel(d).get("fixed"), p: (!b || isNaN(b[0]) || isNaN(b[1])) ? null : b}
                    });
                    var X = Z.mapArray("value", function(f, c) {
                        var e = T.getEdgeByIndex(c);
                        var b = E.linearMap(f, V, R);
                        if (isNaN(b)) {
                            b = (R[0] + R[1]) / 2
                        }
                        return {
                            n1: M[e.node1.dataIndex],
                            n2: M[e.node2.dataIndex],
                            d: b,
                            curveness: e.getModel().get("lineStyle.normal.curveness") || 0
                        }
                    });
                    var S = Y.coordinateSystem;
                    var Q = S.getBoundingRect();
                    var L = H(M, X, {rect: Q, gravity: W.get("gravity")});
                    var O = L.step;
                    L.step = function(b) {
                        for (var c = 0, d = M.length; c < d; c++) {
                            if (M[c].fixed) {
                                F.copy(M[c].p, T.getNodeByIndex(c).getLayout())
                            }
                        }
                        O(function(q, g, h) {
                            for (var j = 0, m = q.length; j < m; j++) {
                                if (!q[j].fixed) {
                                    T.getNodeByIndex(j).setLayout(q[j].p)
                                }
                                P[U.getId(j)] = q[j].p
                            }
                            for (var j = 0, m = g.length; j < m; j++) {
                                var f = g[j];
                                var n = T.getEdgeByIndex(j);
                                var k = f.n1.p;
                                var p = f.n2.p;
                                var o = n.getLayout();
                                o = o ? o.slice() : [];
                                o[0] = o[0] || [];
                                o[1] = o[1] || [];
                                F.copy(o[0], k);
                                F.copy(o[1], p);
                                if (+f.curveness) {
                                    o[2] = [(k[0] + p[0]) / 2 - (k[1] - p[1]) * f.curveness, (k[1] + p[1]) / 2 - (p[0] - k[0]) * f.curveness]
                                }
                                n.setLayout(o)
                            }
                            b && b(h)
                        })
                    };
                    Y.forceLayout = L;
                    Y.preservedPoints = P;
                    L.step()
                } else {
                    Y.forceLayout = null
                }
            })
        }
    }, function(C, E, B) {
        var A = B(10);
        var D = A.scaleAndAdd;
        C.exports = function(P, G, L) {
            var I = L.rect;
            var M = I.width;
            var H = I.height;
            var F = [I.x + M / 2, I.y + H / 2];
            var O = L.gravity == null ? 0.1 : L.gravity;
            for (var K = 0; K < P.length; K++) {
                var N = P[K];
                if (!N.p) {
                    N.p = A.create(M * (Math.random() - 0.5) + F[0], H * (Math.random() - 0.5) + F[1])
                }
                N.pp = A.clone(N.p);
                N.edges = null
            }
            var J = 0.6;
            return {
                warmUp: function() {
                    J = 0.5
                }, setFixed: function(Q) {
                    P[Q].fixed = true
                }, setUnfixed: function(Q) {
                    P[Q].fixed = false
                }, step: function(T) {
                    var a = [];
                    var X = P.length;
                    for (var Y = 0; Y < G.length; Y++) {
                        var Q = G[Y];
                        var c = Q.n1;
                        var R = Q.n2;
                        A.sub(a, R.p, c.p);
                        var S = A.len(a) - Q.d;
                        var U = R.w / (c.w + R.w);
                        A.normalize(a, a);
                        !c.fixed && D(c.p, c.p, a, U * S * J);
                        !R.fixed && D(R.p, R.p, a, -(1 - U) * S * J)
                    }
                    for (var Y = 0; Y < X; Y++) {
                        var Z = P[Y];
                        if (!Z.fixed) {
                            A.sub(a, F, Z.p);
                            A.scaleAndAdd(Z.p, Z.p, a, O * J)
                        }
                    }
                    for (var Y = 0; Y < X; Y++) {
                        var c = P[Y];
                        for (var W = Y + 1; W < X; W++) {
                            var R = P[W];
                            A.sub(a, R.p, c.p);
                            var S = A.len(a);
                            if (S === 0) {
                                A.set(a, Math.random() - 0.5, Math.random() - 0.5);
                                S = 1
                            }
                            var b = (c.rep + R.rep) / S / S;
                            !c.fixed && D(c.pp, c.pp, a, b);
                            !R.fixed && D(R.pp, R.pp, a, -b)
                        }
                    }
                    var V = [];
                    for (var Y = 0; Y < X; Y++) {
                        var Z = P[Y];
                        if (!Z.fixed) {
                            A.sub(V, Z.p, Z.pp);
                            A.scaleAndAdd(Z.p, Z.p, V, J);
                            A.copy(Z.pp, Z.p)
                        }
                    }
                    J = J * 0.992;
                    T && T(P, G, J < 0.01)
                }
            }
        }
    }, function(C, F, B) {
        var E = B(176);
        var G = B(71);
        var D = B(38);

        function A(H, K, J) {
            var I = H.getBoxLayoutParams();
            I.aspect = J;
            return G.getLayoutRect(I, {width: K.getWidth(), height: K.getHeight()})
        }

        C.exports = function(H, J) {
            var I = [];
            H.eachSeriesByType("graph", function(P) {
                var R = P.get("coordinateSystem");
                if (!R || R === "view") {
                    var M = P.getData();
                    var K = M.mapArray(function(Y) {
                        var X = M.getItemModel(Y);
                        return [+X.get("x"), +X.get("y")]
                    });
                    var L = [];
                    var W = [];
                    D.fromPoints(K, L, W);
                    if (W[0] - L[0] === 0) {
                        W[0] += 1;
                        L[0] -= 1
                    }
                    if (W[1] - L[1] === 0) {
                        W[1] += 1;
                        L[1] -= 1
                    }
                    var O = (W[0] - L[0]) / (W[1] - L[1]);
                    var U = A(P, J, O);
                    if (isNaN(O)) {
                        L = [U.x, U.y];
                        W = [U.x + U.width, U.y + U.height]
                    }
                    var T = W[0] - L[0];
                    var S = W[1] - L[1];
                    var V = U.width;
                    var N = U.height;
                    var Q = P.coordinateSystem = new E();
                    Q.zoomLimit = P.get("scaleLimit");
                    Q.setBoundingRect(L[0], L[1], T, S);
                    Q.setViewRect(U.x, U.y, V, N);
                    Q.setCenter(P.get("center"));
                    Q.setZoom(P.get("zoom"));
                    I.push(Q)
                }
            });
            return I
        }
    }, function(B, C, A) {
        A(227);
        A(228)
    }, function(C, F, B) {
        var A = B(98);
        var E = B(78);
        var D = B(4);
        var G = E.extend({
            type: "series.gauge",
            getInitialData: function(H, I) {
                var K = new A(["value"], this);
                var J = H.data || [];
                if (!D.isArray(J)) {
                    J = [J]
                }
                K.initData(J);
                return K
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                center: ["50%", "50%"],
                legendHoverLink: true,
                radius: "75%",
                startAngle: 225,
                endAngle: -45,
                clockwise: true,
                min: 0,
                max: 100,
                splitNumber: 10,
                axisLine: {show: true, lineStyle: {color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]], width: 30}},
                splitLine: {show: true, length: 30, lineStyle: {color: "#eee", width: 2, type: "solid"}},
                axisTick: {show: true, splitNumber: 5, length: 8, lineStyle: {color: "#eee", width: 1, type: "solid"}},
                axisLabel: {show: true, distance: 5, textStyle: {color: "auto"}},
                pointer: {show: true, length: "80%", width: 8},
                itemStyle: {normal: {color: "auto"}},
                title: {show: true, offsetCenter: [0, "-40%"], textStyle: {color: "#333", fontSize: 15}},
                detail: {
                    show: true,
                    backgroundColor: "rgba(0,0,0,0)",
                    borderWidth: 0,
                    borderColor: "#ccc",
                    width: 100,
                    height: 40,
                    offsetCenter: [0, "40%"],
                    textStyle: {color: "auto", fontSize: 30}
                }
            }
        });
        C.exports = G
    }, function(I, K, C) {
        var J = C(229);
        var F = C(18);
        var D = C(7);
        var E = D.parsePercent;

        function A(T, S) {
            var L = T.get("center");
            var R = S.getWidth();
            var M = S.getHeight();
            var P = Math.min(R, M);
            var Q = E(L[0], S.getWidth());
            var O = E(L[1], S.getHeight());
            var N = E(T.get("radius"), P / 2);
            return {cx: Q, cy: O, r: N}
        }

        function H(L, M) {
            if (M) {
                if (typeof M === "string") {
                    L = M.replace("{value}", L != null ? L : "")
                } else {
                    if (typeof M === "function") {
                        L = M(L)
                    }
                }
            }
            return L
        }

        var B = Math.PI * 2;
        var G = C(80).extend({
            type: "gauge", render: function(L, M, P) {
                this.group.removeAll();
                var N = L.get("axisLine.lineStyle.color");
                var O = A(L, P);
                this._renderMain(L, M, P, N, O)
            }, dispose: function() {
            }, _renderMain: function(R, O, U, S, d) {
                var W = this.group;
                var Q = R.getModel("axisLine");
                var b = Q.getModel("lineStyle");
                var N = R.get("clockwise");
                var T = -R.get("startAngle") / 180 * Math.PI;
                var a = -R.get("endAngle") / 180 * Math.PI;
                var X = (a - T) % B;
                var Z = T;
                var P = b.get("width");
                for (var c = 0; c < S.length; c++) {
                    var V = Math.min(Math.max(S[c][0], 0), 1);
                    var a = T + X * V;
                    var M = new F.Sector({shape: {startAngle: Z, endAngle: a, cx: d.cx, cy: d.cy, clockwise: N, r0: d.r - P, r: d.r}, silent: true});
                    M.setStyle({fill: S[c][1]});
                    M.setStyle(b.getLineStyle(["color", "borderWidth", "borderColor"]));
                    W.add(M);
                    Z = a
                }
                var Y = function(e) {
                    if (e <= 0) {
                        return S[0][1]
                    }
                    for (var f = 0; f < S.length; f++) {
                        if (S[f][0] >= e && (f === 0 ? 0 : S[f - 1][0]) < e) {
                            return S[f][1]
                        }
                    }
                    return S[f - 1][1]
                };
                if (!N) {
                    var L = T;
                    T = a;
                    a = L
                }
                this._renderTicks(R, O, U, Y, d, T, a, N);
                this._renderPointer(R, O, U, Y, d, T, a, N);
                this._renderTitle(R, O, U, Y, d);
                this._renderDetail(R, O, U, Y, d)
            }, _renderTicks: function(u, f, M, d, h, Q, l, R) {
                var Y = this.group;
                var x = h.cx;
                var g = h.cy;
                var o = h.r;
                var S = +u.get("min");
                var U = +u.get("max");
                var V = u.getModel("splitLine");
                var p = u.getModel("axisTick");
                var k = u.getModel("axisLabel");
                var T = u.get("splitNumber");
                var w = p.get("splitNumber");
                var q = E(V.get("length"), o);
                var m = E(p.get("length"), o);
                var c = Q;
                var n = (l - Q) / T;
                var L = n / w;
                var s = V.getModel("lineStyle").getLineStyle();
                var b = p.getModel("lineStyle").getLineStyle();
                var W = k.getModel("textStyle");
                for (var a = 0; a <= T; a++) {
                    var O = Math.cos(c);
                    var P = Math.sin(c);
                    if (V.get("show")) {
                        var t = new F.Line({shape: {x1: O * o + x, y1: P * o + g, x2: O * (o - q) + x, y2: P * (o - q) + g}, style: s, silent: true});
                        if (s.stroke === "auto") {
                            t.setStyle({stroke: d(a / T)})
                        }
                        Y.add(t)
                    }
                    if (k.get("show")) {
                        var X = H(D.round(a / T * (U - S) + S), k.get("formatter"));
                        var v = k.get("distance");
                        var e = new F.Text({
                            style: {
                                text: X,
                                x: O * (o - q - v) + x,
                                y: P * (o - q - v) + g,
                                fill: W.getTextColor(),
                                textFont: W.getFont(),
                                textVerticalAlign: P < -0.4 ? "top" : (P > 0.4 ? "bottom" : "middle"),
                                textAlign: O < -0.4 ? "left" : (O > 0.4 ? "right" : "center")
                            }, silent: true
                        });
                        if (e.style.fill === "auto") {
                            e.setStyle({fill: d(a / T)})
                        }
                        Y.add(e)
                    }
                    if (p.get("show") && a !== T) {
                        for (var Z = 0; Z <= w; Z++) {
                            var O = Math.cos(c);
                            var P = Math.sin(c);
                            var N = new F.Line({
                                shape: {x1: O * o + x, y1: P * o + g, x2: O * (o - m) + x, y2: P * (o - m) + g},
                                silent: true,
                                style: b
                            });
                            if (b.stroke === "auto") {
                                N.setStyle({stroke: d((a + Z / w) / T)})
                            }
                            Y.add(N);
                            c += L
                        }
                        c -= L
                    } else {
                        c += n
                    }
                }
            }, _renderPointer: function(R, M, V, N, W, X, L, Q) {
                var S = this.group;
                var P = this._data;
                if (!R.get("pointer.show")) {
                    P && P.eachItemGraphicEl(function(Y) {
                        S.remove(Y)
                    });
                    return
                }
                var T = [+R.get("min"), +R.get("max")];
                var U = [X, L];
                var O = R.getData();
                O.diff(P).add(function(Z) {
                    var Y = new J({shape: {angle: X}});
                    F.initProps(Y, {shape: {angle: D.linearMap(O.get("value", Z), T, U, true)}}, R);
                    S.add(Y);
                    O.setItemGraphicEl(Z, Y)
                }).update(function(Z, a) {
                    var Y = P.getItemGraphicEl(a);
                    F.updateProps(Y, {shape: {angle: D.linearMap(O.get("value", Z), T, U, true)}}, R);
                    S.add(Y);
                    O.setItemGraphicEl(Z, Y)
                }).remove(function(Z) {
                    var Y = P.getItemGraphicEl(Z);
                    S.remove(Y)
                }).execute();
                O.eachItemGraphicEl(function(Y, a) {
                    var Z = O.getItemModel(a);
                    var b = Z.getModel("pointer");
                    Y.setShape({x: W.cx, y: W.cy, width: E(b.get("width"), W.r), r: E(b.get("length"), W.r)});
                    Y.useStyle(Z.getModel("itemStyle.normal").getItemStyle());
                    if (Y.style.fill === "auto") {
                        Y.setStyle("fill", N(D.linearMap(O.get("value", a), T, [0, 1], true)))
                    }
                    F.setHoverStyle(Y, Z.getModel("itemStyle.emphasis").getItemStyle())
                });
                this._data = O
            }, _renderTitle: function(S, N, X, O, M) {
                var L = S.getModel("title");
                if (L.get("show")) {
                    var Y = L.getModel("textStyle");
                    var Q = L.get("offsetCenter");
                    var V = M.cx + E(Q[0], M.r);
                    var W = M.cy + E(Q[1], M.r);
                    var U = new F.Text({
                        style: {
                            x: V,
                            y: W,
                            text: S.getData().getName(0),
                            fill: Y.getTextColor(),
                            textFont: Y.getFont(),
                            textAlign: "center",
                            textVerticalAlign: "middle"
                        }
                    });
                    if (U.style.fill === "auto") {
                        var P = +S.get("min");
                        var R = +S.get("max");
                        var T = S.getData().get("value", 0);
                        U.setStyle("fill", O(D.linearMap(T, [P, R], [0, 1], true)))
                    }
                    this.group.add(U)
                }
            }, _renderDetail: function(S, M, Z, N, L) {
                var a = S.getModel("detail");
                var O = +S.get("min");
                var R = +S.get("max");
                if (a.get("show")) {
                    var V = a.getModel("textStyle");
                    var P = a.get("offsetCenter");
                    var X = L.cx + E(P[0], L.r);
                    var Y = L.cy + E(P[1], L.r);
                    var W = E(a.get("width"), L.r);
                    var T = E(a.get("height"), L.r);
                    var Q = S.getData().get("value", 0);
                    var U = new F.Rect({
                        shape: {x: X - W / 2, y: Y - T / 2, width: W, height: T},
                        style: {text: H(Q, a.get("formatter")), fill: a.get("backgroundColor"), textFill: V.getTextColor(), textFont: V.getFont()}
                    });
                    if (U.style.textFill === "auto") {
                        U.setStyle("textFill", N(D.linearMap(Q, [O, R], [0, 1], true)))
                    }
                    U.setStyle(a.getItemStyle(["color"]));
                    this.group.add(U)
                }
            }
        });
        I.exports = G
    }, function(B, C, A) {
        B.exports = A(20).extend({
            type: "echartsGaugePointer", shape: {angle: 0, width: 10, r: 10, x: 0, y: 0}, buildPath: function(G, F) {
                var D = Math.cos;
                var J = Math.sin;
                var E = F.r;
                var H = F.width;
                var I = F.angle;
                var L = F.x - D(I) * H * (H >= E / 3 ? 1 : 2);
                var K = F.y - J(I) * H * (H >= E / 3 ? 1 : 2);
                I = F.angle - Math.PI / 2;
                G.moveTo(L, K);
                G.lineTo(F.x + D(I) * H, F.y + J(I) * H);
                G.lineTo(F.x + D(F.angle) * E, F.y + J(F.angle) * E);
                G.lineTo(F.x - D(I) * H, F.y - J(I) * H);
                G.lineTo(L, K);
                return
            }
        })
    }, function(C, E, B) {
        var A = B(4);
        var D = B(1);
        B(231);
        B(232);
        D.registerVisual(A.curry(B(151), "funnel"));
        D.registerLayout(B(233));
        D.registerProcessor(A.curry(B(154), "funnel"))
    }, function(E, G, C) {
        var A = C(98);
        var D = C(5);
        var F = C(110);
        var B = C(1).extendSeriesModel({
            type: "series.funnel",
            init: function(H) {
                B.superApply(this, "init", arguments);
                this.legendDataProvider = function() {
                    return this.getRawData()
                };
                this._defaultLabelLine(H)
            },
            getInitialData: function(I, J) {
                var K = F(["value"], I.data);
                var H = new A(K, this);
                H.initData(I.data);
                return H
            },
            _defaultLabelLine: function(H) {
                D.defaultEmphasis(H.labelLine, ["show"]);
                var I = H.labelLine.normal;
                var J = H.labelLine.emphasis;
                I.show = I.show && H.label.normal.show;
                J.show = J.show && H.label.emphasis.show
            },
            getDataParams: function(H) {
                var K = this.getData();
                var J = B.superCall(this, "getDataParams", H);
                var I = K.getSum("value");
                J.percent = !I ? 0 : +(K.get("value", H) / I * 100).toFixed(2);
                J.$vars.push("percent");
                return J
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: true,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                minSize: "0%",
                maxSize: "100%",
                sort: "descending",
                gap: 0,
                funnelAlign: "center",
                label: {normal: {show: true, position: "outer"}, emphasis: {show: true}},
                labelLine: {normal: {show: true, length: 20, lineStyle: {width: 1, type: "solid"}}, emphasis: {}},
                itemStyle: {normal: {borderColor: "#fff", borderWidth: 1}, emphasis: {}}
            }
        });
        E.exports = B
    }, function(I, J, D) {
        var E = D(18);
        var C = D(4);

        function G(Q, N) {
            E.Group.call(this);
            var O = new E.Polygon();
            var L = new E.Polyline();
            var M = new E.Text();
            this.add(O);
            this.add(L);
            this.add(M);
            this.updateData(Q, N, true);

            function P() {
                L.ignore = L.hoverIgnore;
                M.ignore = M.hoverIgnore
            }

            function K() {
                L.ignore = L.normalIgnore;
                M.ignore = M.normalIgnore
            }

            this.on("emphasis", P).on("normal", K).on("mouseover", P).on("mouseout", K)
        }

        var H = G.prototype;

        function B(Q, P, N, M) {
            var L = M.getModel("textStyle");
            var O = M.get("position");
            var K = O === "inside" || O === "inner" || O === "center";
            return {
                fill: L.getTextColor() || (K ? "#fff" : Q.getItemVisual(P, "color")),
                textFont: L.getFont(),
                text: C.retrieve(Q.hostModel.getFormattedLabel(P, N), Q.getName(P))
            }
        }

        var A = ["itemStyle", "normal", "opacity"];
        H.updateData = function(L, N, M) {
            var Q = this.childAt(0);
            var T = L.hostModel;
            var K = L.getItemModel(N);
            var R = L.getItemLayout(N);
            var P = L.getItemModel(N).get(A);
            P = P == null ? 1 : P;
            Q.useStyle({});
            if (M) {
                Q.setShape({points: R.points});
                Q.setStyle({opacity: 0});
                E.initProps(Q, {style: {opacity: P}}, T, N)
            } else {
                E.updateProps(Q, {style: {opacity: P}, shape: {points: R.points}}, T, N)
            }
            var O = K.getModel("itemStyle");
            var S = L.getItemVisual(N, "color");
            Q.setStyle(C.defaults({lineJoin: "round", fill: S}, O.getModel("normal").getItemStyle(["opacity"])));
            Q.hoverStyle = O.getModel("emphasis").getItemStyle();
            this._updateLabel(L, N);
            E.setHoverStyle(this)
        };
        H._updateLabel = function(O, Q) {
            var L = this.childAt(1);
            var N = this.childAt(2);
            var W = O.hostModel;
            var M = O.getItemModel(Q);
            var T = O.getItemLayout(Q);
            var P = T.label;
            var U = O.getItemVisual(Q, "color");
            E.updateProps(L, {shape: {points: P.linePoints || P.linePoints}}, W, Q);
            E.updateProps(N, {style: {x: P.x, y: P.y}}, W, Q);
            N.attr({
                style: {textAlign: P.textAlign, textVerticalAlign: P.verticalAlign, textFont: P.font},
                rotation: P.rotation,
                origin: [P.x, P.y],
                z2: 10
            });
            var S = M.getModel("label.normal");
            var R = M.getModel("label.emphasis");
            var V = M.getModel("labelLine.normal");
            var K = M.getModel("labelLine.emphasis");
            N.setStyle(B(O, Q, "normal", S));
            N.ignore = N.normalIgnore = !S.get("show");
            N.hoverIgnore = !R.get("show");
            L.ignore = L.normalIgnore = !V.get("show");
            L.hoverIgnore = !K.get("show");
            L.setStyle({stroke: U});
            L.setStyle(V.getModel("lineStyle").getLineStyle());
            N.hoverStyle = B(O, Q, "emphasis", R);
            L.hoverStyle = K.getModel("lineStyle").getLineStyle()
        };
        C.inherits(G, E.Group);
        var F = D(80).extend({
            type: "funnel", render: function(K, L, O) {
                var P = K.getData();
                var N = this._data;
                var M = this.group;
                P.diff(N).add(function(R) {
                    var Q = new G(P, R);
                    P.setItemGraphicEl(R, Q);
                    M.add(Q)
                }).update(function(Q, R) {
                    var S = N.getItemGraphicEl(R);
                    S.updateData(P, Q);
                    M.add(S);
                    P.setItemGraphicEl(Q, S)
                }).remove(function(Q) {
                    var R = N.getItemGraphicEl(Q);
                    M.remove(R)
                }).execute();
                this._data = P
            }, remove: function() {
                this.group.removeAll();
                this._data = null
            }, dispose: function() {
            }
        });
        I.exports = F
    }, function(H, I, C) {
        var E = C(71);
        var A = C(7);
        var D = A.parsePercent;

        function G(J, K) {
            return E.getLayoutRect(J.getBoxLayoutParams(), {width: K.getWidth(), height: K.getHeight()})
        }

        function F(P, K) {
            var M = P.mapArray("value", function(Q) {
                return Q
            });
            var J = [];
            var O = K === "ascending";
            for (var L = 0, N = P.count(); L < N; L++) {
                J[L] = L
            }
            if (typeof K === "function") {
                J.sort(K)
            } else {
                if (K !== "none") {
                    J.sort(function(R, Q) {
                        return O ? M[R] - M[Q] : M[Q] - M[R]
                    })
                }
            }
            return J
        }

        function B(J) {
            J.each(function(Y) {
                var N = J.getItemModel(Y);
                var L = N.getModel("label.normal");
                var K = L.get("position");
                var V = N.getModel("labelLine.normal");
                var Q = J.getItemLayout(Y);
                var S = Q.points;
                var P = K === "inner" || K === "inside" || K === "center";
                var R;
                var W;
                var X;
                var O;
                if (P) {
                    W = (S[0][0] + S[1][0] + S[2][0] + S[3][0]) / 4;
                    X = (S[0][1] + S[1][1] + S[2][1] + S[3][1]) / 4;
                    R = "center";
                    O = [[W, X], [W, X]]
                } else {
                    var T;
                    var U;
                    var Z;
                    var M = V.get("length");
                    if (K === "left") {
                        T = (S[3][0] + S[0][0]) / 2;
                        U = (S[3][1] + S[0][1]) / 2;
                        Z = T - M;
                        W = Z - 5;
                        R = "right"
                    } else {
                        T = (S[1][0] + S[2][0]) / 2;
                        U = (S[1][1] + S[2][1]) / 2;
                        Z = T + M;
                        W = Z + 5;
                        R = "left"
                    }
                    var a = U;
                    O = [[T, U], [Z, a]];
                    X = a
                }
                Q.label = {linePoints: O, x: W, y: X, verticalAlign: "middle", textAlign: R, inside: P}
            })
        }

        H.exports = function(J, L, K) {
            J.eachSeriesByType("funnel", function(R) {
                var N = R.getData();
                var W = R.get("sort");
                var e = G(R, L);
                var X = F(N, W);
                var M = [D(R.get("minSize"), e.width), D(R.get("maxSize"), e.width)];
                var Q = N.getDataExtent("value");
                var U = R.get("min");
                var Z = R.get("max");
                if (U == null) {
                    U = Math.min(Q[0], 0)
                }
                if (Z == null) {
                    Z = Q[1]
                }
                var T = R.get("funnelAlign");
                var P = R.get("gap");
                var O = (e.height - P * (N.count() - 1)) / N.count();
                var a = e.y;
                var V = function(i, f) {
                    var j = N.get("value", i) || 0;
                    var g = A.linearMap(j, [U, Z], M, true);
                    var h;
                    switch (T) {
                        case"left":
                            h = e.x;
                            break;
                        case"center":
                            h = e.x + (e.width - g) / 2;
                            break;
                        case"right":
                            h = e.x + e.width - g;
                            break
                    }
                    return [[h, f], [h + g, f]]
                };
                if (W === "ascending") {
                    O = -O;
                    P = -P;
                    a += e.height;
                    X = X.reverse()
                }
                for (var Y = 0; Y < X.length; Y++) {
                    var b = X[Y];
                    var S = X[Y + 1];
                    var d = V(b, a);
                    var c = V(S, a + O);
                    a += O + P;
                    N.setItemLayout(b, {points: d.concat(c.slice().reverse())})
                }
                B(N)
            })
        }
    }, function(B, D, A) {
        var C = A(1);
        A(235);
        A(248);
        A(249);
        C.registerVisual(A(250))
    }, function(H, I, C) {
        C(236);
        C(240);
        C(242);
        var B = C(1);
        var E = C(4);
        var G = C(81);
        var D = 5;
        B.extendComponentView({
            type: "parallel", render: function(J, L, K) {
                this._model = J;
                this._api = K;
                if (!this._handlers) {
                    this._handlers = {};
                    E.each(F, function(M, N) {
                        K.getZr().on(N, this._handlers[N] = E.bind(M, this))
                    }, this)
                }
                G.createOrUpdate(this, "_throttledDispatchExpand", J.get("axisExpandRate"), "fixRate")
            }, dispose: function(J, K) {
                E.each(this._handlers, function(L, M) {
                    K.getZr().off(M, L)
                });
                this._handlers = null
            }, _throttledDispatchExpand: function(J) {
                this._dispatchExpand(J)
            }, _dispatchExpand: function(J) {
                J && this._api.dispatchAction(E.extend({type: "parallelAxisExpand"}, J))
            }
        });
        var F = {
            mousedown: function(J) {
                if (A(this, "click")) {
                    this._mouseDownPoint = [J.offsetX, J.offsetY]
                }
            }, mouseup: function(K) {
                var N = this._mouseDownPoint;
                if (A(this, "click") && N) {
                    var L = [K.offsetX, K.offsetY];
                    var M = Math.pow(N[0] - L[0], 2) + Math.pow(N[1] - L[1], 2);
                    if (M > D) {
                        return
                    }
                    var J = this._model.coordinateSystem.getSlidedAxisExpandWindow([K.offsetX, K.offsetY]);
                    J.behavior !== "none" && this._dispatchExpand({axisExpandWindow: J.axisExpandWindow})
                }
                this._mouseDownPoint = null
            }, mousemove: function(K) {
                if (this._mouseDownPoint || !A(this, "mousemove")) {
                    return
                }
                var M = this._model;
                var L = M.coordinateSystem.getSlidedAxisExpandWindow([K.offsetX, K.offsetY]);
                var J = L.behavior;
                J === "jump" && this._throttledDispatchExpand.debounceNextCall(M.get("axisExpandDebounce"));
                this._throttledDispatchExpand(J === "none" ? null : {axisExpandWindow: L.axisExpandWindow, animation: J === "jump" ? null : false})
            }
        };

        function A(K, J) {
            var L = K._model;
            return L.get("axisExpandable") && L.get("axisExpandTriggerOn") === J
        }

        B.registerPreprocessor(C(247))
    }, function(B, D, A) {
        var E = A(237);

        function C(F, G) {
            var H = [];
            F.eachComponent("parallel", function(I, K) {
                var J = new E(I, F, G);
                J.name = "parallel_" + K;
                J.resize(I, G);
                I.coordinateSystem = J;
                J.model = I;
                H.push(J)
            });
            F.eachSeries(function(I) {
                if (I.get("coordinateSystem") === "parallel") {
                    var J = F.queryComponents({mainType: "parallel", index: I.get("parallelIndex"), id: I.get("parallelId")})[0];
                    I.coordinateSystem = J.coordinateSystem
                }
            });
            return H
        }

        A(76).register("parallel", {create: C})
    }, function(S, G, T) {
        var N = T(71);
        var L = T(101);
        var F = T(4);
        var E = T(238);
        var O = T(18);
        var J = T(11);
        var R = T(7);
        var K = T(239);
        var H = F.each;
        var U = Math.min;
        var Q = Math.max;
        var C = Math.floor;
        var M = Math.ceil;
        var A = R.round;
        var I = Math.PI;

        function D(W, Y, X) {
            this._axesMap = F.createHashMap();
            this._axesLayout = {};
            this.dimensions = W.dimensions;
            this._rect;
            this._model = W;
            this._init(W, Y, X)
        }

        D.prototype = {
            type: "parallel", constructor: D, _init: function(X, a, Y) {
                var W = X.dimensions;
                var Z = X.parallelAxisIndex;
                H(W, function(e, c) {
                    var g = Z[c];
                    var d = a.getComponent("parallelAxis", g);
                    var f = this._axesMap.set(e, new E(e, L.createScaleByModel(d), [0, 0], d.get("type"), g));
                    var b = f.type === "category";
                    f.onBand = b && d.get("boundaryGap");
                    f.inverse = d.get("inverse");
                    d.axis = f;
                    f.model = d;
                    f.coordinateSystem = d.coordinateSystem = this
                }, this)
            }, update: function(W, X) {
                this._updateAxesFromSeries(this._model, W)
            }, containPoint: function(X) {
                var c = this._makeLayoutInfo();
                var b = c.axisBase;
                var W = c.layoutBase;
                var a = c.pixelDimIndex;
                var Y = X[1 - a];
                var Z = X[a];
                return Y >= b && Y <= b + c.axisLength && Z >= W && Z <= W + c.layoutLength
            }, _updateAxesFromSeries: function(W, X) {
                X.eachSeries(function(Y) {
                    if (!W.contains(Y, X)) {
                        return
                    }
                    var Z = Y.getData();
                    H(this.dimensions, function(a) {
                        var b = this._axesMap.get(a);
                        b.scale.unionExtentFromData(Z, a);
                        L.niceScaleExtent(b.scale, b.model)
                    }, this)
                }, this)
            }, resize: function(W, X) {
                this._rect = N.getLayoutRect(W.getBoxLayoutParams(), {width: X.getWidth(), height: X.getHeight()});
                this._layoutAxes()
            }, getRect: function() {
                return this._rect
            }, _makeLayoutInfo: function() {
                var l = this._model;
                var e = this._rect;
                var Z = ["x", "y"];
                var a = ["width", "height"];
                var d = l.get("layout");
                var h = d === "horizontal" ? 0 : 1;
                var i = e[a[h]];
                var j = [0, i];
                var f = this.dimensions.length;
                var X = P(l.get("axisExpandWidth"), j);
                var Y = P(l.get("axisExpandCount") || 0, [0, f]);
                var c = l.get("axisExpandable") && f > 3 && f > Y && Y > 1 && X > 0 && i > 0;
                var k = l.get("axisExpandWindow");
                var m;
                if (!k) {
                    m = P(X * (Y - 1), j);
                    var g = l.get("axisExpandCenter") || C(f / 2);
                    k = [X * g - m / 2];
                    k[1] = k[0] + m
                } else {
                    m = P(k[1] - k[0], j);
                    k[1] = k[0] + m
                }
                var n = (i - m) / (f - Y);
                n < 3 && (n = 0);
                var W = [C(A(k[0] / X, 1)) + 1, M(A(k[1] / X, 1)) - 1];
                var b = n / X * k[0];
                return {
                    layout: d,
                    pixelDimIndex: h,
                    layoutBase: e[Z[h]],
                    layoutLength: i,
                    axisBase: e[Z[1 - h]],
                    axisLength: e[a[1 - h]],
                    axisExpandable: c,
                    axisExpandWidth: X,
                    axisCollapseWidth: n,
                    axisExpandWindow: k,
                    axisCount: f,
                    winInnerIndices: W,
                    axisExpandWindow0Pos: b
                }
            }, _layoutAxes: function() {
                var X = this._rect;
                var W = this._axesMap;
                var Y = this.dimensions;
                var a = this._makeLayoutInfo();
                var Z = a.layout;
                W.each(function(d) {
                    var b = [0, a.axisLength];
                    var c = d.inverse ? 1 : 0;
                    d.setExtent(b[c], b[1 - c])
                });
                H(Y, function(e, d) {
                    var h = (a.axisExpandable ? V : B)(d, a);
                    var b = {horizontal: {x: h.position, y: a.axisLength}, vertical: {x: 0, y: h.position}};
                    var c = {horizontal: I / 2, vertical: 0};
                    var g = [b[Z].x + X.x, b[Z].y + X.y];
                    var i = c[Z];
                    var f = J.create();
                    J.rotate(f, f, i);
                    J.translate(f, f, g);
                    this._axesLayout[e] = {
                        position: g,
                        rotation: i,
                        transform: f,
                        axisNameAvailableWidth: h.axisNameAvailableWidth,
                        axisLabelShow: h.axisLabelShow,
                        nameTruncateMaxWidth: h.nameTruncateMaxWidth,
                        tickDirection: 1,
                        labelDirection: 1,
                        labelInterval: W.get(e).getLabelInterval()
                    }
                }, this)
            }, getAxis: function(W) {
                return this._axesMap.get(W)
            }, dataToPoint: function(X, W) {
                return this.axisCoordToPoint(this._axesMap.get(W).dataToCoord(X), W)
            }, eachActiveState: function(a, Z, e) {
                var W = this.dimensions;
                var c = this._axesMap;
                var l = this.hasAxisBrushed();
                for (var f = 0, h = a.count(); f < h; f++) {
                    var g = a.getValues(W, f);
                    var Y;
                    if (!l) {
                        Y = "normal"
                    } else {
                        Y = "active";
                        for (var d = 0, b = W.length; d < b; d++) {
                            var X = W[d];
                            var k = c.get(X).model.getActiveState(g[d], d);
                            if (k === "inactive") {
                                Y = "inactive";
                                break
                            }
                        }
                    }
                    Z.call(e, Y, f)
                }
            }, hasAxisBrushed: function() {
                var Y = this.dimensions;
                var W = this._axesMap;
                var Z = false;
                for (var a = 0, X = Y.length; a < X; a++) {
                    if (W.get(Y[a]).model.getActiveState() !== "normal") {
                        Z = true
                    }
                }
                return Z
            }, axisCoordToPoint: function(W, X) {
                var Y = this._axesLayout[X];
                return O.applyTransform([W, 0], Y.transform)
            }, getAxisLayout: function(W) {
                return F.clone(this._axesLayout[W])
            }, getSlidedAxisExpandWindow: function(h) {
                var b = this._makeLayoutInfo();
                var Y = b.pixelDimIndex;
                var g = b.axisExpandWindow.slice();
                var c = g[1] - g[0];
                var a = [0, b.axisExpandWidth * (b.axisCount - 1)];
                if (!this.containPoint(h)) {
                    return {behavior: "none", axisExpandWindow: g}
                }
                var W = h[Y] - b.layoutBase - b.axisExpandWindow0Pos;
                var f;
                var e = "slide";
                var Z = b.axisCollapseWidth;
                var i = this._model.get("axisExpandSlideTriggerArea");
                var X = i[0] != null;
                if (Z) {
                    if (X && Z && W < c * i[0]) {
                        e = "jump";
                        f = W - c * i[2]
                    } else {
                        if (X && Z && W > c * (1 - i[0])) {
                            e = "jump";
                            f = W - c * (1 - i[2])
                        } else {
                            (f = W - c * i[1]) >= 0 && (f = W - c * (1 - i[1])) <= 0 && (f = 0)
                        }
                    }
                    f *= b.axisExpandWidth / Z;
                    f ? K(f, g, a, "all") : (e = "none")
                } else {
                    var c = g[1] - g[0];
                    var d = a[1] * W / c;
                    g = [Q(0, d - c / 2)];
                    g[1] = U(a[1], g[0] + c);
                    g[0] = g[1] - c
                }
                return {axisExpandWindow: g, behavior: e}
            }
        };

        function P(X, W) {
            return U(Q(X, W[0]), W[1])
        }

        function B(Y, X) {
            var W = X.layoutLength / (X.axisCount - 1);
            return {position: W * Y, axisNameAvailableWidth: W, axisLabelShow: true}
        }

        function V(b, c) {
            var W = c.layoutLength;
            var g = c.axisExpandWidth;
            var X = c.axisCount;
            var Z = c.axisCollapseWidth;
            var f = c.winInnerIndices;
            var e;
            var d = Z;
            var a = false;
            var Y;
            if (b < f[0]) {
                e = b * Z;
                Y = Z
            } else {
                if (b <= f[1]) {
                    e = c.axisExpandWindow0Pos + b * g - c.axisExpandWindow[0];
                    d = g;
                    a = true
                } else {
                    e = W - (X - 1 - b) * Z;
                    Y = Z
                }
            }
            return {position: e, axisNameAvailableWidth: d, axisLabelShow: a, nameTruncateMaxWidth: Y}
        }

        S.exports = D
    }, function(D, F, C) {
        var B = C(4);
        var E = C(100);
        var A = function(H, I, G, J, K) {
            E.call(this, H, I, G);
            this.type = J || "value";
            this.axisIndex = K
        };
        A.prototype = {constructor: A, model: null};
        B.inherits(A, E);
        D.exports = A
    }, function(B, D) {
        B.exports = function(L, M, H, E, O, G) {
            M[0] = C(M[0], H);
            M[1] = C(M[1], H);
            L = L || 0;
            var J = H[1] - H[0];
            if (O != null) {
                O = C(O, [0, J])
            }
            if (G != null) {
                G = Math.max(G, O != null ? O : 0)
            }
            if (E === "all") {
                O = G = Math.abs(M[1] - M[0]);
                E = 0
            }
            var K = A(M, E);
            M[E] += L;
            var F = O || 0;
            var I = H.slice();
            K.sign < 0 ? (I[0] += F) : (I[1] -= F);
            M[E] = C(M[E], I);
            var N = A(M, E);
            if (O != null && (N.sign !== K.sign || N.span < O)) {
                M[1 - E] = M[E] + K.sign * O
            }
            var N = A(M, E);
            if (G != null && N.span > G) {
                M[1 - E] = M[E] + N.sign * G
            }
            return M
        };

        function A(E, F) {
            var G = E[F] - E[1 - F];
            return {span: Math.abs(G), sign: G > 0 ? -1 : G < 0 ? 1 : F ? -1 : 1}
        }

        function C(E, F) {
            return Math.min(F[1], Math.max(F[0], E))
        }
    }, function(C, E, B) {
        var A = B(4);
        var D = B(69);
        B(241);
        D.extend({
            type: "parallel",
            dependencies: ["parallelAxis"],
            coordinateSystem: null,
            dimensions: null,
            parallelAxisIndex: null,
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                layout: "horizontal",
                axisExpandable: false,
                axisExpandCenter: null,
                axisExpandCount: 0,
                axisExpandWidth: 50,
                axisExpandRate: 17,
                axisExpandDebounce: 50,
                axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
                axisExpandTriggerOn: "click",
                parallelAxisDefault: null
            },
            init: function() {
                D.prototype.init.apply(this, arguments);
                this.mergeOption({})
            },
            mergeOption: function(F) {
                var G = this.option;
                F && A.merge(G, F, true);
                this._initDimensions()
            },
            contains: function(H, G) {
                var F = H.get("parallelIndex");
                return F != null && G.getComponent("parallel", F) === this
            },
            setAxisExpand: function(F) {
                A.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(G) {
                    if (F.hasOwnProperty(G)) {
                        this.option[G] = F[G]
                    }
                }, this)
            },
            _initDimensions: function() {
                var G = this.dimensions = [];
                var H = this.parallelAxisIndex = [];
                var F = A.filter(this.dependentModels.parallelAxis, function(I) {
                    return I.get("parallelIndex") === this.componentIndex
                });
                A.each(F, function(I) {
                    G.push("dim" + I.get("dim"));
                    H.push(I.componentIndex)
                })
            }
        })
    }, function(I, K, D) {
        var J = D(69);
        var C = D(4);
        var F = D(15);
        var B = D(131);
        var E = D(7);
        var H = J.extend({
            type: "baseParallelAxis", axis: null, activeIntervals: [], getAreaSelectStyle: function() {
                return F([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]]).call(this.getModel("areaSelectStyle"))
            }, setActiveIntervals: function(L) {
                var N = this.activeIntervals = C.clone(L);
                if (N) {
                    for (var M = N.length - 1; M >= 0; M--) {
                        E.asc(N[M])
                    }
                }
            }, getActiveState: function(O) {
                var M = this.activeIntervals;
                if (!M.length) {
                    return "normal"
                }
                if (O == null) {
                    return "inactive"
                }
                for (var L = 0, N = M.length; L < N; L++) {
                    if (M[L][0] <= O && O <= M[L][1]) {
                        return "active"
                    }
                }
                return "inactive"
            }
        });
        var G = {
            type: "value",
            dim: null,
            areaSelectStyle: {width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: 0.3},
            realtime: true,
            z: 10
        };
        C.merge(H.prototype, D(112));

        function A(M, L) {
            return L.type || (L.data ? "category" : "value")
        }

        B("parallel", H, A, G);
        I.exports = H
    }, function(B, C, A) {
        A(236);
        A(243);
        A(244)
    }, function(C, E, A) {
        var D = A(1);
        var B = {type: "axisAreaSelect", event: "axisAreaSelected", update: "updateVisual"};
        D.registerAction(B, function(G, F) {
            F.eachComponent({mainType: "parallelAxis", query: G}, function(H) {
                H.axis.model.setActiveIntervals(G.intervals)
            })
        });
        D.registerAction("parallelAxisExpand", function(G, F) {
            F.eachComponent({mainType: "parallel", query: G}, function(H) {
                H.setAxisExpand(G)
            })
        })
    }, function(L, M, F) {
        var G = F(4);
        var C = F(135);
        var E = F(245);
        var J = F(246);
        var I = F(18);
        var D = ["axisLine", "axisLabel", "axisTick", "axisName"];
        var K = F(1).extendComponentView({
            type: "parallelAxis", init: function(N, O) {
                K.superApply(this, "init", arguments);
                (this._brushController = new E(O.getZr())).on("brush", G.bind(this._onBrush, this))
            }, render: function(Q, O, Y, S) {
                if (B(Q, O, S)) {
                    return
                }
                this.axisModel = Q;
                this.api = Y;
                this.group.removeAll();
                var U = this._axisGroup;
                this._axisGroup = new I.Group();
                this.group.add(this._axisGroup);
                if (!Q.get("show")) {
                    return
                }
                var V = A(Q, O);
                var P = V.coordinateSystem;
                var T = Q.getAreaSelectStyle();
                var Z = T.width;
                var X = Q.axis.dim;
                var R = P.getAxisLayout(X);
                var a = G.extend({strokeContainThreshold: Z}, R);
                var W = new C(Q, a);
                G.each(D, W.add, W);
                this._axisGroup.add(W.getGroup());
                this._refreshBrushController(a, T, Q, V, Z, Y);
                var N = (S && S.animation === false) ? null : Q;
                I.groupTransition(U, this._axisGroup, N)
            }, updateVisual: function(O, N, Q, P) {
                this._brushController && this._brushController.updateCovers(H(O))
            }, _refreshBrushController: function(W, R, P, S, V, U) {
                var Q = P.axis.getExtent();
                var T = Q[1] - Q[0];
                var O = Math.min(30, Math.abs(T) * 0.1);
                var N = I.BoundingRect.create({x: Q[0], y: -V / 2, width: T, height: V});
                N.x -= O;
                N.width += 2 * O;
                this._brushController.mount({enableGlobalPan: true, rotation: W.rotation, position: W.position}).setPanels([{
                    panelId: "pl",
                    clipPath: J.makeRectPanelClipPath(N),
                    isTargetByCursor: J.makeRectIsTargetByCursor(N, U, S),
                    getLinearBrushOtherExtent: J.makeLinearBrushOtherExtent(N, 0)
                }]).enableBrush({brushType: "lineX", brushStyle: R, removeOnClick: true}).updateCovers(H(P))
            }, _onBrush: function(N, O) {
                var Q = this.axisModel;
                var R = Q.axis;
                var P = G.map(N, function(S) {
                    return [R.coordToData(S.range[0], true), R.coordToData(S.range[1], true)]
                });
                if (!Q.option.realtime === O.isEnd || O.removeOnClick) {
                    this.api.dispatchAction({type: "axisAreaSelect", parallelAxisId: Q.id, intervals: P})
                }
            }, dispose: function() {
                this._brushController.dispose()
            }
        });

        function B(O, N, P) {
            return P && P.type === "axisAreaSelect" && N.findComponents({mainType: "parallelAxis", query: P})[0] === O
        }

        function H(N) {
            var O = N.axis;
            return G.map(N.activeIntervals, function(P) {
                return {brushType: "lineX", panelId: "pl", range: [O.dataToCoord(P[0], true), O.dataToCoord(P[1], true)]}
            })
        }

        function A(O, N) {
            return N.getComponent("parallel", O.get("parallelIndex"))
        }

        L.exports = K
    }, function(Ab, Af, Z) {
        var D = Z(25);
        var i = Z(4);
        var y = Z(18);
        var d = Z(184);
        var F = Z(99);
        var Q = i.curry;
        var X = i.each;
        var Ac = i.map;
        var v = Math.min;
        var s = Math.max;
        var g = Math.pow;
        var R = 10000;
        var A = 6;
        var C = 6;
        var l = "globalPan";
        var B = {w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1]};
        var N = {w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse"};
        var P = {
            brushStyle: {lineWidth: 2, stroke: "rgba(0,0,0,0.3)", fill: "rgba(0,0,0,0.1)"},
            transformable: true,
            brushMode: "single",
            removeOnClick: false
        };
        var G = 0;

        function W(Ah) {
            if (true) {
                i.assert(Ah)
            }
            D.call(this);
            this._zr = Ah;
            this.group = new y.Group();
            this._brushType;
            this._brushOption;
            this._panels;
            this._track = [];
            this._dragging;
            this._covers = [];
            this._creatingCover;
            this._creatingPanel;
            this._enableGlobalPan;
            if (true) {
                this._mounted
            }
            this._uid = "brushController_" + G++;
            this._handlers = {};
            X(T, function(Ai, Aj) {
                this._handlers[Aj] = i.bind(Ai, this)
            }, this)
        }

        W.prototype = {
            constructor: W, enableBrush: function(Ah) {
                if (true) {
                    i.assert(this._mounted)
                }
                this._brushType && Aa(this);
                Ah.brushType && h(this, Ah);
                return this
            }, setPanels: function(Ah) {
                if (Ah && Ah.length) {
                    var Ai = this._panels = {};
                    i.each(Ah, function(Aj) {
                        Ai[Aj.panelId] = i.clone(Aj)
                    })
                } else {
                    this._panels = null
                }
                return this
            }, mount: function(Ah) {
                Ah = Ah || {};
                if (true) {
                    this._mounted = true
                }
                this._enableGlobalPan = Ah.enableGlobalPan;
                var Ai = this.group;
                this._zr.add(Ai);
                Ai.attr({position: Ah.position || [0, 0], rotation: Ah.rotation || 0, scale: Ah.scale || [1, 1]});
                this._transform = Ai.getLocalTransform();
                return this
            }, eachCover: function(Ah, Ai) {
                X(this._covers, Ah, Ai)
            }, updateCovers: function(Al) {
                if (true) {
                    i.assert(this._mounted)
                }
                Al = i.map(Al, function(Ar) {
                    return i.merge(i.clone(P), Ar, true)
                });
                var Ai = "\0-brush-index-";
                var Ao = this._covers;
                var Am = this._covers = [];
                var An = this;
                var Aj = this._creatingCover;
                (new F(Ao, Al, Aq, Ak)).add(Ap).update(Ap).remove(Ah).execute();
                return this;

                function Ak(Ar, As) {
                    return (Ar.id != null ? Ar.id : Ai + As) + "-" + Ar.brushType
                }

                function Aq(As, Ar) {
                    return Ak(As.__brushOption, Ar)
                }

                function Ap(Au, As) {
                    var Ar = Al[Au];
                    if (As != null && Ao[As] === Aj) {
                        Am[Au] = Ao[As]
                    } else {
                        var At = Am[Au] = As != null ? (Ao[As].__brushOption = Ar, Ao[As]) : p(An, u(An, Ar));
                        a(An, At)
                    }
                }

                function Ah(Ar) {
                    if (Ao[Ar] !== Aj) {
                        An.group.remove(Ao[Ar])
                    }
                }
            }, unmount: function() {
                if (true) {
                    if (!this._mounted) {
                        return
                    }
                }
                this.enableBrush(false);
                q(this);
                this._zr.remove(this.group);
                if (true) {
                    this._mounted = false
                }
                return this
            }, dispose: function() {
                this.unmount();
                this.off()
            }
        };
        i.mixin(W, D);

        function h(Aj, Ai) {
            var Ah = Aj._zr;
            if (!Aj._enableGlobalPan) {
                d.take(Ah, l, Aj._uid)
            }
            X(Aj._handlers, function(Ak, Al) {
                Ah.on(Al, Ak)
            });
            Aj._brushType = Ai.brushType;
            Aj._brushOption = i.merge(i.clone(P), Ai, true)
        }

        function Aa(Ai) {
            var Ah = Ai._zr;
            d.release(Ah, l, Ai._uid);
            X(Ai._handlers, function(Aj, Ak) {
                Ah.off(Ak, Aj)
            });
            Ai._brushType = Ai._brushOption = null
        }

        function u(Aj, Ah) {
            var Ai = x[Ah.brushType].createCover(Aj, Ah);
            Ai.__brushOption = Ah;
            V(Ai, Ah);
            Aj.group.add(Ai);
            return Ai
        }

        function p(Aj, Ai) {
            var Ah = r(Ai);
            if (Ah.endCreating) {
                Ah.endCreating(Aj, Ai);
                V(Ai, Ai.__brushOption)
            }
            return Ai
        }

        function L(Aj, Ai) {
            var Ah = Ai.__brushOption;
            r(Ai).updateCoverShape(Aj, Ai, Ah.range, Ah)
        }

        function V(Aj, Ah) {
            var Ai = Ah.z;
            Ai == null && (Ai = R);
            Aj.traverse(function(Ak) {
                Ak.z = Ai;
                Ak.z2 = Ai
            })
        }

        function a(Ai, Ah) {
            r(Ah).updateCommon(Ai, Ah);
            L(Ai, Ah)
        }

        function r(Ah) {
            return x[Ah.__brushOption.brushType]
        }

        function e(Am, Aj, Ai) {
            var Al = Am._panels;
            if (!Al) {
                return true
            }
            var Ah;
            var Ak = Am._transform;
            X(Al, function(An) {
                An.isTargetByCursor(Aj, Ai, Ak) && (Ah = An)
            });
            return Ah
        }

        function K(Ak, Ai) {
            var Aj = Ak._panels;
            if (!Aj) {
                return true
            }
            var Ah = Ai.__brushOption.panelId;
            return Ah != null ? Aj[Ah] : true
        }

        function q(Aj) {
            var Ah = Aj._covers;
            var Ai = Ah.length;
            X(Ah, function(Ak) {
                Aj.group.remove(Ak)
            }, Aj);
            Ah.length = 0;
            return !!Ai
        }

        function z(Aj, Ai) {
            var Ah = Ac(Aj._covers, function(Al) {
                var Ak = Al.__brushOption;
                var Am = i.clone(Ak.range);
                return {brushType: Ak.brushType, panelId: Ak.panelId, range: Am}
            });
            Aj.trigger("brush", Ah, {isEnd: !!Ai.isEnd, removeOnClick: !!Ai.removeOnClick})
        }

        function H(An) {
            var Al = An._track;
            if (!Al.length) {
                return false
            }
            var Am = Al[Al.length - 1];
            var Ak = Al[0];
            var Aj = Am[0] - Ak[0];
            var Ai = Am[1] - Ak[1];
            var Ah = g(Aj * Aj + Ai * Ai, 0.5);
            return Ah > A
        }

        function O(Ai) {
            var Ah = Ai.length - 1;
            Ah < 0 && (Ah = 0);
            return [Ai[0], Ai[Ah]]
        }

        function E(Ai, Al, Ah, Ak) {
            var Aj = new y.Group();
            Aj.add(new y.Rect({
                name: "main",
                style: b(Ah),
                silent: true,
                draggable: true,
                cursor: "move",
                drift: Q(Ai, Al, Aj, "nswe"),
                ondragend: Q(z, Al, {isEnd: true})
            }));
            X(Ak, function(Am) {
                Aj.add(new y.Rect({
                    name: Am,
                    style: {opacity: 0},
                    draggable: true,
                    silent: true,
                    invisible: true,
                    drift: Q(Ai, Al, Aj, Am),
                    ondragend: Q(z, Al, {isEnd: true})
                }))
            });
            return Aj
        }

        function m(Aw, Aj, Al, An) {
            var At = An.brushStyle.lineWidth || 0;
            var Ah = s(At, C);
            var Au = Al[0][0];
            var Av = Al[1][0];
            var Ap = Au - At / 2;
            var Aq = Av - At / 2;
            var Ax = Al[0][1];
            var Ay = Al[1][1];
            var Ai = Ax - Ah + At / 2;
            var Ao = Ay - Ah + At / 2;
            var Ar = Ax - Au;
            var As = Ay - Av;
            var Am = Ar + At;
            var Ak = As + At;
            c(Aw, Aj, "main", Au, Av, Ar, As);
            if (An.transformable) {
                c(Aw, Aj, "w", Ap, Aq, Ah, Ak);
                c(Aw, Aj, "e", Ai, Aq, Ah, Ak);
                c(Aw, Aj, "n", Ap, Aq, Am, Ah);
                c(Aw, Aj, "s", Ap, Ao, Am, Ah);
                c(Aw, Aj, "nw", Ap, Aq, Ah, Ah);
                c(Aw, Aj, "ne", Ai, Aq, Ah, Ah);
                c(Aw, Aj, "sw", Ap, Ao, Ah, Ah);
                c(Aw, Aj, "se", Ai, Ao, Ah, Ah)
            }
        }

        function J(Al, Ak) {
            var Ai = Ak.__brushOption;
            var Aj = Ai.transformable;
            var Ah = Ak.childAt(0);
            Ah.useStyle(b(Ai));
            Ah.attr({silent: !Aj, cursor: Aj ? "move" : "default"});
            X(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(Ao) {
                var Am = Ak.childOfName(Ao);
                var An = U(Al, Ao);
                Am && Am.attr({silent: !Aj, invisible: !Aj, cursor: Aj ? N[An] + "-resize" : null})
            })
        }

        function c(Am, Ah, Aj, An, Ao, Ak, Al) {
            var Ai = Ah.childOfName(Aj);
            Ai && Ai.setShape(n(Ad(Am, Ah, [[An, Ao], [An + Ak, Ao + Al]])))
        }

        function b(Ah) {
            return i.defaults({strokeNoScale: true}, Ah.brushStyle)
        }

        function I(Aj, Ak, Ah, Ai) {
            var Al = [v(Aj, Ah), v(Ak, Ai)];
            var Am = [s(Aj, Ah), s(Ak, Ai)];
            return [[Al[0], Am[0]], [Al[1], Am[1]]]
        }

        function k(Ah) {
            return y.getTransform(Ah.group)
        }

        function U(Al, Aj) {
            if (Aj.length > 1) {
                Aj = Aj.split("");
                var Ah = [U(Al, Aj[0]), U(Al, Aj[1])];
                (Ah[0] === "e" || Ah[0] === "w") && Ah.reverse();
                return Ah.join("")
            } else {
                var Ai = {w: "left", e: "right", n: "top", s: "bottom"};
                var Ak = {left: "w", right: "e", top: "n", bottom: "s"};
                var Ah = y.transformDirection(Ai[Aj], k(Al));
                return Ak[Ah]
            }
        }

        function Ae(Ai, Ao, Am, Ah, Aj, Ap, An, Ak) {
            var Ar = Ah.__brushOption;
            var Aq = Ai(Ar.range);
            var Al = t(Am, Ap, An);
            X(Aj.split(""), function(As) {
                var At = B[As];
                Aq[At[0]][At[1]] += Al[At[0]]
            });
            Ar.range = Ao(I(Aq[0][0], Aq[1][0], Aq[0][1], Aq[1][1]));
            a(Am, Ah);
            z(Am, {isEnd: false})
        }

        function f(An, Ak, Ai, Aj, Ah) {
            var Am = Ak.__brushOption.range;
            var Al = t(An, Ai, Aj);
            X(Am, function(Ao) {
                Ao[0] += Al[0];
                Ao[1] += Al[1]
            });
            a(An, Ak);
            z(An, {isEnd: false})
        }

        function t(Am, Aj, Ak) {
            var Al = Am.group;
            var Ah = Al.transformCoordToLocal(Aj, Ak);
            var Ai = Al.transformCoordToLocal(0, 0);
            return [Ah[0] - Ai[0], Ah[1] - Ai[1]]
        }

        function Ad(Ak, Aj, Ai) {
            var Ah = K(Ak, Aj);
            return (Ah && Ah !== true) ? Ah.clipPath(Ai, Ak._transform) : i.clone(Ai)
        }

        function n(Ai) {
            var Al = v(Ai[0][0], Ai[1][0]);
            var Ah = v(Ai[0][1], Ai[1][1]);
            var Ak = s(Ai[0][0], Ai[1][0]);
            var Aj = s(Ai[0][1], Ai[1][1]);
            return {x: Al, y: Ah, width: Ak - Al, height: Aj - Ah}
        }

        function Y(Am, Ah, Aj) {
            if (!Am._brushType) {
                return
            }
            var Ai = Am._zr;
            var Ak = Am._covers;
            var An = e(Am, Ah, Aj);
            if (!Am._dragging) {
                for (var Al = 0; Al < Ak.length; Al++) {
                    var Ao = Ak[Al].__brushOption;
                    if (An && (An === true || Ao.panelId === An.panelId) && x[Ao.brushType].contain(Ak[Al], Aj[0], Aj[1])) {
                        return
                    }
                }
            }
            An && Ai.setCursorStyle("crosshair")
        }

        function Ag(Ah) {
            var Ai = Ah.event;
            Ai.preventDefault && Ai.preventDefault()
        }

        function j(Ai, Ah, Aj) {
            return Ai.childOfName("main").contain(Ah, Aj)
        }

        function M(Am, Ah, Aj, Ak) {
            var Ai = Am._creatingCover;
            var Ao = Am._creatingPanel;
            var Aq = Am._brushOption;
            var Al;
            Am._track.push(Aj.slice());
            if (H(Am) || Ai) {
                if (Ao && !Ai) {
                    Aq.brushMode === "single" && q(Am);
                    var Ap = i.clone(Aq);
                    Ap.brushType = o(Ap.brushType, Ao);
                    Ap.panelId = Ao === true ? null : Ao.panelId;
                    Ai = Am._creatingCover = u(Am, Ap);
                    Am._covers.push(Ai)
                }
                if (Ai) {
                    var Ar = x[o(Am._brushType, Ao)];
                    var An = Ai.__brushOption;
                    An.range = Ar.getCreatingRange(Ad(Am, Ai, Am._track));
                    if (Ak) {
                        p(Am, Ai);
                        Ar.updateCommon(Am, Ai)
                    }
                    L(Am, Ai);
                    Al = {isEnd: Ak}
                }
            } else {
                if (Ak && Aq.brushMode === "single" && Aq.removeOnClick) {
                    if (e(Am, Ah, Aj) && q(Am)) {
                        Al = {isEnd: Ak, removeOnClick: true}
                    }
                }
            }
            return Al
        }

        function o(Ai, Ah) {
            if (Ai === "auto") {
                if (true) {
                    i.assert(Ah && Ah.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"')
                }
                return Ah.defaultBrushType
            }
            return Ai
        }

        var T = {
            mousedown: function(Aj) {
                if (this._dragging) {
                    w.call(this, Aj)
                } else {
                    if (!Aj.target || !Aj.target.draggable) {
                        Ag(Aj);
                        var Ai = this.group.transformCoordToLocal(Aj.offsetX, Aj.offsetY);
                        this._creatingCover = null;
                        var Ah = this._creatingPanel = e(this, Aj, Ai);
                        if (Ah) {
                            this._dragging = true;
                            this._track = [Ai.slice()]
                        }
                    }
                }
            }, mousemove: function(Ai) {
                var Ah = this.group.transformCoordToLocal(Ai.offsetX, Ai.offsetY);
                Y(this, Ai, Ah);
                if (this._dragging) {
                    Ag(Ai);
                    var Aj = M(this, Ai, Ah, false);
                    Aj && z(this, Aj)
                }
            }, mouseup: w
        };

        function w(Ai) {
            if (this._dragging) {
                Ag(Ai);
                var Ah = this.group.transformCoordToLocal(Ai.offsetX, Ai.offsetY);
                var Aj = M(this, Ai, Ah, true);
                this._dragging = false;
                this._track = [];
                this._creatingCover = null;
                Aj && z(this, Aj)
            }
        }

        var x = {
            lineX: S(0), lineY: S(1), rect: {
                createCover: function(Ai, Ah) {
                    return E(Q(Ae, function(Aj) {
                        return Aj
                    }, function(Aj) {
                        return Aj
                    }), Ai, Ah, ["w", "e", "n", "s", "se", "sw", "ne", "nw"])
                }, getCreatingRange: function(Ai) {
                    var Ah = O(Ai);
                    return I(Ah[1][0], Ah[1][1], Ah[0][0], Ah[0][1])
                }, updateCoverShape: function(Ak, Aj, Ai, Ah) {
                    m(Ak, Aj, Ai, Ah)
                }, updateCommon: J, contain: j
            }, polygon: {
                createCover: function(Aj, Ah) {
                    var Ai = new y.Group();
                    Ai.add(new y.Polyline({name: "main", style: b(Ah), silent: true}));
                    return Ai
                }, getCreatingRange: function(Ah) {
                    return Ah
                }, endCreating: function(Ai, Ah) {
                    Ah.remove(Ah.childAt(0));
                    Ah.add(new y.Polygon({name: "main", draggable: true, drift: Q(f, Ai, Ah), ondragend: Q(z, Ai, {isEnd: true})}))
                }, updateCoverShape: function(Ak, Aj, Ai, Ah) {
                    Aj.childAt(0).setShape({points: Ad(Ak, Aj, Ai)})
                }, updateCommon: J, contain: j
            }
        };

        function S(Ah) {
            return {
                createCover: function(Aj, Ai) {
                    return E(Q(Ae, function(Al) {
                        var Ak = [Al, [0, 100]];
                        Ah && Ak.reverse();
                        return Ak
                    }, function(Ak) {
                        return Ak[Ah]
                    }), Aj, Ai, [["w", "e"], ["n", "s"]][Ah])
                }, getCreatingRange: function(Ak) {
                    var Aj = O(Ak);
                    var Ai = v(Aj[0][Ah], Aj[1][Ah]);
                    var Al = s(Aj[0][Ah], Aj[1][Ah]);
                    return [Ai, Al]
                }, updateCoverShape: function(Am, Ai, Ap, Ao) {
                    var An;
                    var Al = K(Am, Ai);
                    if (Al !== true && Al.getLinearBrushOtherExtent) {
                        An = Al.getLinearBrushOtherExtent(Ah, Am._transform)
                    } else {
                        var Ak = Am._zr;
                        An = [0, [Ak.getWidth(), Ak.getHeight()][1 - Ah]]
                    }
                    var Aj = [Ap, An];
                    Ah && Aj.reverse();
                    m(Am, Ai, Aj, Ao)
                }, updateCommon: J, contain: j
            }
        }

        Ab.exports = W
    }, function(F, H, A) {
        var D = A(186);
        var C = A(9);
        var G = A(18);
        var E = {};
        E.makeRectPanelClipPath = function(I) {
            I = B(I);
            return function(J, K) {
                return G.clipPointsByRect(J, I)
            }
        };
        E.makeLinearBrushOtherExtent = function(I, J) {
            I = B(I);
            return function(K) {
                var L = J != null ? J : K;
                var M = L ? I.width : I.height;
                var N = L ? I.x : I.y;
                return [N, N + (M || 0)]
            }
        };
        E.makeRectIsTargetByCursor = function(I, K, J) {
            I = B(I);
            return function(M, L, N) {
                return I.contain(L[0], L[1]) && !D.onIrrelevantElement(M, K, J)
            }
        };

        function B(I) {
            return C.create(I)
        }

        F.exports = E
    }, function(E, G, C) {
        var B = C(4);
        var D = C(5);
        E.exports = function(H) {
            A(H);
            F(H)
        };

        function A(H) {
            if (H.parallel) {
                return
            }
            var I = false;
            B.each(H.series, function(J) {
                if (J && J.type === "parallel") {
                    I = true
                }
            });
            if (I) {
                H.parallel = [{}]
            }
        }

        function F(I) {
            var H = D.normalizeToArray(I.parallelAxis);
            B.each(H, function(K) {
                if (!B.isObject(K)) {
                    return
                }
                var J = K.parallelIndex || 0;
                var L = D.normalizeToArray(I.parallel)[J];
                if (L && L.parallelAxisDefault) {
                    B.merge(K, L.parallelAxisDefault, false)
                }
            })
        }
    }, function(H, J, D) {
        var I = D(98);
        var C = D(4);
        var F = D(78);
        var A = D(110);
        H.exports = F.extend({
            type: "series.parallel",
            dependencies: ["parallel"],
            visualColorAccessPath: "lineStyle.normal.color",
            getInitialData: function(R, Q) {
                var N = Q.getComponent("parallel", this.get("parallelIndex"));
                var P = N.parallelAxisIndex;
                var K = R.data;
                var S = N.dimensions;
                var L = G(S, K);
                var O = C.map(L, function(V, T) {
                    var W = C.indexOf(S, V);
                    var U = W >= 0 && Q.getComponent("parallelAxis", P[W]);
                    if (U && U.get("type") === "category") {
                        B(U, V, K);
                        return {name: V, type: "ordinal"}
                    } else {
                        if (W < 0) {
                            return A.guessOrdinal(K, T) ? {name: V, type: "ordinal"} : V
                        } else {
                            return V
                        }
                    }
                });
                var M = new I(O, this);
                M.initData(K);
                if (this.option.progressive) {
                    this.option.animation = false
                }
                return M
            },
            getRawIndicesByActiveState: function(K) {
                var L = this.coordinateSystem;
                var N = this.getData();
                var M = [];
                L.eachActiveState(N, function(P, O) {
                    if (K === P) {
                        M.push(N.getRawIndex(O))
                    }
                });
                return M
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "parallel",
                parallelIndex: 0,
                label: {normal: {show: false}, emphasis: {show: false}},
                inactiveOpacity: 0.05,
                activeOpacity: 1,
                lineStyle: {normal: {width: 1, opacity: 0.45, type: "solid"}},
                progressive: false,
                smooth: false,
                animationEasing: "linear"
            }
        });

        function B(L, N, O) {
            var M = L.get("data");
            var K = E(N);
            if (M && M.length) {
                C.each(O, function(P) {
                    if (!P) {
                        return
                    }
                    var Q = C.indexOf(M, P[K]);
                    P[K] = Q >= 0 ? Q : NaN
                })
            }
        }

        function E(K) {
            return +K.replace("dim", "")
        }

        function G(P, O) {
            var K = 0;
            C.each(P, function(R) {
                var Q = E(R);
                Q > K && (K = Q)
            });
            var N = O[0];
            if (N && N.length - 1 > K) {
                K = N.length - 1
            }
            var L = [];
            for (var M = 0; M <= K; M++) {
                L.push("dim" + M)
            }
            return L
        }
    }, function(K, L, D) {
        var I = D(18);
        var C = D(4);
        var F = 0.3;
        var J = D(80).extend({
            type: "parallel", init: function() {
                this._dataGroup = new I.Group();
                this.group.add(this._dataGroup);
                this._data
            }, render: function(M, N, P, O) {
                this._renderForNormal(M, O)
            }, dispose: function() {
            }, _renderForNormal: function(Y, O) {
                var S = this._dataGroup;
                var P = Y.getData();
                var Q = this._data;
                var W = Y.coordinateSystem;
                var M = W.dimensions;
                var X = Y.option;
                var U = X.smooth ? F : null;
                P.diff(Q).add(R).update(N).remove(T).execute();
                A(P, U);
                if (!this._data) {
                    var V = G(W, Y, function() {
                        setTimeout(function() {
                            S.removeClipPath()
                        })
                    });
                    S.setClipPath(V)
                }
                this._data = P;

                function R(Z) {
                    E(P, S, Z, M, W, null, U)
                }

                function N(c, Z) {
                    var b = Q.getItemGraphicEl(Z);
                    var a = B(P, c, M, W);
                    P.setItemGraphicEl(c, b);
                    var d = (O && O.animation === false) ? null : Y;
                    I.updateProps(b, {shape: {points: a}}, d, c)
                }

                function T(Z) {
                    var a = Q.getItemGraphicEl(Z);
                    S.remove(a)
                }
            }, remove: function() {
                this._dataGroup && this._dataGroup.removeAll();
                this._data = null
            }
        });

        function G(P, N, M) {
            var O = P.model;
            var R = P.getRect();
            var Q = new I.Rect({shape: {x: R.x, y: R.y, width: R.width, height: R.height}});
            var S = O.get("layout") === "horizontal" ? "width" : "height";
            Q.setShape(S, 0);
            I.initProps(Q, {shape: {width: R.width, height: R.height}}, N, M);
            return Q
        }

        function B(O, S, M, N) {
            var T = [];
            for (var R = 0; R < M.length; R++) {
                var P = M[R];
                var Q = O.get(P, S);
                if (!H(Q, N.getAxis(P).type)) {
                    T.push(N.dataToPoint(Q, P))
                }
            }
            return T
        }

        function E(S, M, N, Q, O) {
            var P = B(S, N, Q, O);
            var R = new I.Polyline({shape: {points: P}, silent: true, z2: 10});
            M.add(R);
            S.setItemGraphicEl(N, R)
        }

        function A(P, M) {
            var N = P.hostModel.getModel("lineStyle.normal");
            var O = N.getLineStyle();
            P.eachItemGraphicEl(function(T, Q) {
                if (P.hasItemOption) {
                    var R = P.getItemModel(Q);
                    var S = R.getModel("lineStyle.normal", N);
                    O = S.getLineStyle(["color", "stroke"])
                }
                T.useStyle(C.extend(O, {fill: null, stroke: P.getItemVisual(Q, "color"), opacity: P.getItemVisual(Q, "opacity")}));
                T.shape.smooth = M
            })
        }

        function H(M, N) {
            return N === "category" ? M == null : (M == null || isNaN(M))
        }

        K.exports = J
    }, function(A, C) {
        var B = ["lineStyle", "normal", "opacity"];
        A.exports = function(D) {
            D.eachSeriesByType("parallel", function(O) {
                var J = O.getModel("itemStyle.normal");
                var G = O.getModel("lineStyle.normal");
                var M = D.get("color");
                var I = G.get("color") || J.get("color") || M[O.seriesIndex % M.length];
                var L = O.get("inactiveOpacity");
                var K = O.get("activeOpacity");
                var N = O.getModel("lineStyle.normal").getLineStyle();
                var F = O.coordinateSystem;
                var H = O.getData();
                var E = {normal: N.opacity, active: K, inactive: L};
                F.eachActiveState(H, function(P, Q) {
                    var R = H.getItemModel(Q);
                    var S = E[P];
                    if (P === "normal") {
                        var T = R.get(B, true);
                        T != null && (S = T)
                    }
                    H.setItemVisual(Q, "opacity", S)
                });
                H.setVisual("color", I)
            })
        }
    }, function(B, D, A) {
        var C = A(1);
        A(252);
        A(253);
        C.registerLayout(A(254));
        C.registerVisual(A(256))
    }, function(D, F, C) {
        var E = C(78);
        var B = C(207);
        var A = C(6).encodeHTML;
        var G = E.extend({
            type: "series.sankey",
            layoutInfo: null,
            getInitialData: function(H) {
                var K = H.edges || H.links;
                var J = H.data || H.nodes;
                if (J && K) {
                    var I = B(J, K, this, true);
                    return I.data
                }
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            formatTooltip: function(I, J, L) {
                if (L === "edge") {
                    var M = this.getDataParams(I, L);
                    var K = M.data;
                    var H = K.source + " -- " + K.target;
                    if (M.value) {
                        H += " : " + M.value
                    }
                    return A(H)
                }
                return G.superCall(this, "formatTooltip", I, J)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                layout: null,
                left: "5%",
                top: "5%",
                right: "20%",
                bottom: "5%",
                nodeWidth: 20,
                nodeGap: 8,
                layoutIterations: 32,
                label: {normal: {show: true, position: "right", textStyle: {color: "#000", fontSize: 12}}, emphasis: {show: true}},
                itemStyle: {normal: {borderWidth: 1, borderColor: "#333"}},
                lineStyle: {normal: {color: "#314656", opacity: 0.2, curveness: 0.5}, emphasis: {opacity: 0.6}},
                animationEasing: "linear",
                animationDuration: 1000
            }
        });
        D.exports = G
    }, function(D, G, C) {
        var A = C(18);
        var B = C(4);
        var F = A.extendShape({
            shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, cpx2: 0, cpy2: 0, extent: 0}, buildPath: function(I, J) {
                var H = J.extent / 2;
                I.moveTo(J.x1, J.y1 - H);
                I.bezierCurveTo(J.cpx1, J.cpy1 - H, J.cpx2, J.cpy2 - H, J.x2, J.y2 - H);
                I.lineTo(J.x2, J.y2 + H);
                I.bezierCurveTo(J.cpx2, J.cpy2 + H, J.cpx1, J.cpy1 + H, J.x1, J.y1 + H);
                I.closePath()
            }
        });
        D.exports = C(1).extendChartView({
            type: "sankey", _model: null, render: function(O, H, N) {
                var I = O.getGraph();
                var L = this.group;
                var K = O.layoutInfo;
                var J = O.getData();
                var M = O.getData("edge");
                this._model = O;
                L.removeAll();
                L.position = [K.x, K.y];
                I.eachEdge(function(Z) {
                    var P = new F();
                    P.dataIndex = Z.dataIndex;
                    P.seriesIndex = O.seriesIndex;
                    P.dataType = "edge";
                    var S = Z.getModel("lineStyle.normal");
                    var b = S.get("curveness");
                    var d = Z.node1.getLayout();
                    var Y = Z.node2.getLayout();
                    var c = Z.getLayout();
                    P.shape.extent = Math.max(1, c.dy);
                    var R = d.x + d.dx;
                    var T = d.y + c.sy + c.dy / 2;
                    var U = Y.x;
                    var V = Y.y + c.ty + c.dy / 2;
                    var X = R * (1 - b) + U * b;
                    var a = T;
                    var W = R * b + U * (1 - b);
                    var Q = V;
                    P.setShape({x1: R, y1: T, x2: U, y2: V, cpx1: X, cpy1: a, cpx2: W, cpy2: Q});
                    P.setStyle(S.getItemStyle());
                    switch (P.style.fill) {
                        case"source":
                            P.style.fill = Z.node1.getVisual("color");
                            break;
                        case"target":
                            P.style.fill = Z.node2.getVisual("color");
                            break
                    }
                    A.setHoverStyle(P, Z.getModel("lineStyle.emphasis").getItemStyle());
                    L.add(P);
                    M.setItemGraphicEl(Z.dataIndex, P)
                });
                I.eachNode(function(V) {
                    var U = V.getLayout();
                    var Q = V.getModel();
                    var T = Q.getModel("label.normal");
                    var W = T.getModel("textStyle");
                    var P = Q.getModel("label.emphasis");
                    var S = P.getModel("textStyle");
                    var R = new A.Rect({
                        shape: {x: U.x, y: U.y, width: V.getLayout().dx, height: V.getLayout().dy},
                        style: {
                            text: T.get("show") ? O.getFormattedLabel(V.dataIndex, "normal") || V.id : "",
                            textFont: W.getFont(),
                            textFill: W.getTextColor(),
                            textPosition: T.get("position")
                        }
                    });
                    R.setStyle(B.defaults({fill: V.getVisual("color")}, Q.getModel("itemStyle.normal").getItemStyle()));
                    A.setHoverStyle(R, B.extend(V.getModel("itemStyle.emphasis"), {
                        text: P.get("show") ? O.getFormattedLabel(V.dataIndex, "emphasis") || V.id : "",
                        textFont: S.getFont(),
                        textFill: S.getTextColor(),
                        textPosition: P.get("position")
                    }));
                    L.add(R);
                    J.setItemGraphicEl(V.dataIndex, R);
                    R.dataType = "node"
                });
                if (!this._data && O.get("animation")) {
                    L.setClipPath(E(L.getBoundingRect(), O, function() {
                        L.removeClipPath()
                    }))
                }
                this._data = O.getData()
            }, dispose: function() {
            }
        });

        function E(J, I, H) {
            var K = new A.Rect({shape: {x: J.x - 10, y: J.y - 10, width: 0, height: J.height + 20}});
            A.initProps(K, {shape: {width: J.width + 20, height: J.height + 20}}, I, H);
            return K
        }
    }, function(T, J, V) {
        var N = V(71);
        var C = V(255);
        var I = V(4);
        T.exports = function(b, d, c) {
            b.eachSeriesByType("sankey", function(o) {
                var i = o.get("nodeWidth");
                var l = o.get("nodeGap");
                var k = P(o, d);
                o.layoutInfo = k;
                var m = k.width;
                var f = k.height;
                var g = o.getGraph();
                var n = g.nodes;
                var e = g.edges;
                A(n);
                var j = I.filter(n, function(p) {
                    return p.getLayout().value === 0
                });
                var h = j.length !== 0 ? 0 : o.get("layoutIterations");
                a(n, e, i, l, m, f, h)
            })
        };

        function P(b, c) {
            return N.getLayoutRect(b.getBoxLayoutParams(), {width: c.getWidth(), height: c.getHeight()})
        }

        function a(e, c, g, h, f, b, d) {
            O(e, g, f);
            X(e, c, b, h, d);
            E(e)
        }

        function A(b) {
            I.each(b, function(d) {
                var e = M(d.outEdges, S);
                var f = M(d.inEdges, S);
                var c = Math.max(e, f);
                d.setLayout({value: c}, true)
            })
        }

        function O(o, f, m) {
            var e = o;
            var d = null;
            var n = 0;
            var b = 0;
            while (e.length) {
                d = [];
                for (var k = 0, c = e.length; k < c; k++) {
                    var l = e[k];
                    l.setLayout({x: n}, true);
                    l.setLayout({dx: f}, true);
                    for (var g = 0, h = l.outEdges.length; g < h; g++) {
                        d.push(l.outEdges[g].node2)
                    }
                }
                e = d;
                ++n
            }
            U(o, n);
            b = (m - f) / (n - 1);
            F(o, b)
        }

        function U(b, c) {
            I.each(b, function(d) {
                if (!d.outEdges.length) {
                    d.setLayout({x: c - 1}, true)
                }
            })
        }

        function F(c, b) {
            I.each(c, function(e) {
                var d = e.getLayout().x * b;
                e.setLayout({x: d}, true)
            })
        }

        function X(e, d, c, h, g) {
            var b = C().key(function(i) {
                return i.getLayout().x
            }).sortKeys(G).entries(e).map(function(i) {
                return i.values
            });
            R(e, b, d, c, h);
            B(b, h, c);
            for (var f = 1; g > 0; g--) {
                f *= 0.99;
                L(b, f);
                B(b, h, c);
                W(b, f);
                B(b, h, c)
            }
        }

        function R(e, g, d, c, h) {
            var f = [];
            I.each(g, function(k) {
                var i = k.length;
                var l = 0;
                I.each(k, function(m) {
                    l += m.getLayout().value
                });
                var j = (c - (i - 1) * h) / l;
                f.push(j)
            });
            f.sort(function(j, i) {
                return j - i
            });
            var b = f[0];
            I.each(g, function(i) {
                I.each(i, function(l, j) {
                    l.setLayout({y: j}, true);
                    var k = l.getLayout().value * b;
                    l.setLayout({dy: k}, true)
                })
            });
            I.each(d, function(i) {
                var j = +i.getValue() * b;
                i.setLayout({dy: j}, true)
            })
        }

        function B(d, c, b) {
            I.each(d, function(j) {
                var h;
                var f;
                var k = 0;
                var g = j.length;
                var e;
                j.sort(Y);
                for (e = 0; e < g; e++) {
                    h = j[e];
                    f = k - h.getLayout().y;
                    if (f > 0) {
                        var l = h.getLayout().y + f;
                        h.setLayout({y: l}, true)
                    }
                    k = h.getLayout().y + h.getLayout().dy + c
                }
                f = k - c - b;
                if (f > 0) {
                    var l = h.getLayout().y - f;
                    h.setLayout({y: l}, true);
                    k = h.getLayout().y;
                    for (e = g - 2; e >= 0; --e) {
                        h = j[e];
                        f = h.getLayout().y + h.getLayout().dy + c - k;
                        if (f > 0) {
                            l = h.getLayout().y - f;
                            h.setLayout({y: l}, true)
                        }
                        k = h.getLayout().y
                    }
                }
            })
        }

        function L(c, b) {
            I.each(c.slice().reverse(), function(d) {
                I.each(d, function(f) {
                    if (f.outEdges.length) {
                        var g = M(f.outEdges, H) / M(f.outEdges, S);
                        var e = f.getLayout().y + (g - Z(f)) * b;
                        f.setLayout({y: e}, true)
                    }
                })
            })
        }

        function H(b) {
            return Z(b.node2) * b.getValue()
        }

        function W(c, b) {
            I.each(c, function(d) {
                I.each(d, function(f) {
                    if (f.inEdges.length) {
                        var g = M(f.inEdges, D) / M(f.inEdges, S);
                        var e = f.getLayout().y + (g - Z(f)) * b;
                        f.setLayout({y: e}, true)
                    }
                })
            })
        }

        function D(b) {
            return Z(b.node1) * b.getValue()
        }

        function E(b) {
            I.each(b, function(c) {
                c.outEdges.sort(K);
                c.inEdges.sort(Q)
            });
            I.each(b, function(d) {
                var e = 0;
                var c = 0;
                I.each(d.outEdges, function(f) {
                    f.setLayout({sy: e}, true);
                    e += f.getLayout().dy
                });
                I.each(d.inEdges, function(f) {
                    f.setLayout({ty: c}, true);
                    c += f.getLayout().dy
                })
            })
        }

        function K(d, c) {
            return d.node2.getLayout().y - c.node2.getLayout().y
        }

        function Q(d, c) {
            return d.node1.getLayout().y - c.node1.getLayout().y
        }

        function M(b, h) {
            var g = 0;
            var d = b.length;
            var c = -1;
            while (++c < d) {
                var e = +h.call(b, b[c], c);
                if (!isNaN(e)) {
                    g += e
                }
            }
            return g
        }

        function Z(b) {
            return b.getLayout().y + b.getLayout().dy / 2
        }

        function Y(d, c) {
            return d.getLayout().y - c.getLayout().y
        }

        function G(d, c) {
            return d < c ? -1 : d > c ? 1 : d === c ? 0 : NaN
        }

        function S(b) {
            return b.getValue()
        }
    }, function(C, D, B) {
        var A = B(4);

        function E() {
            var G = [];
            var I = [];

            function F(J, N) {
                if (N >= G.length) {
                    return J
                }
                var L = -1;
                var M = J.length;
                var R = G[N++];
                var K = {};
                var P = {};
                while (++L < M) {
                    var Q = R(J[L]);
                    var O = P[Q];
                    if (O) {
                        O.push(J[L])
                    } else {
                        P[Q] = [J[L]]
                    }
                }
                A.each(P, function(T, S) {
                    K[S] = F(T, N)
                });
                return K
            }

            function H(L, K) {
                if (K >= G.length) {
                    return L
                }
                var J = [];
                var M = I[K++];
                A.each(L, function(O, N) {
                    J.push({key: N, values: H(O, K)})
                });
                if (M) {
                    return J.sort(function(O, N) {
                        return M(O.key, N.key)
                    })
                } else {
                    return J
                }
            }

            return {
                key: function(J) {
                    G.push(J);
                    return this
                }, sortKeys: function(J) {
                    I[G.length - 1] = J;
                    return this
                }, entries: function(J) {
                    return H(F(J, 0), 0)
                }
            }
        }

        C.exports = E
    }, function(D, E, C) {
        var B = C(203);
        var A = C(4);
        D.exports = function(F, G) {
            F.eachSeriesByType("sankey", function(H) {
                var I = H.getGraph();
                var J = I.nodes;
                J.sort(function(N, M) {
                    return N.getLayout().value - M.getLayout().value
                });
                var L = J[0].getLayout().value;
                var K = J[J.length - 1].getLayout().value;
                A.each(J, function(N) {
                    var O = new B({type: "color", mappingMethod: "linear", dataExtent: [L, K], visual: H.get("color")});
                    var P = O.mapValueToVisual(N.getLayout().value);
                    N.setVisual("color", P);
                    var M = N.getModel();
                    var Q = M.get("itemStyle.normal.color");
                    if (Q != null) {
                        N.setVisual("color", Q)
                    }
                })
            })
        }
    }, function(B, D, A) {
        var C = A(1);
        A(258);
        A(261);
        C.registerVisual(A(262));
        C.registerLayout(A(263))
    }, function(E, G, D) {
        var B = D(4);
        var F = D(78);
        var C = D(259);
        var A = F.extend({
            type: "series.boxplot",
            dependencies: ["xAxis", "yAxis", "grid"],
            defaultValueDimensions: ["min", "Q1", "median", "Q3", "max"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: true,
                hoverAnimation: true,
                layout: null,
                boxWidth: [7, 50],
                itemStyle: {
                    normal: {color: "#fff", borderWidth: 1},
                    emphasis: {borderWidth: 2, shadowBlur: 5, shadowOffsetX: 2, shadowOffsetY: 2, shadowColor: "rgba(0,0,0,0.4)"}
                },
                animationEasing: "elasticOut",
                animationDuration: 800
            }
        });
        B.mixin(A, C.seriesModelMixin, true);
        E.exports = A
    }, function(G, I, C) {
        var H = C(98);
        var A = C(110);
        var D = C(260);
        var B = C(4);
        var F = {
            _baseAxisDim: null, getInitialData: function(V, U) {
                var L;
                var P = U.getComponent("xAxis", this.get("xAxisIndex"));
                var W = U.getComponent("yAxis", this.get("yAxisIndex"));
                var S = P.get("type");
                var K = W.get("type");
                var Q;
                if (S === "category") {
                    V.layout = "horizontal";
                    L = P.getCategories();
                    Q = true
                } else {
                    if (K === "category") {
                        V.layout = "vertical";
                        L = W.getCategories();
                        Q = true
                    } else {
                        V.layout = V.layout || "horizontal"
                    }
                }
                var J = ["x", "y"];
                var M = V.layout === "horizontal" ? 0 : 1;
                var R = this._baseAxisDim = J[M];
                var T = J[1 - M];
                var O = V.data;
                Q && B.each(O, function(Y, Z) {
                    B.isArray(Y) && Y.unshift(Z)
                });
                var X = [{name: R, otherDims: {tooltip: false}, dimsDef: ["base"]}, {name: T, dimsDef: this.defaultValueDimensions.slice()}];
                X = A(X, O, {encodeDef: this.get("encode"), dimsDef: this.get("dimensions")});
                var N = new H(X, this);
                N.initData(O, L ? L.slice() : null);
                return N
            }, getBaseAxis: function() {
                var J = this._baseAxisDim;
                return this.ecModel.getComponent(J + "Axis", this.get(J + "AxisIndex")).axis
            }
        };
        var E = {
            init: function() {
                var J = this._whiskerBoxDraw = new D(this.getStyleUpdater());
                this.group.add(J.group)
            }, render: function(J, K, L) {
                this._whiskerBoxDraw.updateData(J.getData())
            }, remove: function(J) {
                this._whiskerBoxDraw.remove()
            }
        };
        G.exports = {seriesModelMixin: F, viewMixin: E}
    }, function(K, M, D) {
        var C = D(4);
        var F = D(18);
        var E = D(20);
        var L = E.extend({
            type: "whiskerInBox", shape: {}, buildPath: function(P, Q) {
                for (var N in Q) {
                    if (Q.hasOwnProperty(N) && N.indexOf("ends") === 0) {
                        var O = Q[N];
                        P.moveTo(O[0][0], O[0][1]);
                        P.lineTo(O[1][0], O[1][1])
                    }
                }
            }
        });

        function H(Q, O, N, P) {
            F.Group.call(this);
            this.bodyIndex;
            this.whiskerIndex;
            this.styleUpdater = N;
            this._createContent(Q, O, P);
            this.updateData(Q, O, P);
            this._seriesModel
        }

        var A = H.prototype;
        A._createContent = function(T, R, S) {
            var P = T.getItemLayout(R);
            var O = P.chartLayout === "horizontal" ? 1 : 0;
            var N = 0;
            this.add(new F.Polygon({shape: {points: S ? G(P.bodyEnds, O, P) : P.bodyEnds}, style: {strokeNoScale: true}, z2: 100}));
            this.bodyIndex = N++;
            var Q = C.map(P.whiskerEnds, function(U) {
                return S ? G(U, O, P) : U
            });
            this.add(new L({shape: B(Q), style: {strokeNoScale: true}, z2: 100}));
            this.whiskerIndex = N++
        };

        function G(N, O, P) {
            return C.map(N, function(Q) {
                Q = Q.slice();
                Q[O] = P.initBaseline;
                return Q
            })
        }

        function B(N) {
            var O = {};
            C.each(N, function(Q, P) {
                O["ends" + P] = Q
            });
            return O
        }

        A.updateData = function(S, Q, R) {
            var N = this._seriesModel = S.hostModel;
            var O = S.getItemLayout(Q);
            var P = F[R ? "initProps" : "updateProps"];
            P(this.childAt(this.bodyIndex), {shape: {points: O.bodyEnds}}, N, Q);
            P(this.childAt(this.whiskerIndex), {shape: B(O.whiskerEnds)}, N, Q);
            this.styleUpdater.call(null, this, S, Q)
        };
        C.inherits(H, F.Group);

        function J(N) {
            this.group = new F.Group();
            this.styleUpdater = N
        }

        var I = J.prototype;
        I.updateData = function(Q) {
            var O = this.group;
            var P = this._data;
            var N = this.styleUpdater;
            Q.diff(P).add(function(R) {
                if (Q.hasValue(R)) {
                    var S = new H(Q, R, N, true);
                    Q.setItemGraphicEl(R, S);
                    O.add(S)
                }
            }).update(function(R, T) {
                var S = P.getItemGraphicEl(T);
                if (!Q.hasValue(R)) {
                    O.remove(S);
                    return
                }
                if (!S) {
                    S = new H(Q, R, N)
                } else {
                    S.updateData(Q, R)
                }
                O.add(S);
                Q.setItemGraphicEl(R, S)
            }).remove(function(S) {
                var R = P.getItemGraphicEl(S);
                R && O.remove(R)
            }).execute();
            this._data = Q
        };
        I.remove = function() {
            var N = this.group;
            var O = this._data;
            this._data = null;
            O && O.eachItemGraphicEl(function(P) {
                P && N.remove(P)
            })
        };
        K.exports = J
    }, function(J, K, D) {
        var C = D(4);
        var I = D(80);
        var G = D(18);
        var A = D(259);
        var B = I.extend({
            type: "boxplot", getStyleUpdater: function() {
                return F
            }, dispose: C.noop
        });
        C.mixin(B, A.viewMixin, true);
        var E = ["itemStyle", "normal"];
        var H = ["itemStyle", "emphasis"];

        function F(Q, M, P) {
            var L = M.getItemModel(P);
            var R = L.getModel(E);
            var T = M.getItemVisual(P, "color");
            var O = R.getItemStyle(["borderColor"]);
            var S = Q.childAt(Q.whiskerIndex);
            S.style.set(O);
            S.style.stroke = T;
            S.dirty();
            var N = Q.childAt(Q.bodyIndex);
            N.style.set(O);
            N.style.stroke = T;
            N.dirty();
            var U = L.getModel(H).getItemStyle();
            G.setHoverStyle(Q, U)
        }

        J.exports = B
    }, function(B, C) {
        var A = ["itemStyle", "normal", "borderColor"];
        B.exports = function(E, F) {
            var D = E.get("color");
            E.eachRawSeriesByType("boxplot", function(G) {
                var I = D[G.seriesIndex % D.length];
                var H = G.getData();
                H.setVisual({legendSymbol: "roundRect", color: G.get(A) || I});
                if (!E.isSeriesFiltered(G)) {
                    H.each(function(K) {
                        var J = H.getItemModel(K);
                        H.setItemVisual(K, {color: J.get(A, true)})
                    })
                }
            })
        }
    }, function(I, J, E) {
        var D = E(4);
        var G = E(7);
        var H = G.parsePercent;
        var A = D.each;
        I.exports = function(K) {
            var L = B(K);
            A(L, function(M) {
                var N = M.seriesModels;
                if (!N.length) {
                    return
                }
                C(M);
                A(N, function(O, P) {
                    F(O, M.boxOffsetList[P], M.boxWidthList[P])
                })
            })
        };

        function B(K) {
            var L = [];
            var M = [];
            K.eachSeriesByType("boxplot", function(N) {
                var P = N.getBaseAxis();
                var O = D.indexOf(M, P);
                if (O < 0) {
                    O = M.length;
                    M[O] = P;
                    L[O] = {axis: P, seriesModels: []}
                }
                L[O].seriesModels.push(N)
            });
            return L
        }

        function C(K) {
            var Q;
            var W = K.axis;
            var R = K.seriesModels;
            var L = R.length;
            var X = K.boxWidthList = [];
            var V = K.boxOffsetList = [];
            var O = [];
            var T;
            if (W.type === "category") {
                T = W.getBandWidth()
            } else {
                var U = 0;
                A(R, function(Y) {
                    U = Math.max(U, Y.getData().count())
                });
                Q = W.getExtent(), Math.abs(Q[1] - Q[0]) / U
            }
            A(R, function(Y) {
                var Z = Y.get("boxWidth");
                if (!D.isArray(Z)) {
                    Z = [Z, Z]
                }
                O.push([H(Z[0], T) || 0, H(Z[1], T) || 0])
            });
            var P = T * 0.8 - 2;
            var N = P / L * 0.3;
            var S = (P - N * (L - 1)) / L;
            var M = S / 2 - P / 2;
            A(R, function(Y, Z) {
                V.push(M);
                M += N + S;
                X.push(Math.min(Math.max(S, O[Z][0]), O[Z][1]))
            })
        }

        function F(V, L, K) {
            var T = V.coordinateSystem;
            var N = V.getData();
            var P = K / 2;
            var O = V.get("layout");
            var U = O === "horizontal" ? 0 : 1;
            var S = 1 - U;
            var Q = ["x", "y"];
            var M = [];
            var R;
            D.each(N.dimensions, function(W) {
                var Y = N.getDimensionInfo(W);
                var X = Y.coordDim;
                if (X === Q[S]) {
                    M.push(W)
                } else {
                    if (X === Q[U]) {
                        R = W
                    }
                }
            });
            if (R == null || M.length < 5) {
                return
            }
            N.each([R].concat(M), function() {
                var X = arguments;
                var g = X[0];
                var b = X[M.length + 1];
                var Y = c(X[3]);
                var W = c(X[1]);
                var a = c(X[5]);
                var d = [[W, c(X[2])], [a, c(X[4])]];
                Z(W);
                Z(a);
                Z(Y);
                var e = [];
                f(d[0][1], 0);
                f(d[1][1], 1);
                N.setItemLayout(b, {chartLayout: O, initBaseline: Y[S], median: Y, bodyEnds: e, whiskerEnds: d});

                function c(j) {
                    var i = [];
                    i[U] = g;
                    i[S] = j;
                    var h;
                    if (isNaN(g) || isNaN(j)) {
                        h = [NaN, NaN]
                    } else {
                        h = T.dataToPoint(i);
                        h[U] += L
                    }
                    return h
                }

                function f(h, j) {
                    var i = h.slice();
                    var k = h.slice();
                    i[U] += P;
                    k[U] -= P;
                    j ? e.push(i, k) : e.push(k, i)
                }

                function Z(h) {
                    var i = [h.slice(), h.slice()];
                    i[0][U] -= P;
                    i[1][U] += P;
                    d.push(i)
                }
            })
        }
    }, function(B, D, A) {
        var C = A(1);
        A(265);
        A(266);
        C.registerPreprocessor(A(267));
        C.registerVisual(A(268));
        C.registerLayout(A(269))
    }, function(E, G, C) {
        var A = C(4);
        var F = C(78);
        var B = C(259);
        var D = F.extend({
            type: "series.candlestick",
            dependencies: ["xAxis", "yAxis", "grid"],
            defaultValueDimensions: ["open", "close", "lowest", "highest"],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: true,
                hoverAnimation: true,
                layout: null,
                itemStyle: {
                    normal: {color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656"},
                    emphasis: {borderWidth: 2}
                },
                barMaxWidth: null,
                barMinWidth: null,
                barWidth: null,
                animationUpdate: false,
                animationEasing: "linear",
                animationDuration: 300
            },
            getShadowDim: function() {
                return "open"
            },
            brushSelector: function(H, K, I) {
                var J = K.getItemLayout(H);
                return I.rect(J.brushRect)
            }
        });
        A.mixin(D, B.seriesModelMixin, true);
        E.exports = D
    }, function(I, K, C) {
        var B = C(4);
        var H = C(80);
        var F = C(18);
        var A = C(259);
        var J = H.extend({
            type: "candlestick", getStyleUpdater: function() {
                return E
            }, dispose: B.noop
        });
        B.mixin(J, A.viewMixin, true);
        var D = ["itemStyle", "normal"];
        var G = ["itemStyle", "emphasis"];

        function E(Q, M, P) {
            var L = M.getItemModel(P);
            var R = L.getModel(D);
            var O = M.getItemVisual(P, "color");
            var U = M.getItemVisual(P, "borderColor") || O;
            var S = R.getItemStyle(["color", "color0", "borderColor", "borderColor0"]);
            var T = Q.childAt(Q.whiskerIndex);
            T.useStyle(S);
            T.style.stroke = U;
            var N = Q.childAt(Q.bodyIndex);
            N.useStyle(S);
            N.style.fill = O;
            N.style.stroke = U;
            var V = L.getModel(G).getItemStyle();
            F.setHoverStyle(Q, V)
        }

        I.exports = J
    }, function(C, D, B) {
        var A = B(4);
        C.exports = function(E) {
            if (!E || !A.isArray(E.series)) {
                return
            }
            A.each(E.series, function(F) {
                if (A.isObject(F) && F.type === "k") {
                    F.type = "candlestick"
                }
            })
        }
    }, function(D, F) {
        var C = ["itemStyle", "normal", "borderColor"];
        var B = ["itemStyle", "normal", "borderColor0"];
        var A = ["itemStyle", "normal", "color"];
        var E = ["itemStyle", "normal", "color0"];
        D.exports = function(G, H) {
            G.eachRawSeriesByType("candlestick", function(I) {
                var J = I.getData();
                J.setVisual({legendSymbol: "roundRect"});
                if (!G.isSeriesFiltered(I)) {
                    J.each(function(M) {
                        var L = J.getItemModel(M);
                        var K = J.getItemLayout(M).sign;
                        J.setItemVisual(M, {color: L.get(K > 0 ? A : E), borderColor: L.get(K > 0 ? C : B)})
                    })
                }
            })
        }
    }, function(D, G, C) {
        var B = C(4);
        var E = C(4).retrieve;
        var F = C(7).parsePercent;
        D.exports = function(H) {
            H.eachSeriesByType("candlestick", function(R) {
                var J = R.coordinateSystem;
                var L = R.getData();
                var P = A(R, L);
                var M = R.get("layout");
                var Q = M === "horizontal" ? 0 : 1;
                var O = 1 - Q;
                var I = ["x", "y"];
                var K = [];
                var N;
                B.each(L.dimensions, function(S) {
                    var U = L.getDimensionInfo(S);
                    var T = U.coordDim;
                    if (T === I[O]) {
                        K.push(S)
                    } else {
                        if (T === I[Q]) {
                            N = S
                        }
                    }
                });
                if (N == null || K.length < 4) {
                    return
                }
                L.each([N].concat(K), function() {
                    var S = arguments;
                    var Y = S[0];
                    var V = S[K.length + 1];
                    var T = S[1];
                    var f = S[2];
                    var X = S[3];
                    var W = S[4];
                    var b = Math.min(T, f);
                    var a = Math.max(T, f);
                    var e = U(b);
                    var i = U(a);
                    var c = U(X);
                    var g = U(W);
                    var Z = [[g, i], [c, e]];
                    var j = [];
                    h(i, 0);
                    h(e, 1);
                    L.setItemLayout(V, {
                        chartLayout: M,
                        sign: T > f ? -1 : T < f ? 1 : 0,
                        initBaseline: T > f ? i[O] : e[O],
                        bodyEnds: j,
                        whiskerEnds: Z,
                        brushRect: d()
                    });

                    function U(l) {
                        var k = [];
                        k[Q] = Y;
                        k[O] = l;
                        return (isNaN(Y) || isNaN(l)) ? [NaN, NaN] : J.dataToPoint(k)
                    }

                    function h(k, m) {
                        var l = k.slice();
                        var n = k.slice();
                        l[Q] += P / 2;
                        n[Q] -= P / 2;
                        m ? j.push(l, n) : j.push(n, l)
                    }

                    function d() {
                        var k = U(Math.min(T, f, X, W));
                        var l = U(Math.max(T, f, X, W));
                        k[Q] -= P / 2;
                        l[Q] -= P / 2;
                        return {x: k[0], y: k[1], width: O ? P : l[0] - k[0], height: O ? l[1] - k[1] : P}
                    }
                }, true)
            })
        };

        function A(O, I) {
            var N = O.getBaseAxis();
            var K;
            var H = N.type === "category" ? N.getBandWidth() : (K = N.getExtent(), Math.abs(K[1] - K[0]) / I.count());
            var M = F(E(O.get("barMaxWidth"), H), H);
            var L = F(E(O.get("barMinWidth"), 1), H);
            var J = O.get("barWidth");
            return J != null ? F(J, H) : Math.max(Math.min(H / 2, M), L)
        }
    }, function(C, E, B) {
        var A = B(4);
        var D = B(1);
        B(271);
        B(272);
        D.registerVisual(A.curry(B(121), "effectScatter", "circle", null));
        D.registerLayout(A.curry(B(122), "effectScatter"))
    }, function(C, E, A) {
        var B = A(109);
        var D = A(78);
        C.exports = D.extend({
            type: "series.effectScatter",
            dependencies: ["grid", "polar"],
            getInitialData: function(F, G) {
                var H = B(F.data, this, G);
                return H
            },
            brushSelector: "point",
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: true,
                effectType: "ripple",
                progressive: 0,
                showEffectOn: "render",
                rippleEffect: {period: 4, scale: 2.5, brushType: "fill"},
                symbolSize: 10
            }
        })
    }, function(D, E, B) {
        var A = B(116);
        var C = B(273);
        B(1).extendChartView({
            type: "effectScatter", init: function() {
                this._symbolDraw = new A(C)
            }, render: function(G, H, I) {
                var J = G.getData();
                var F = this._symbolDraw;
                F.updateData(J);
                this.group.add(F.group)
            }, updateLayout: function() {
                this._symbolDraw.updateLayout()
            }, remove: function(F, G) {
                this._symbolDraw && this._symbolDraw.remove(G)
            }, dispose: function() {
            }
        })
    }, function(L, N, F) {
        var E = F(4);
        var K = F(111);
        var I = F(18);
        var G = F(7);
        var H = F(117);
        var J = I.Group;
        var D = 3;

        function C(O) {
            if (!E.isArray(O)) {
                O = [+O, +O]
            }
            return O
        }

        function A(O, P) {
            O.eachChild(function(Q) {
                Q.attr({
                    z: P.z,
                    zlevel: P.zlevel,
                    style: {stroke: P.brushType === "stroke" ? P.color : null, fill: P.brushType === "fill" ? P.color : null}
                })
            })
        }

        function B(R, Q) {
            J.call(this);
            var P = new H(R, Q);
            var O = new J();
            this.add(P);
            this.add(O);
            O.beforeUpdate = function() {
                this.attr(P.getScale())
            };
            this.updateData(R, Q)
        }

        var M = B.prototype;
        M.stopEffectAnimation = function() {
            this.childAt(1).removeAll()
        };
        M.startEffectAnimation = function(S) {
            var P = S.symbolType;
            var U = S.color;
            var O = this.childAt(1);
            for (var Q = 0; Q < D; Q++) {
                var T = K.createSymbol(P, -1, -1, 2, 2, U);
                T.attr({style: {strokeNoScale: true}, z2: 99, silent: true, scale: [0.5, 0.5]});
                var R = -Q / D * S.period + S.effectOffset;
                T.animate("", true).when(S.period, {scale: [S.rippleScale / 2, S.rippleScale / 2]}).delay(R).start();
                T.animateStyle(true).when(S.period, {opacity: 0}).delay(R).start();
                O.add(T)
            }
            A(O, S)
        };
        M.updateEffectAnimation = function(S) {
            var T = this._effectCfg;
            var O = this.childAt(1);
            var P = ["symbolType", "period", "rippleScale"];
            for (var Q = 0; Q < P; Q++) {
                var R = P[Q];
                if (T[R] !== S[R]) {
                    this.stopEffectAnimation();
                    this.startEffectAnimation(S);
                    return
                }
            }
            A(O, S)
        };
        M.highlight = function() {
            this.trigger("emphasis")
        };
        M.downplay = function() {
            this.trigger("normal")
        };
        M.updateData = function(R, T) {
            var b = R.hostModel;
            this.childAt(0).updateData(R, T);
            var X = this.childAt(1);
            var P = R.getItemModel(T);
            var U = R.getItemVisual(T, "symbol");
            var O = C(R.getItemVisual(T, "symbolSize"));
            var S = R.getItemVisual(T, "color");
            X.attr("scale", O);
            X.traverse(function(c) {
                c.attr({fill: S})
            });
            var a = P.getShallow("symbolOffset");
            if (a) {
                var W = X.position;
                W[0] = G.parsePercent(a[0], O[0]);
                W[1] = G.parsePercent(a[1], O[1])
            }
            X.rotation = (P.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
            var Z = {};
            Z.showEffectOn = b.get("showEffectOn");
            Z.rippleScale = P.get("rippleEffect.scale");
            Z.brushType = P.get("rippleEffect.brushType");
            Z.period = P.get("rippleEffect.period") * 1000;
            Z.effectOffset = T / R.count();
            Z.z = P.getShallow("z") || 0;
            Z.zlevel = P.getShallow("zlevel") || 0;
            Z.symbolType = U;
            Z.color = S;
            this.off("mouseover").off("mouseout").off("emphasis").off("normal");
            if (Z.showEffectOn === "render") {
                this._effectCfg ? this.updateEffectAnimation(Z) : this.startEffectAnimation(Z);
                this._effectCfg = Z
            } else {
                this._effectCfg = null;
                this.stopEffectAnimation();
                var V = this.childAt(0);
                var Y = function() {
                    V.trigger("emphasis");
                    if (Z.showEffectOn !== "render") {
                        this.startEffectAnimation(Z)
                    }
                };
                var Q = function() {
                    V.trigger("normal");
                    if (Z.showEffectOn !== "render") {
                        this.stopEffectAnimation()
                    }
                };
                this.on("mouseover", Y, this).on("mouseout", Q, this).on("emphasis", Y, this).on("normal", Q, this)
            }
            this._effectCfg = Z
        };
        M.fadeOut = function(O) {
            this.off("mouseover").off("mouseout").off("emphasis").off("normal");
            O && O()
        };
        E.inherits(B, J);
        L.exports = B
    }, function(B, D, A) {
        A(275);
        A(276);
        var C = A(1);
        C.registerLayout(A(281));
        C.registerVisual(A(282))
    }, function(H, J, D) {
        var F = D(78);
        var I = D(98);
        var B = D(4);
        var C = D(6);
        var G = D(76);

        function A(K) {
            var L = K.data;
            if (L && L[0] && L[0][0] && L[0][0].coord) {
                if (true) {
                    console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }")
                }
                K.data = B.map(L, function(N) {
                    var M = [N[0].coord, N[1].coord];
                    var O = {coords: M};
                    if (N[0].name) {
                        O.fromName = N[0].name
                    }
                    if (N[1].name) {
                        O.toName = N[1].name
                    }
                    return B.mergeAll([O, N[0], N[1]])
                })
            }
        }

        var E = F.extend({
            type: "series.lines",
            dependencies: ["grid", "polar"],
            visualColorAccessPath: "lineStyle.normal.color",
            init: function(K) {
                A(K);
                E.superApply(this, "init", arguments)
            },
            mergeOption: function(K) {
                A(K);
                E.superApply(this, "mergeOption", arguments)
            },
            getInitialData: function(K, M) {
                if (true) {
                    var L = G.get(K.coordinateSystem);
                    if (!L) {
                        throw new Error("Unkown coordinate system " + K.coordinateSystem)
                    }
                }
                var N = new I(["value"], this);
                N.hasItemOption = false;
                N.initData(K.data, [], function(Q, R, O, P) {
                    if (Q instanceof Array) {
                        return NaN
                    } else {
                        N.hasItemOption = true;
                        var S = Q.value;
                        if (S != null) {
                            return S instanceof Array ? S[P] : S
                        }
                    }
                });
                return N
            },
            formatTooltip: function(L) {
                var Q = this.getData();
                var N = Q.getItemModel(L);
                var O = N.get("name");
                if (O) {
                    return O
                }
                var M = N.get("fromName");
                var P = N.get("toName");
                var K = [];
                M != null && K.push(M);
                P != null && K.push(P);
                return C.encodeHTML(K.join(" > "))
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: true,
                hoverAnimation: true,
                xAxisIndex: 0,
                yAxisIndex: 0,
                symbol: ["none", "none"],
                symbolSize: [10, 10],
                geoIndex: 0,
                effect: {show: false, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: true, trailLength: 0.2},
                large: false,
                largeThreshold: 2000,
                polyline: false,
                label: {normal: {show: false, position: "end"}},
                lineStyle: {normal: {opacity: 0.5}}
            }
        })
    }, function(H, I, C) {
        var B = C(210);
        var F = C(277);
        var G = C(211);
        var E = C(278);
        var A = C(279);
        var D = C(280);
        C(1).extendChartView({
            type: "lines", init: function() {
            }, render: function(U, K, S) {
                var M = U.getData();
                var N = this._lineDraw;
                var P = U.get("effect.show");
                var Q = U.get("polyline");
                var O = U.get("large") && M.count() >= U.get("largeThreshold");
                if (true) {
                    if (P && O) {
                        console.warn("Large lines not support effect")
                    }
                }
                if (P !== this._hasEffet || Q !== this._isPolyline || O !== this._isLarge) {
                    if (N) {
                        N.remove()
                    }
                    N = this._lineDraw = O ? new D() : new B(Q ? (P ? A : E) : (P ? F : G));
                    this._hasEffet = P;
                    this._isPolyline = Q;
                    this._isLarge = O
                }
                var J = U.get("zlevel");
                var R = U.get("effect.trailLength");
                var L = S.getZr();
                L.painter.getLayer(J).clear(true);
                if (this._lastZlevel != null) {
                    L.configLayer(this._lastZlevel, {motionBlur: false})
                }
                if (P && R) {
                    if (true) {
                        var T = false;
                        K.eachSeries(function(V) {
                            if (V !== U && V.get("zlevel") === J) {
                                T = true
                            }
                        });
                        T && console.warn("Lines with trail effect should have an individual zlevel")
                    }
                    L.configLayer(J, {motionBlur: true, lastFrameAlpha: Math.max(Math.min(R / 10 + 0.9, 1), 0)})
                }
                this.group.add(N.group);
                N.updateData(M);
                this._lastZlevel = J
            }, updateLayout: function(J, K, M) {
                this._lineDraw.updateLayout(J);
                var L = M.getZr();
                L.painter.getLayer(this._lastZlevel).clear(true)
            }, remove: function(J, K) {
                this._lineDraw && this._lineDraw.remove(K, true)
            }, dispose: function() {
            }
        })
    }, function(I, K, C) {
        var E = C(18);
        var H = C(211);
        var B = C(4);
        var G = C(111);
        var F = C(10);
        var D = C(37);

        function A(L, M, N) {
            E.Group.call(this);
            this.add(this.createLine(L, M, N));
            this._updateEffectSymbol(L, M)
        }

        var J = A.prototype;
        J.createLine = function(L, M, N) {
            return new H(L, M, N)
        };
        J._updateEffectSymbol = function(S, O) {
            var L = S.getItemModel(O);
            var M = L.getModel("effect");
            var P = M.get("symbolSize");
            var Q = M.get("symbol");
            if (!B.isArray(P)) {
                P = [P, P]
            }
            var N = M.get("color") || S.getItemVisual(O, "color");
            var R = this.childAt(1);
            if (this._symbolType !== Q) {
                this.remove(R);
                R = G.createSymbol(Q, -0.5, -0.5, 1, 1, N);
                R.z2 = 100;
                R.culling = true;
                this.add(R)
            }
            if (!R) {
                return
            }
            R.setStyle("shadowColor", N);
            R.setStyle(M.getItemStyle(["color"]));
            R.attr("scale", P);
            R.setColor(N);
            R.attr("scale", P);
            this._symbolType = Q;
            this._updateEffectAnimation(S, M, O)
        };
        J._updateEffectAnimation = function(T, O, Q) {
            var S = this.childAt(1);
            if (!S) {
                return
            }
            var R = this;
            var U = T.getItemLayout(Q);
            var L = O.get("period") * 1000;
            var X = O.get("loop");
            var P = O.get("constantSpeed");
            var W = B.retrieve(O.get("delay"), function(Y) {
                return Y / T.count() * L / 3
            });
            var N = typeof W === "function";
            S.ignore = true;
            this.updateAnimationPoints(S, U);
            if (P > 0) {
                L = this.getLineLength(S) / P * 1000
            }
            if (L !== this._period || X !== this._loop) {
                S.stopAnimation();
                var M = W;
                if (N) {
                    M = W(Q)
                }
                if (S.__t > 0) {
                    M = -L * S.__t
                }
                S.__t = 0;
                var V = S.animate("", X).when(L, {__t: 1}).delay(M).during(function() {
                    R.updateSymbolPosition(S)
                });
                if (!X) {
                    V.done(function() {
                        R.remove(S)
                    })
                }
                V.start()
            }
            this._period = L;
            this._loop = X
        };
        J.getLineLength = function(L) {
            return (F.dist(L.__p1, L.__cp1) + F.dist(L.__cp1, L.__p2))
        };
        J.updateAnimationPoints = function(L, M) {
            L.__p1 = M[0];
            L.__p2 = M[1];
            L.__cp1 = M[2] || [(M[0][0] + M[1][0]) / 2, (M[0][1] + M[1][1]) / 2]
        };
        J.updateData = function(L, M, N) {
            this.childAt(0).updateData(L, M, N);
            this._updateEffectSymbol(L, M)
        };
        J.updateSymbolPosition = function(Q) {
            var P = Q.__p1;
            var S = Q.__p2;
            var T = Q.__cp1;
            var N = Q.__t;
            var R = Q.position;
            var O = D.quadraticAt;
            var M = D.quadraticDerivativeAt;
            R[0] = O(P[0], T[0], S[0], N);
            R[1] = O(P[1], T[1], S[1], N);
            var L = M(P[0], T[0], S[0], N);
            var U = M(P[1], T[1], S[1], N);
            Q.rotation = -Math.atan2(U, L) - Math.PI / 2;
            Q.ignore = false
        };
        J.updateLayout = function(L, N) {
            this.childAt(0).updateLayout(L, N);
            var M = L.getItemModel(N).getModel("effect");
            this._updateEffectAnimation(L, M, N)
        };
        B.inherits(A, E.Group);
        I.exports = A
    }, function(F, G, D) {
        var A = D(18);
        var B = D(4);

        function C(H, I, J) {
            A.Group.call(this);
            this._createPolyline(H, I, J)
        }

        var E = C.prototype;
        E._createPolyline = function(H, J, L) {
            var I = H.getItemLayout(J);
            var K = new A.Polyline({shape: {points: I}});
            this.add(K);
            this._updateCommonStl(H, J, L)
        };
        E.updateData = function(H, K, M) {
            var I = H.hostModel;
            var L = this.childAt(0);
            var J = {shape: {points: H.getItemLayout(K)}};
            A.updateProps(L, J, I, K);
            this._updateCommonStl(H, K, M)
        };
        E._updateCommonStl = function(L, J, K) {
            var H = this.childAt(0);
            var M = L.getItemModel(J);
            var O = L.getItemVisual(J, "color");
            var N = K && K.lineStyle;
            var I = K && K.hoverLineStyle;
            if (!K || L.hasItemOption) {
                N = M.getModel("lineStyle.normal").getLineStyle();
                I = M.getModel("lineStyle.emphasis").getLineStyle()
            }
            H.useStyle(B.defaults({strokeNoScale: true, fill: "none", stroke: O}, N));
            H.hoverStyle = I;
            A.setHoverStyle(this)
        };
        E.updateLayout = function(H, J) {
            var I = this.childAt(0);
            I.setShape("points", H.getItemLayout(J))
        };
        B.inherits(C, A.Group);
        F.exports = C
    }, function(H, I, C) {
        var F = C(278);
        var B = C(4);
        var G = C(277);
        var E = C(10);

        function A(J, K, L) {
            G.call(this, J, K, L);
            this._lastFrame = 0;
            this._lastFramePercent = 0
        }

        var D = A.prototype;
        D.createLine = function(J, K, L) {
            return new F(J, K, L)
        };
        D.updateAnimationPoints = function(K, L) {
            this._points = L;
            var P = [0];
            var M = 0;
            for (var J = 1; J < L.length; J++) {
                var N = L[J - 1];
                var O = L[J];
                M += E.dist(N, O);
                P.push(M)
            }
            if (M === 0) {
                return
            }
            for (var J = 0; J < P.length; J++) {
                P[J] /= M
            }
            this._offsets = P;
            this._length = M
        };
        D.getLineLength = function(J) {
            return this._length
        };
        D.updateSymbolPosition = function(Q) {
            var M = Q.__t;
            var L = this._points;
            var P = this._offsets;
            var R = L.length;
            if (!P) {
                return
            }
            var O = this._lastFrame;
            var N;
            if (M < this._lastFramePercent) {
                var K = Math.min(O + 1, R - 1);
                for (N = K; N >= 0; N--) {
                    if (P[N] <= M) {
                        break
                    }
                }
                N = Math.min(N, R - 2)
            } else {
                for (var N = O; N < R; N++) {
                    if (P[N] > M) {
                        break
                    }
                }
                N = Math.min(N - 1, R - 2)
            }
            E.lerp(Q.position, L[N], L[N + 1], (M - P[N]) / (P[N + 1] - P[N]));
            var J = L[N + 1][0] - L[N][0];
            var S = L[N + 1][1] - L[N][1];
            Q.rotation = -Math.atan2(S, J) - Math.PI / 2;
            this._lastFrame = N;
            this._lastFramePercent = M;
            Q.ignore = false
        };
        B.inherits(A, G);
        H.exports = A
    }, function(H, I, B) {
        var E = B(18);
        var A = B(42);
        var C = B(40);
        var D = E.extendShape({
            shape: {polyline: false, segs: []}, buildPath: function(P, K) {
                var J = K.segs;
                var M = K.polyline;
                for (var L = 0; L < J.length; L++) {
                    var N = J[L];
                    if (M) {
                        P.moveTo(N[0][0], N[0][1]);
                        for (var O = 1; O < N.length; O++) {
                            P.lineTo(N[O][0], N[O][1])
                        }
                    } else {
                        P.moveTo(N[0][0], N[0][1]);
                        if (N.length > 2) {
                            P.quadraticCurveTo(N[2][0], N[2][1], N[1][0], N[1][1])
                        } else {
                            P.lineTo(N[1][0], N[1][1])
                        }
                    }
                }
            }, findDataIndex: function(P, Q) {
                var K = this.shape;
                var J = K.segs;
                var O = K.polyline;
                var N = Math.max(this.style.lineWidth, 1);
                for (var M = 0; M < J.length; M++) {
                    var R = J[M];
                    if (O) {
                        for (var L = 1; L < R.length; L++) {
                            if (C.containStroke(R[L - 1][0], R[L - 1][1], R[L][0], R[L][1], N, P, Q)) {
                                return M
                            }
                        }
                    } else {
                        if (R.length > 2) {
                            if (A.containStroke(R[0][0], R[0][1], R[2][0], R[2][1], R[1][0], R[1][1], N, P, Q)) {
                                return M
                            }
                        } else {
                            if (C.containStroke(R[0][0], R[0][1], R[1][0], R[1][1], N, P, Q)) {
                                return M
                            }
                        }
                    }
                }
                return -1
            }
        });

        function G() {
            this.group = new E.Group();
            this._lineEl = new D()
        }

        var F = G.prototype;
        F.updateData = function(M) {
            this.group.removeAll();
            var J = this._lineEl;
            var K = M.hostModel;
            J.setShape({segs: M.mapArray(M.getItemLayout), polyline: K.get("polyline")});
            J.useStyle(K.getModel("lineStyle.normal").getLineStyle());
            var L = M.getVisual("color");
            if (L) {
                J.setStyle("stroke", L)
            }
            J.setStyle("fill");
            J.seriesIndex = K.seriesIndex;
            J.on("mousemove", function(O) {
                J.dataIndex = null;
                var N = J.findDataIndex(O.offsetX, O.offsetY);
                if (N > 0) {
                    J.dataIndex = N
                }
            });
            this.group.add(J)
        };
        F.updateLayout = function(J) {
            var K = J.getData();
            this._lineEl.setShape({segs: K.mapArray(K.getItemLayout)})
        };
        F.remove = function() {
            this.group.removeAll()
        };
        H.exports = G
    }, function(B, C, A) {
        B.exports = function(D) {
            D.eachSeriesByType("lines", function(E) {
                var G = E.coordinateSystem;
                var F = E.getData();
                F.each(function(L) {
                    var J = F.getItemModel(L);
                    var I = (J.option instanceof Array) ? J.option : J.get("coords");
                    if (true) {
                        if (!(I instanceof Array && I.length > 0 && I[0] instanceof Array)) {
                            throw new Error("Invalid coords " + JSON.stringify(I) + ". Lines must have 2d coords array in data item.")
                        }
                    }
                    var M = [];
                    if (E.get("polyline")) {
                        for (var H = 0; H < I.length; H++) {
                            M.push(G.dataToPoint(I[H]))
                        }
                    } else {
                        M[0] = G.dataToPoint(I[0]);
                        M[1] = G.dataToPoint(I[1]);
                        var K = J.get("lineStyle.normal.curveness");
                        if (+K) {
                            M[2] = [(M[0][0] + M[1][0]) / 2 - (M[0][1] - M[1][1]) * K, (M[0][1] + M[1][1]) / 2 - (M[1][0] - M[0][0]) * K]
                        }
                    }
                    F.setItemLayout(L, M)
                })
            })
        }
    }, function(B, C) {
        function A(D) {
            if (!(D instanceof Array)) {
                D = [D, D]
            }
            return D
        }

        B.exports = function(D) {
            D.eachSeriesByType("lines", function(E) {
                var I = E.getData();
                var F = A(E.get("symbol"));
                var G = A(E.get("symbolSize"));
                var H = "lineStyle.normal.opacity".split(".");
                I.setVisual("fromSymbol", F && F[0]);
                I.setVisual("toSymbol", F && F[1]);
                I.setVisual("fromSymbolSize", G && G[0]);
                I.setVisual("toSymbolSize", G && G[1]);
                I.setVisual("opacity", E.get(H));
                I.each(function(M) {
                    var K = I.getItemModel(M);
                    var J = A(K.getShallow("symbol", true));
                    var N = A(K.getShallow("symbolSize", true));
                    var L = K.get(H);
                    J[0] && I.setItemVisual(M, "fromSymbol", J[0]);
                    J[1] && I.setItemVisual(M, "toSymbol", J[1]);
                    N[0] && I.setItemVisual(M, "fromSymbolSize", N[0]);
                    N[1] && I.setItemVisual(M, "toSymbolSize", N[1]);
                    I.setItemVisual(M, "opacity", L)
                })
            })
        }
    }, function(B, C, A) {
        A(284);
        A(285)
    }, function(C, E, A) {
        var D = A(78);
        var B = A(109);
        C.exports = D.extend({
            type: "series.heatmap",
            getInitialData: function(F, G) {
                return B(F.data, this, G)
            },
            defaultOption: {coordinateSystem: "cartesian2d", zlevel: 0, z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0}
        })
    }, function(H, I, C) {
        var E = C(18);
        var G = C(286);
        var B = C(4);

        function A(N, O, L) {
            var K = N[1] - N[0];
            O = B.map(O, function(P) {
                return {interval: [(P.interval[0] - N[0]) / K, (P.interval[1] - N[0]) / K]}
            });
            var M = O.length;
            var J = 0;
            return function(R) {
                for (var P = J; P < M; P++) {
                    var Q = O[P].interval;
                    if (Q[0] <= R && R <= Q[1]) {
                        J = P;
                        break
                    }
                }
                if (P === M) {
                    for (var P = J - 1; P >= 0; P--) {
                        var Q = O[P].interval;
                        if (Q[0] <= R && R <= Q[1]) {
                            J = P;
                            break
                        }
                    }
                }
                return P >= 0 && P < M && L[P]
            }
        }

        function F(L, K) {
            var J = L[1] - L[0];
            K = [(K[0] - L[0]) / J, (K[1] - L[0]) / J];
            return function(M) {
                return M >= K[0] && M <= K[1]
            }
        }

        function D(J) {
            var K = J.dimensions;
            return K[0] === "lng" && K[1] === "lat"
        }

        H.exports = C(1).extendChartView({
            type: "heatmap", render: function(J, K, N) {
                var L;
                K.eachComponent("visualMap", function(O) {
                    O.eachTargetSeries(function(P) {
                        if (P === J) {
                            L = O
                        }
                    })
                });
                if (true) {
                    if (!L) {
                        throw new Error("Heatmap must use with visualMap")
                    }
                }
                this.group.removeAll();
                var M = J.coordinateSystem;
                if (M.type === "cartesian2d" || M.type === "calendar") {
                    this._renderOnCartesianAndCalendar(M, J, N)
                } else {
                    if (D(M)) {
                        this._renderOnGeo(M, J, L, N)
                    }
                }
            }, dispose: function() {
            }, _renderOnCartesianAndCalendar: function(S, O, R) {
                if (S.type === "cartesian2d") {
                    var V = S.getAxis("x");
                    var N = S.getAxis("y");
                    if (true) {
                        if (!(V.type === "category" && N.type === "category")) {
                            throw new Error("Heatmap on cartesian must have two category axes")
                        }
                        if (!(V.onBand && N.onBand)) {
                            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true")
                        }
                    }
                    var U = V.getBandWidth();
                    var a = N.getBandWidth()
                }
                var W = this.group;
                var X = O.getData();
                var Y = "itemStyle.normal";
                var T = "itemStyle.emphasis";
                var Q = "label.normal";
                var Z = "label.emphasis";
                var b = O.getModel(Y).getItemStyle(["color"]);
                var J = O.getModel(T).getItemStyle();
                var L = O.getModel("label.normal");
                var K = O.getModel("label.emphasis");
                var M = S.type;
                var P = M === "cartesian2d" ? [O.coordDimToDataDim("x")[0], O.coordDimToDataDim("y")[0], O.coordDimToDataDim("value")[0]] : [O.coordDimToDataDim("time")[0], O.coordDimToDataDim("value")[0]];
                X.each(function(g) {
                    var e;
                    if (M === "cartesian2d") {
                        if (isNaN(X.get(P[2], g))) {
                            return
                        }
                        var d = S.dataToPoint([X.get(P[0], g), X.get(P[1], g)]);
                        e = new E.Rect({
                            shape: {x: d[0] - U / 2, y: d[1] - a / 2, width: U, height: a},
                            style: {fill: X.getItemVisual(g, "color"), opacity: X.getItemVisual(g, "opacity")}
                        })
                    } else {
                        if (isNaN(X.get(P[1], g))) {
                            return
                        }
                        e = new E.Rect({
                            z2: 1,
                            shape: S.dataToRect([X.get(P[0], g)]).contentShape,
                            style: {fill: X.getItemVisual(g, "color"), opacity: X.getItemVisual(g, "opacity")}
                        })
                    }
                    var f = X.getItemModel(g);
                    if (X.hasItemOption) {
                        b = f.getModel(Y).getItemStyle(["color"]);
                        J = f.getModel(T).getItemStyle();
                        L = f.getModel(Q);
                        K = f.getModel(Z)
                    }
                    var c = O.getRawValue(g);
                    var h = "-";
                    if (c && c[2] != null) {
                        h = c[2]
                    }
                    if (L.getShallow("show")) {
                        E.setText(b, L);
                        b.text = O.getFormattedLabel(g, "normal") || h
                    }
                    if (K.getShallow("show")) {
                        E.setText(J, K);
                        J.text = O.getFormattedLabel(g, "emphasis") || h
                    }
                    e.setStyle(b);
                    E.setHoverStyle(e, X.hasItemOption ? J : B.extend({}, J));
                    W.add(e);
                    X.setItemGraphicEl(g, e)
                })
            }, _renderOnGeo: function(U, M, K, Q) {
                var L = K.targetVisuals.inRange;
                var R = K.targetVisuals.outOfRange;
                var O = M.getData();
                var N = this._hmLayer || (this._hmLayer || new G());
                N.blurSize = M.get("blurSize");
                N.pointSize = M.get("pointSize");
                N.minOpacity = M.get("minOpacity");
                N.maxOpacity = M.get("maxOpacity");
                var P = U.getViewRect().clone();
                var S = U.getRoamTransform().transform;
                P.applyTransform(S);
                var Y = Math.max(P.x, 0);
                var Z = Math.max(P.y, 0);
                var b = Math.min(P.width + P.x, Q.getWidth());
                var W = Math.min(P.height + P.y, Q.getHeight());
                var c = b - Y;
                var a = W - Z;
                var T = O.mapArray(["lng", "lat", "value"], function(f, g, d) {
                    var e = U.dataToPoint([f, g]);
                    e[0] -= Y;
                    e[1] -= Z;
                    e.push(d);
                    return e
                });
                var V = K.getExtent();
                var J = K.type === "visualMap.continuous" ? F(V, K.option.range) : A(V, K.getPieceList(), K.option.selected);
                N.update(T, c, a, L.color.getNormalizer(), {inRange: L.color.getColorMapper(), outOfRange: R.color.getColorMapper()}, J);
                var X = new E.Image({style: {width: c, height: a, x: Y, y: Z, image: N.canvas}, silent: true});
                this.group.add(X)
            }
        })
    }, function(C, E, B) {
        var A = 256;
        var D = B(4);

        function F() {
            var G = D.createCanvas();
            this.canvas = G;
            this.blurSize = 30;
            this.pointSize = 20;
            this.maxOpacity = 1;
            this.minOpacity = 0;
            this._gradientPixels = {}
        }

        F.prototype = {
            update: function(b, g, f, c, N, V) {
                var h = this._getBrush();
                var P = this._getGradient(b, N, "inRange");
                var T = this._getGradient(b, N, "outOfRange");
                var G = this.pointSize + this.blurSize;
                var H = this.canvas;
                var O = H.getContext("2d");
                var J = b.length;
                H.width = g;
                H.height = f;
                for (var M = 0; M < J; ++M) {
                    var I = b[M];
                    var d = I[0];
                    var e = I[1];
                    var R = I[2];
                    var U = c(R);
                    O.globalAlpha = U;
                    O.drawImage(h, d - G, e - G)
                }
                var X = O.getImageData(0, 0, H.width, H.height);
                var L = X.data;
                var Q = 0;
                var Z = L.length;
                var Y = this.minOpacity;
                var K = this.maxOpacity;
                var W = K - Y;
                while (Q < Z) {
                    var U = L[Q + 3] / 256;
                    var S = Math.floor(U * (A - 1)) * 4;
                    if (U > 0) {
                        var a = V(U) ? P : T;
                        U > 0 && (U = U * W + Y);
                        L[Q++] = a[S];
                        L[Q++] = a[S + 1];
                        L[Q++] = a[S + 2];
                        L[Q++] = a[S + 3] * U * 256
                    } else {
                        Q += 4
                    }
                }
                O.putImageData(X, 0, 0);
                return H
            }, _getBrush: function() {
                var I = this._brushCanvas || (this._brushCanvas = D.createCanvas());
                var G = this.pointSize + this.blurSize;
                var H = G * 2;
                I.width = H;
                I.height = H;
                var J = I.getContext("2d");
                J.clearRect(0, 0, H, H);
                J.shadowOffsetX = H;
                J.shadowBlur = this.blurSize;
                J.shadowColor = "#000";
                J.beginPath();
                J.arc(-G, G, this.pointSize, 0, Math.PI * 2, true);
                J.closePath();
                J.fill();
                return I
            }, _getGradient: function(G, I, J) {
                var N = this._gradientPixels;
                var L = N[J] || (N[J] = new Uint8ClampedArray(256 * 4));
                var H = [0, 0, 0, 0];
                var M = 0;
                for (var K = 0; K < 256; K++) {
                    I[J](K / 255, true, H);
                    L[M++] = H[0];
                    L[M++] = H[1];
                    L[M++] = H[2];
                    L[M++] = H[3]
                }
                return L
            }
        };
        C.exports = F
    }, function(D, F, C) {
        var B = C(4);
        C(125);
        C(288);
        C(289);
        var E = C(145);
        var A = C(1);
        A.registerLayout(B.curry(E, "pictorialBar"));
        A.registerVisual(B.curry(C(121), "pictorialBar", "roundRect", null));
        C(124)
    }, function(C, D, B) {
        var A = B(141).extend({
            type: "series.pictorialBar",
            dependencies: ["grid"],
            defaultOption: {
                symbol: "circle",
                symbolSize: null,
                symbolRotate: null,
                symbolPosition: null,
                symbolOffset: null,
                symbolMargin: null,
                symbolRepeat: false,
                symbolRepeatDirection: "end",
                symbolClip: false,
                symbolBoundingData: null,
                symbolPatternSize: 400,
                barGap: "-100%",
                progressive: 0,
                hoverAnimation: false
            },
            getInitialData: function(E) {
                E.stack = null;
                return A.superApply(this, "getInitialData", arguments)
            }
        });
        C.exports = A
    }, function(b, g, H) {
        var O = H(4);
        var c = H(18);
        var Y = H(111);
        var h = H(7);
        var M = H(143);
        var T = h.parsePercent;
        var G = ["itemStyle", "normal", "borderWidth"];
        var B = [{xy: "x", wh: "width", index: 0, posDesc: ["left", "right"]}, {xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"]}];
        var I = new c.Circle();
        var f = H(1).extendChartView({
            type: "pictorialBar", render: function(u, k, t) {
                var p = this.group;
                var m = u.getData();
                var n = this._data;
                var o = u.coordinateSystem;
                var s = o.getBaseAxis();
                var l = !!s.isHorizontal();
                var r = o.grid.getRect();
                var q = {
                    ecSize: {width: t.getWidth(), height: t.getHeight()},
                    seriesModel: u,
                    coordSys: o,
                    coordSysExtent: [[r.x, r.x + r.width], [r.y, r.y + r.height]],
                    isHorizontal: l,
                    valueDim: B[+l],
                    categoryDim: B[1 - l]
                };
                m.diff(n).add(function(v) {
                    if (!m.hasValue(v)) {
                        return
                    }
                    var w = j(m, v);
                    var y = R(m, v, w, q);
                    var x = C(m, q, y);
                    m.setItemGraphicEl(v, x);
                    p.add(x);
                    E(x, q, y)
                }).update(function(z, w) {
                    var x = n.getItemGraphicEl(w);
                    if (!m.hasValue(z)) {
                        p.remove(x);
                        return
                    }
                    var v = j(m, z);
                    var y = R(m, z, v, q);
                    var Aa = a(m, y);
                    if (x && Aa !== x.__pictorialShapeStr) {
                        p.remove(x);
                        m.setItemGraphicEl(z, null);
                        x = null
                    }
                    if (x) {
                        N(x, q, y)
                    } else {
                        x = C(m, q, y, true)
                    }
                    m.setItemGraphicEl(z, x);
                    x.__pictorialSymbolMeta = y;
                    p.add(x);
                    E(x, q, y)
                }).remove(function(v) {
                    var w = n.getItemGraphicEl(v);
                    w && Q(n, v, w.__pictorialSymbolMeta.animationModel, w)
                }).execute();
                this._data = m;
                return this.group
            }, dispose: O.noop, remove: function(l, m) {
                var k = this.group;
                var n = this._data;
                if (l.get("animation")) {
                    if (n) {
                        n.eachItemGraphicEl(function(o) {
                            Q(n, o.dataIndex, l, o)
                        })
                    }
                } else {
                    k.removeAll()
                }
            }
        });

        function R(o, t, l, n) {
            var s = o.getItemLayout(t);
            var u = l.get("symbolRepeat");
            var x = l.get("symbolClip");
            var r = l.get("symbolPosition") || "start";
            var v = l.get("symbolRotate");
            var w = (v || 0) * Math.PI / 180 || 0;
            var m = l.get("symbolPatternSize") || 2;
            var y = l.isAnimationEnabled();
            var k = {
                dataIndex: t,
                layout: s,
                itemModel: l,
                symbolType: o.getItemVisual(t, "symbol") || "circle",
                color: o.getItemVisual(t, "color"),
                symbolClip: x,
                symbolRepeat: u,
                symbolRepeatDirection: l.get("symbolRepeatDirection"),
                symbolPatternSize: m,
                rotation: w,
                animationModel: y ? l : null,
                hoverAnimation: y && l.get("hoverAnimation"),
                z2: l.getShallow("z", true) || 0
            };
            d(l, u, s, n, k);
            U(o, t, s, u, x, k.boundingLength, k.pxSign, m, n, k);
            F(l, k.symbolScale, w, n, k);
            var p = k.symbolSize;
            var q = l.get("symbolOffset");
            if (O.isArray(q)) {
                q = [T(q[0], p[0]), T(q[1], p[1])]
            }
            S(l, p, s, u, x, q, r, k.valueLineWidth, k.boundingLength, k.repeatCutLength, n, k);
            return k
        }

        function d(l, v, q, m, n) {
            var p = m.valueDim;
            var r = l.get("symbolBoundingData");
            var k = m.coordSys.getOtherAxis(m.coordSys.getBaseAxis());
            var o = k.toGlobalCoord(k.dataToCoord(0));
            var s = 1 - +(q[p.wh] <= 0);
            var t;
            if (O.isArray(r)) {
                var u = [D(k, r[0]) - o, D(k, r[1]) - o];
                u[1] < u[0] && (u.reverse());
                t = u[s]
            } else {
                if (r != null) {
                    t = D(k, r) - o
                } else {
                    if (v) {
                        t = m.coordSysExtent[p.index][s] - o
                    } else {
                        t = q[p.wh]
                    }
                }
            }
            n.boundingLength = t;
            if (v) {
                n.repeatCutLength = q[p.wh]
            }
            n.pxSign = t > 0 ? 1 : t < 0 ? -1 : 0
        }

        function D(l, k) {
            return l.toGlobalCoord(l.dataToCoord(l.scale.parse(k)))
        }

        function U(p, t, s, w, x, u, r, n, o, q) {
            var l = o.valueDim;
            var m = o.categoryDim;
            var y = Math.abs(s[m.wh]);
            var k = p.getItemVisual(t, "symbolSize");
            if (O.isArray(k)) {
                k = k.slice()
            } else {
                if (k == null) {
                    k = "100%"
                }
                k = [k, k]
            }
            k[m.index] = T(k[m.index], y);
            k[l.index] = T(k[l.index], w ? y : Math.abs(u));
            q.symbolSize = k;
            var v = q.symbolScale = [k[0] / n, k[1] / n];
            v[l.index] *= (o.isHorizontal ? -1 : 1) * r
        }

        function F(l, m, k, o, p) {
            var n = l.get(G) || 0;
            if (n) {
                I.attr({scale: m.slice(), rotation: k});
                I.updateTransform();
                n /= I.getLineScale();
                n *= m[o.valueDim.index]
            }
            p.valueLineWidth = n
        }

        function S(Am, n, v, m, l, u, Ad, Ah, q, Aj, s, z) {
            var x = s.categoryDim;
            var w = s.valueDim;
            var t = z.pxSign;
            var Al = Math.max(n[w.index] + Ah, 0);
            var Aa = Al;
            if (m) {
                var y = Math.abs(q);
                var r = O.retrieve(Am.get("symbolMargin"), "15%") + "";
                var p = false;
                if (r.lastIndexOf("!") === r.length - 1) {
                    p = true;
                    r = r.slice(0, r.length - 1)
                }
                r = T(r, n[w.index]);
                var Ag = Math.max(Al + r * 2, 0);
                var k = p ? 0 : r * 2;
                var Ae = h.isNumeric(m);
                var Ak = Ae ? m : Z((y + k) / Ag);
                var o = y - Ak * Al;
                r = o / 2 / (p ? Ak : Ak - 1);
                Ag = Al + r * 2;
                k = p ? 0 : r * 2;
                if (!Ae && m !== "fixed") {
                    Ak = Aj ? Z((Math.abs(Aj) + k) / Ag) : 0
                }
                Aa = Ak * Ag - k;
                z.repeatTimes = Ak;
                z.symbolMargin = r
            }
            var Ai = t * (Aa / 2);
            var Af = z.pathPosition = [];
            Af[x.index] = v[x.wh] / 2;
            Af[w.index] = Ad === "start" ? Ai : Ad === "end" ? q - Ai : q / 2;
            if (u) {
                Af[0] += u[0];
                Af[1] += u[1]
            }
            var An = z.bundlePosition = [];
            An[x.index] = v[x.xy];
            An[w.index] = v[w.xy];
            var Ab = z.barRectShape = O.extend({}, v);
            Ab[w.wh] = t * Math.max(Math.abs(v[w.wh]), Math.abs(Af[w.index] + Ai));
            Ab[x.wh] = v[x.wh];
            var Ac = z.clipShape = {};
            Ac[x.xy] = -v[x.xy];
            Ac[x.wh] = s.ecSize[x.wh];
            Ac[w.xy] = 0;
            Ac[w.wh] = v[w.wh]
        }

        function A(l) {
            var k = l.symbolPatternSize;
            var m = Y.createSymbol(l.symbolType, -k / 2, -k / 2, k, k, l.color);
            m.attr({culling: true});
            m.type !== "image" && m.setStyle({strokeNoScale: true});
            return m
        }

        function V(m, q, v, l) {
            var Aa = m.__pictorialBundle;
            var n = v.symbolSize;
            var x = v.valueLineWidth;
            var s = v.pathPosition;
            var r = q.valueDim;
            var z = v.repeatTimes || 0;
            var o = 0;
            var w = n[q.valueDim.index] + x + v.symbolMargin * 2;
            L(m, function(Ab) {
                Ab.__pictorialAnimationIndex = o;
                Ab.__pictorialRepeatTimes = z;
                if (o < z) {
                    X(Ab, null, u(o), v, l)
                } else {
                    X(Ab, null, {scale: [0, 0]}, v, l, function() {
                        Aa.remove(Ab)
                    })
                }
                K(Ab, v);
                o++
            });
            for (; o < z; o++) {
                var t = A(v);
                t.__pictorialAnimationIndex = o;
                t.__pictorialRepeatTimes = z;
                Aa.add(t);
                var y = u(o, true);
                X(t, {position: y.position, scale: [0, 0]}, {scale: y.scale, rotation: y.rotation}, v, l);
                t.on("mouseover", p).on("mouseout", k);
                K(t, v)
            }

            function u(Ae) {
                var Ad = s.slice();
                var Ac = v.pxSign;
                var Ab = Ae;
                if (v.symbolRepeatDirection === "start" ? Ac > 0 : Ac < 0) {
                    Ab = z - 1 - Ae
                }
                Ad[r.index] = w * (Ab - z / 2 + 0.5) + s[r.index];
                return {position: Ad, scale: v.symbolScale.slice(), rotation: v.rotation}
            }

            function p() {
                L(m, function(Ab) {
                    Ab.trigger("emphasis")
                })
            }

            function k() {
                L(m, function(Ab) {
                    Ab.trigger("normal")
                })
            }
        }

        function i(p, n, k, q) {
            var m = p.__pictorialBundle;
            var l = p.__pictorialMainPath;
            if (!l) {
                l = p.__pictorialMainPath = A(k);
                m.add(l);
                X(l, {position: k.pathPosition.slice(), scale: [0, 0], rotation: k.rotation}, {scale: k.symbolScale.slice()}, k, q);
                l.on("mouseover", o).on("mouseout", r)
            } else {
                X(l, null, {position: k.pathPosition.slice(), scale: k.symbolScale.slice(), rotation: k.rotation}, k, q)
            }
            K(l, k);

            function o() {
                this.trigger("emphasis")
            }

            function r() {
                this.trigger("normal")
            }
        }

        function e(m, n, o) {
            var k = O.extend({}, n.barRectShape);
            var l = m.__pictorialBarRect;
            if (!l) {
                l = m.__pictorialBarRect = new c.Rect({
                    z2: 2,
                    shape: k,
                    silent: true,
                    style: {stroke: "transparent", fill: "transparent", lineWidth: 0}
                });
                m.add(l)
            } else {
                X(l, null, {shape: k}, n, o)
            }
        }

        function W(p, l, k, t) {
            if (k.symbolClip) {
                var s = p.__pictorialClipPath;
                var n = O.extend({}, k.clipShape);
                var o = l.valueDim;
                var m = k.animationModel;
                var q = k.dataIndex;
                if (s) {
                    c.updateProps(s, {shape: n}, m, q)
                } else {
                    n[o.wh] = 0;
                    s = new c.Rect({shape: n});
                    p.__pictorialBundle.setClipPath(s);
                    p.__pictorialClipPath = s;
                    var r = {};
                    r[o.wh] = k.clipShape[o.wh];
                    c[t ? "updateProps" : "initProps"](s, {shape: r}, m, q)
                }
            }
        }

        function j(m, k) {
            var l = m.getItemModel(k);
            l.getAnimationDelayParams = P;
            l.isAnimationEnabled = J;
            return l
        }

        function P(k) {
            return {index: k.__pictorialAnimationIndex, count: k.__pictorialRepeatTimes}
        }

        function J() {
            return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation")
        }

        function K(m, k) {
            m.off("emphasis").off("normal");
            var l = k.symbolScale.slice();
            k.hoverAnimation && m.on("emphasis", function() {
                this.animateTo({scale: [l[0] * 1.1, l[1] * 1.1]}, 400, "elasticOut")
            }).on("normal", function() {
                this.animateTo({scale: l.slice()}, 400, "elasticOut")
            })
        }

        function C(p, l, n, o) {
            var m = new c.Group();
            var k = new c.Group();
            m.add(k);
            m.__pictorialBundle = k;
            k.attr("position", n.bundlePosition.slice());
            if (n.symbolRepeat) {
                V(m, l, n)
            } else {
                i(m, l, n)
            }
            e(m, n, o);
            W(m, l, n, o);
            m.__pictorialShapeStr = a(p, n);
            m.__pictorialSymbolMeta = n;
            return m
        }

        function N(m, l, n) {
            var o = n.animationModel;
            var k = n.dataIndex;
            var p = m.__pictorialBundle;
            c.updateProps(p, {position: n.bundlePosition.slice()}, o, k);
            if (n.symbolRepeat) {
                V(m, l, n, true)
            } else {
                i(m, l, n, true)
            }
            e(m, n, true);
            W(m, l, n, true)
        }

        function Q(p, k, o, n) {
            var m = n.__pictorialBarRect;
            m && (m.style.text = "");
            var l = [];
            L(n, function(q) {
                l.push(q)
            });
            n.__pictorialMainPath && l.push(n.__pictorialMainPath);
            n.__pictorialClipPath && (o = null);
            O.each(l, function(q) {
                c.updateProps(q, {scale: [0, 0]}, o, k, function() {
                    n.parent && n.parent.remove(n)
                })
            });
            p.setItemGraphicEl(k, null)
        }

        function a(l, k) {
            return [l.getItemVisual(k.dataIndex, "symbol") || "none", !!k.symbolRepeat, !!k.symbolClip].join(":")
        }

        function L(m, k, l) {
            O.each(m.__pictorialBundle.children(), function(n) {
                n !== m.__pictorialBarRect && k.call(l, n)
            })
        }

        function X(k, o, m, n, p, l) {
            o && k.attr(o);
            if (n.symbolClip && !p) {
                m && k.attr(m)
            } else {
                m && c[p ? "updateProps" : "initProps"](k, m, n.animationModel, n.dataIndex, l)
            }
        }

        function E(t, n, k) {
            var o = k.color;
            var u = k.dataIndex;
            var l = k.itemModel;
            var s = l.getModel("itemStyle.normal").getItemStyle(["color"]);
            var v = l.getModel("itemStyle.emphasis").getItemStyle();
            var m = l.getShallow("cursor");
            L(t, function(w) {
                w.setColor(o);
                w.setStyle(O.defaults({fill: o, opacity: k.opacity}, s));
                c.setHoverStyle(w, v);
                m && (w.cursor = m);
                w.z2 = k.z2
            });
            var p = {};
            var q = n.valueDim.posDesc[+(k.boundingLength > 0)];
            var r = t.__pictorialBarRect;
            M.setLabel(r.style, p, l, o, n.seriesModel, u, q);
            c.setHoverStyle(r, p)
        }

        function Z(k) {
            var l = Math.round(k);
            return Math.abs(k - l) < 0.0001 ? l : Math.ceil(k)
        }

        b.exports = f
    }, function(C, E, B) {
        var D = B(1);
        var A = B(4);
        B(291);
        B(308);
        B(309);
        D.registerLayout(B(311));
        D.registerVisual(B(312));
        D.registerProcessor(A.curry(B(154), "themeRiver"))
    }, function(B, D, A) {
        A(292);
        A(295);
        A(297);
        A(298);
        A(307);
        var C = A(1);
        C.extendComponentView({type: "single"})
    }, function(B, E, A) {
        var C = A(293);

        function D(F, H) {
            var G = [];
            F.eachComponent("singleAxis", function(I, K) {
                var J = new C(I, F, H);
                J.name = "single_" + K;
                J.resize(I, H);
                I.coordinateSystem = J;
                G.push(J)
            });
            F.eachSeries(function(I) {
                if (I.get("coordinateSystem") === "singleAxis") {
                    var J = F.queryComponents({mainType: "singleAxis", index: I.get("singleAxisIndex"), id: I.get("singleAxisId")})[0];
                    I.coordinateSystem = J && J.coordinateSystem
                }
            });
            return G
        }

        A(76).register("single", {create: D, dimensions: C.prototype.dimensions})
    }, function(C, G, B) {
        var A = B(294);
        var D = B(101);
        var E = B(71);

        function F(I, H, J) {
            this.dimension = "single";
            this.dimensions = ["single"];
            this._axis = null;
            this._rect;
            this._init(I, H, J);
            this.model = I
        }

        F.prototype = {
            type: "singleAxis", axisPointerEnabled: true, constructor: F, _init: function(J, I, L) {
                var K = this.dimension;
                var M = new A(K, D.createScaleByModel(J), [0, 0], J.get("type"), J.get("position"));
                var H = M.type === "category";
                M.onBand = H && J.get("boundaryGap");
                M.inverse = J.get("inverse");
                M.orient = J.get("orient");
                J.axis = M;
                M.model = J;
                M.coordinateSystem = this;
                this._axis = M
            }, update: function(H, I) {
                H.eachSeries(function(J) {
                    if (J.coordinateSystem === this) {
                        var L = J.getData();
                        var K = this.dimension;
                        this._axis.scale.unionExtentFromData(L, J.coordDimToDataDim(K));
                        D.niceScaleExtent(this._axis.scale, this._axis.model)
                    }
                }, this)
            }, resize: function(H, I) {
                this._rect = E.getLayoutRect({
                    left: H.get("left"),
                    top: H.get("top"),
                    right: H.get("right"),
                    bottom: H.get("bottom"),
                    width: H.get("width"),
                    height: H.get("height")
                }, {width: I.getWidth(), height: I.getHeight()});
                this._adjustAxis()
            }, getRect: function() {
                return this._rect
            }, _adjustAxis: function() {
                var I = this._rect;
                var L = this._axis;
                var H = L.isHorizontal();
                var J = H ? [0, I.width] : [0, I.height];
                var K = L.reverse ? 1 : 0;
                L.setExtent(J[K], J[1 - K]);
                this._updateAxisTransform(L, H ? I.x : I.y)
            }, _updateAxisTransform: function(L, J) {
                var H = L.getExtent();
                var I = H[0] + H[1];
                var K = L.isHorizontal();
                L.toGlobalCoord = K ? function(M) {
                    return M + J
                } : function(M) {
                    return I - M + J
                };
                L.toLocalCoord = K ? function(M) {
                    return M - J
                } : function(M) {
                    return I - M + J
                }
            }, getAxis: function() {
                return this._axis
            }, getBaseAxis: function() {
                return this._axis
            }, getAxes: function() {
                return [this._axis]
            }, getTooltipAxes: function() {
                return {baseAxes: [this.getAxis()]}
            }, containPoint: function(H) {
                var I = this.getRect();
                var K = this.getAxis();
                var J = K.orient;
                if (J === "horizontal") {
                    return K.contain(K.toLocalCoord(H[0])) && (H[1] >= I.y && H[1] <= (I.y + I.height))
                } else {
                    return K.contain(K.toLocalCoord(H[1])) && (H[0] >= I.y && H[0] <= (I.y + I.height))
                }
            }, pointToData: function(H) {
                var I = this.getAxis();
                return [I.coordToData(I.toLocalCoord(H[I.orient === "horizontal" ? 0 : 1]))]
            }, dataToPoint: function(K) {
                var L = this.getAxis();
                var I = this.getRect();
                var H = [];
                var J = L.orient === "horizontal" ? 0 : 1;
                if (K instanceof Array) {
                    K = K[0]
                }
                H[J] = L.toGlobalCoord(L.dataToCoord(+K));
                H[1 - J] = J === 0 ? (I.y + I.height / 2) : (I.x + I.width / 2);
                return H
            }
        };
        C.exports = F
    }, function(D, F, C) {
        var A = C(4);
        var E = C(100);
        var B = function(I, J, H, K, G) {
            E.call(this, I, J, H);
            this.type = K || "value";
            this.position = G || "bottom";
            this.orient = null;
            this._labelInterval = null
        };
        B.prototype = {
            constructor: B, model: null, isHorizontal: function() {
                var G = this.position;
                return G === "top" || G === "bottom"
            }, pointToData: function(G, H) {
                return this.coordinateSystem.pointToData(G, H)[0]
            }, toGlobalCoord: null, toLocalCoord: null
        };
        A.inherits(B, E);
        D.exports = B
    }, function(K, L, D) {
        var A = D(135);
        var C = D(4);
        var E = D(18);
        var J = D(296);
        var I = A.getInterval;
        var H = A.ifIgnoreOnTick;
        var F = ["axisLine", "axisLabel", "axisTick", "axisName"];
        var G = "splitLine";
        var B = D(136).extend({
            type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function(O, N, R, P) {
                var M = this.group;
                M.removeAll();
                var Q = J.layout(O);
                var S = new A(O, Q);
                C.each(F, S.add, S);
                M.add(S.getGroup());
                if (O.get(G + ".show")) {
                    this["_" + G](O, Q.labelInterval)
                }
                B.superCall(this, "render", O, N, R, P)
            }, _splitLine: function(S, b) {
                var c = S.axis;
                if (c.scale.isBlank()) {
                    return
                }
                var X = S.getModel("splitLine");
                var a = X.getModel("lineStyle");
                var Z = a.get("width");
                var T = a.get("color");
                var U = I(X, b);
                T = T instanceof Array ? T : [T];
                var R = S.coordinateSystem.getRect();
                var V = c.isHorizontal();
                var P = [];
                var W = 0;
                var N = c.getTicksCoords();
                var d = [];
                var O = [];
                for (var Q = 0; Q < N.length; ++Q) {
                    if (H(c, Q, U)) {
                        continue
                    }
                    var M = c.toGlobalCoord(N[Q]);
                    if (V) {
                        d[0] = M;
                        d[1] = R.y;
                        O[0] = M;
                        O[1] = R.y + R.height
                    } else {
                        d[0] = R.x;
                        d[1] = M;
                        O[0] = R.x + R.width;
                        O[1] = M
                    }
                    var Y = (W++) % T.length;
                    P[Y] = P[Y] || [];
                    P[Y].push(new E.Line(E.subPixelOptimizeLine({
                        shape: {x1: d[0], y1: d[1], x2: O[0], y2: O[1]},
                        style: {lineWidth: Z},
                        silent: true
                    })))
                }
                for (var Q = 0; Q < P.length; ++Q) {
                    this.group.add(E.mergePath(P[Q], {style: {stroke: T[Q % T.length], lineDash: a.getLineDash(Z), lineWidth: Z}, silent: true}))
                }
            }
        });
        K.exports = B
    }, function(C, E, B) {
        var A = B(4);
        var D = {};
        D.layout = function(K, J) {
            J = J || {};
            var R = K.coordinateSystem;
            var H = K.axis;
            var N = {};
            var F = H.position;
            var O = H.orient;
            var L = R.getRect();
            var P = [L.x, L.x + L.width, L.y, L.y + L.height];
            var G = {horizontal: {top: P[2], bottom: P[3]}, vertical: {left: P[0], right: P[1]}};
            N.position = [O === "vertical" ? G.vertical[F] : P[0], O === "horizontal" ? G.horizontal[F] : P[3]];
            var I = {horizontal: 0, vertical: 1};
            N.rotation = Math.PI / 2 * I[O];
            var M = {top: -1, bottom: 1, right: 1, left: -1};
            N.labelDirection = N.tickDirection = N.nameDirection = M[F];
            if (K.get("axisTick.inside")) {
                N.tickDirection = -N.tickDirection
            }
            if (A.retrieve(J.labelInside, K.get("axisLabel.inside"))) {
                N.labelDirection = -N.labelDirection
            }
            var Q = J.rotate;
            Q == null && (Q = K.get("axisLabel.rotate"));
            N.labelRotation = F === "top" ? -Q : Q;
            N.labelInterval = H.getLabelInterval();
            N.z2 = 1;
            return N
        };
        C.exports = D
    }, function(G, I, D) {
        var H = D(69);
        var B = D(131);
        var C = D(4);
        var E = H.extend({
            type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel: function() {
                return this
            }
        });
        var F = {
            left: "5%",
            top: "5%",
            right: "5%",
            bottom: "5%",
            type: "value",
            position: "bottom",
            orient: "horizontal",
            axisLine: {show: true, lineStyle: {width: 2, type: "solid"}},
            tooltip: {show: true},
            axisTick: {show: true, length: 6, lineStyle: {width: 2}},
            axisLabel: {show: true, interval: "auto"},
            splitLine: {show: true, lineStyle: {type: "dashed", opacity: 0.2}}
        };

        function A(K, J) {
            return J.type || (J.data ? "category" : "value")
        }

        C.merge(E.prototype, D(112));
        B("single", E, A, F);
        G.exports = E
    }, function(E, G, C) {
        var F = C(1);
        var A = C(137);
        var D = C(299);
        var B = C(4);
        C(301);
        C(302);
        C(304);
        F.registerPreprocessor(function(H) {
            if (H) {
                (!H.axisPointer || H.axisPointer.length === 0) && (H.axisPointer = {});
                var I = H.axisPointer.link;
                if (I && !B.isArray(I)) {
                    H.axisPointer.link = [I]
                }
            }
        });
        F.registerProcessor(F.PRIORITY.PROCESSOR.STATISTIC, function(H, I) {
            H.getComponent("axisPointer").coordSysAxesInfo = A.collect(H, I)
        });
        F.registerAction({type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer"}, D)
    }, function(P, F, R) {
        var T = R(4);
        var C = R(5);
        var M = R(137);
        var Q = R(300);
        var G = T.each;
        var B = T.curry;
        var I = C.makeGetter();

        function J(k, Y, d) {
            var c = k.currTrigger;
            var W = [k.x, k.y];
            var V = k;
            var Z = k.dispatchAction || T.bind(d.dispatchAction, d);
            var a = Y.getComponent("axisPointer").coordSysAxesInfo;
            if (N(W)) {
                W = Q({seriesIndex: V.seriesIndex, dataIndex: V.dataIndex}, Y).point
            }
            var l = N(W);
            var b = V.axesInfo;
            var h = a.axesInfo;
            var e = c === "leave" || N(W);
            var f = {};
            var j = {};
            var X = {list: [], map: {}};
            var g = {showPointer: B(D, j), showTooltip: B(A, X)};
            G(a.coordSysMap, function(m, o) {
                var n = l || m.containPoint(W);
                G(a.coordSysAxesInfo[o], function(q, p) {
                    var t = q.axis;
                    var r = K(b, q);
                    if (!e && n && (!b || r)) {
                        var s = r && r.value;
                        if (s == null && !l) {
                            s = t.pointToData(W)
                        }
                        s != null && H(q, s, g, false, f)
                    }
                })
            });
            var i = {};
            G(h, function(n, m) {
                var o = n.linkGroup;
                if (o && !j[m]) {
                    G(o.axesInfo, function(s, q) {
                        var p = j[q];
                        if (s !== n && p) {
                            var r = p.value;
                            o.mapper && (r = n.axis.scale.parse(o.mapper(r, S(s), S(n))));
                            i[n.key] = r
                        }
                    })
                }
            });
            G(i, function(n, m) {
                H(h[m], n, g, true, f)
            });
            U(j, h, f);
            E(X, W, k, Z);
            O(h, Z, d);
            return f
        }

        function H(c, X, W, d, b) {
            var V = c.axis;
            if (V.scale.isBlank() || !V.containData(X)) {
                return
            }
            if (!c.involveSeries) {
                W.showPointer(c, X);
                return
            }
            var a = L(X, c);
            var Y = a.payloadBatch;
            var Z = a.snapToValue;
            if (Y[0] && b.seriesIndex == null) {
                T.extend(b, Y[0])
            }
            if (!d && c.snap) {
                if (V.containData(Z) && Z != null) {
                    X = Z
                }
            }
            W.showPointer(c, X, Y, b);
            W.showTooltip(c, a, Z)
        }

        function L(Y, b) {
            var V = b.axis;
            var a = V.dim;
            var X = Y;
            var W = [];
            var Z = Number.MAX_VALUE;
            var c = -1;
            G(b.seriesModels, function(j, e) {
                var k = j.coordDimToDataDim(a);
                var f;
                var i;
                if (j.getAxisTooltipData) {
                    var d = j.getAxisTooltipData(k, Y, V);
                    i = d.dataIndices;
                    f = d.nestestValue
                } else {
                    i = j.getData().indicesOfNearest(k[0], Y, false, V.type === "category" ? 0.5 : null);
                    if (!i.length) {
                        return
                    }
                    f = j.getData().get(k[0], i[0])
                }
                if (f == null || !isFinite(f)) {
                    return
                }
                var g = Y - f;
                var h = Math.abs(g);
                if (h <= Z) {
                    if (h < Z || (g >= 0 && c < 0)) {
                        Z = h;
                        c = g;
                        X = f;
                        W.length = 0
                    }
                    G(i, function(l) {
                        W.push({seriesIndex: j.seriesIndex, dataIndexInside: l, dataIndex: j.getData().getRawIndex(l)})
                    })
                }
            });
            return {payloadBatch: W, snapToValue: X}
        }

        function D(Y, V, X, W) {
            Y[V.key] = {value: X, payloadBatch: W}
        }

        function A(X, f, Z, a) {
            var Y = Z.payloadBatch;
            var V = f.axis;
            var d = V.model;
            var W = f.axisPointerModel;
            if (!f.triggerTooltip || !Y.length) {
                return
            }
            var c = f.coordSys.model;
            var e = M.makeKey(c);
            var b = X.map[e];
            if (!b) {
                b = X.map[e] = {
                    coordSysId: c.id,
                    coordSysIndex: c.componentIndex,
                    coordSysType: c.type,
                    coordSysMainType: c.mainType,
                    dataByAxis: []
                };
                X.list.push(b)
            }
            b.dataByAxis.push({
                axisDim: V.dim,
                axisIndex: d.componentIndex,
                axisType: d.type,
                axisId: d.id,
                value: a,
                valueLabelOpt: {precision: W.get("label.precision"), formatter: W.get("label.formatter")},
                seriesDataIndices: Y.slice()
            })
        }

        function U(X, V, Y) {
            var W = Y.axesInfo = [];
            G(V, function(a, Z) {
                var b = a.axisPointerModel.option;
                var c = X[Z];
                if (c) {
                    !a.useHandle && (b.status = "show");
                    b.value = c.value;
                    b.seriesDataIndices = (c.payloadBatch || []).slice()
                } else {
                    !a.useHandle && (b.status = "hide")
                }
                b.status === "show" && W.push({axisDim: a.axis.dim, axisIndex: a.axis.model.componentIndex, value: b.value})
            })
        }

        function E(X, W, Y, Z) {
            if (N(W) || !X.list.length) {
                Z({type: "hideTip"});
                return
            }
            var V = ((X.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
            Z({
                type: "showTip",
                escapeConnect: true,
                x: W[0],
                y: W[1],
                tooltipOption: Y.tooltipOption,
                position: Y.position,
                dataIndexInside: V.dataIndexInside,
                dataIndex: V.dataIndex,
                seriesIndex: V.seriesIndex,
                dataByCoordSys: X.list
            })
        }

        function O(Z, V, d) {
            var b = d.getZr();
            var a = "axisPointerLastHighlights";
            var Y = I(b)[a] || {};
            var X = I(b)[a] = {};
            G(Z, function(f, e) {
                var g = f.axisPointerModel.option;
                g.status === "show" && G(g.seriesDataIndices, function(i) {
                    var h = i.seriesIndex + " | " + i.dataIndex;
                    X[h] = i
                })
            });
            var W = [];
            var c = [];
            T.each(Y, function(f, e) {
                !X[e] && c.push(f)
            });
            T.each(X, function(f, e) {
                !Y[e] && W.push(f)
            });
            c.length && d.dispatchAction({type: "downplay", escapeConnect: true, batch: c});
            W.length && d.dispatchAction({type: "highlight", escapeConnect: true, batch: W})
        }

        function K(V, X) {
            for (var W = 0; W < (V || []).length; W++) {
                var Y = V[W];
                if (X.axis.dim === Y.axisDim && X.axis.model.componentIndex === Y.axisIndex) {
                    return Y
                }
            }
        }

        function S(V) {
            var W = V.axis.model;
            var X = {};
            var Y = X.axisDim = V.axis.dim;
            X.axisIndex = X[Y + "AxisIndex"] = W.componentIndex;
            X.axisName = X[Y + "AxisName"] = W.name;
            X.axisId = X[Y + "AxisId"] = W.id;
            return X
        }

        function N(V) {
            return !V || V[0] == null || isNaN(V[0]) || V[1] == null || isNaN(V[1])
        }

        P.exports = J
    }, function(D, E, B) {
        var A = B(4);
        var C = B(5);
        D.exports = function(F, G) {
            var N = [];
            var K = F.seriesIndex;
            var O;
            if (K == null || !(O = G.getSeriesByIndex(K))) {
                return {point: []}
            }
            var J = O.getData();
            var M = C.queryDataIndex(J, F);
            if (M == null || A.isArray(M)) {
                return {point: []}
            }
            var L = J.getItemGraphicEl(M);
            var H = O.coordinateSystem;
            if (O.getTooltipPosition) {
                N = O.getTooltipPosition(M) || []
            } else {
                if (H && H.dataToPoint) {
                    N = H.dataToPoint(J.getValues(A.map(H.dimensions, function(P) {
                        return O.coordDimToDataDim(P)[0]
                    }), M, true)) || []
                } else {
                    if (L) {
                        var I = L.getBoundingRect().clone();
                        I.applyTransform(L.transform);
                        N = [I.x + I.width / 2, I.y + I.height / 2]
                    }
                }
            }
            return {point: N, el: L}
        }
    }, function(C, E, A) {
        var D = A(1);
        var B = D.extendComponentModel({
            type: "axisPointer",
            coordSysAxesInfo: null,
            defaultOption: {
                show: "auto",
                triggerOn: null,
                zlevel: 0,
                z: 50,
                type: "line",
                snap: false,
                triggerTooltip: true,
                value: null,
                status: null,
                link: [],
                animation: null,
                animationDurationUpdate: 200,
                lineStyle: {color: "#aaa", width: 1, type: "solid"},
                shadowStyle: {color: "rgba(150,150,150,0.3)"},
                label: {
                    show: true,
                    formatter: null,
                    precision: "auto",
                    margin: 3,
                    textStyle: {color: "#fff"},
                    padding: [5, 7, 5, 7],
                    backgroundColor: "auto",
                    borderColor: null,
                    borderWidth: 0,
                    shadowBlur: 3,
                    shadowColor: "#aaa"
                },
                handle: {
                    show: false,
                    icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
                    size: 45,
                    margin: 50,
                    color: "#333",
                    shadowBlur: 3,
                    shadowColor: "#aaa",
                    shadowOffsetX: 0,
                    shadowOffsetY: 2,
                    throttle: 40
                }
            }
        });
        C.exports = B
    }, function(B, D, A) {
        var C = A(303);
        var E = A(1).extendComponentView({
            type: "axisPointer", render: function(F, H, J) {
                var I = H.getComponent("tooltip");
                var G = F.get("triggerOn") || (I && I.get("triggerOn") || "mousemove|click");
                C.register("axisPointer", J, function(M, K, L) {
                    if (G !== "none" && (M === "leave" || G.indexOf(M) >= 0)) {
                        L({type: "updateAxisPointer", currTrigger: M, x: K && K.offsetX, y: K && K.offsetY})
                    }
                })
            }, remove: function(F, G) {
                C.disopse(G.getZr(), "axisPointer");
                E.superApply(this._model, "remove", arguments)
            }, dispose: function(F, G) {
                C.unregister("axisPointer", G);
                E.superApply(this._model, "dispose", arguments)
            }
        })
    }, function(K, M, D) {
        var J = D(2);
        var C = D(4);
        var F = D(5).makeGetter();
        var A = C.each;
        var H = {};
        H.register = function(N, R, P) {
            if (J.node) {
                return
            }
            var O = R.getZr();
            F(O).records || (F(O).records = {});
            B(O, R);
            var Q = F(O).records[N] || (F(O).records[N] = {});
            Q.handler = P
        };

        function B(N, O) {
            if (F(N).initialized) {
                return
            }
            F(N).initialized = true;
            P("click", C.curry(E, "click"));
            P("mousemove", C.curry(E, "mousemove"));
            P("globalout", G);

            function P(R, Q) {
                N.on(R, function(T) {
                    var S = L(O);
                    A(F(N).records, function(U) {
                        U && Q(U, T, S.dispatchAction)
                    });
                    I(S.pendings, O)
                })
            }
        }

        function I(Q, R) {
            var P = Q.showTip.length;
            var N = Q.hideTip.length;
            var O;
            if (P) {
                O = Q.showTip[P - 1]
            } else {
                if (N) {
                    O = Q.hideTip[N - 1]
                }
            }
            if (O) {
                O.dispatchAction = null;
                R.dispatchAction(O)
            }
        }

        function G(O, N, P) {
            O.handler("leave", null, P)
        }

        function E(Q, O, N, P) {
            O.handler(Q, N, P)
        }

        function L(P) {
            var N = {showTip: [], hideTip: []};
            var O = function(R) {
                var Q = N[R.type];
                if (Q) {
                    Q.push(R)
                } else {
                    R.dispatchAction = O;
                    P.dispatchAction(R)
                }
            };
            return {dispatchAction: O, pendings: N}
        }

        H.unregister = function(N, Q) {
            if (J.node) {
                return
            }
            var O = Q.getZr();
            var P = (F(O).records || {})[N];
            if (P) {
                F(O).records[N] = null
            }
        };
        K.exports = H
    }, function(K, L, E) {
        var G = E(18);
        var D = E(305);
        var J = E(306);
        var H = E(138);
        var C = E(136);
        var A = D.extend({
            makeElOption: function(Y, S, Q, P, W) {
                var O = Q.axis;
                var X = O.grid;
                var N = P.get("type");
                var V = B(X, O).getOtherAxis(O).getGlobalExtent();
                var U = O.toGlobalCoord(O.dataToCoord(S, true));
                if (N && N !== "none") {
                    var M = J.buildElStyle(P);
                    var R = F[N](O, U, V, M);
                    R.style = M;
                    Y.graphicKey = R.type;
                    Y.pointer = R
                }
                var T = H.layout(X.model, Q);
                J.buildCartesianSingleLabelElOption(S, Y, T, Q, P, W)
            }, getHandleTransform: function(O, M, N) {
                var P = H.layout(M.axis.grid.model, M, {labelInside: false});
                P.labelMargin = N.get("handle.margin");
                return {position: J.getTransformedPosition(M.axis, O, P), rotation: P.rotation + (P.labelDirection < 0 ? Math.PI : 0)}
            }, updateHandleTransform: function(T, W, P, O) {
                var N = P.axis;
                var X = N.grid;
                var U = N.getGlobalExtent(true);
                var V = B(X, N).getOtherAxis(N).getGlobalExtent();
                var Q = N.dim === "x" ? 0 : 1;
                var M = T.position;
                M[Q] += W[Q];
                M[Q] = Math.min(U[1], M[Q]);
                M[Q] = Math.max(U[0], M[Q]);
                var R = (V[1] + V[0]) / 2;
                var Y = [R, R];
                Y[Q] = M[Q];
                var S = [{verticalAlign: "middle"}, {align: "center"}];
                return {position: M, rotation: T.rotation, cursorPoint: Y, tooltipOption: S[Q]}
            }
        });

        function B(O, N) {
            var M = {};
            M[N.dim + "AxisIndex"] = N.index;
            return O.getCartesian(M)
        }

        var F = {
            line: function(Q, O, N, M) {
                var P = J.makeLineShape([O, N[0]], [O, N[1]], I(Q));
                G.subPixelOptimizeLine({shape: P, style: M});
                return {type: "Line", shape: P}
            }, shadow: function(R, P, O, N) {
                var Q = R.getBandWidth();
                var M = O[1] - O[0];
                return {type: "Rect", shape: J.makeRectShape([P - Q / 2, O[0]], [Q, M], I(R))}
            }
        };

        function I(M) {
            return M.dim === "x" ? 0 : 1
        }

        C.registerAxisPointerClass("CartesianAxisPointer", A);
        K.exports = A
    }, function(O, F, Q) {
        var D = Q(4);
        var E = Q(13);
        var J = Q(18);
        var I = Q(5).makeGetter();
        var K = Q(137);
        var P = Q(88);
        var C = Q(81);
        var H = D.clone;
        var B = D.bind;

        function G() {
        }

        G.prototype = {
            _group: null,
            _lastGraphicKey: null,
            _handle: null,
            _dragging: false,
            _lastValue: null,
            _lastStatus: null,
            _payloadInfo: null,
            animationThreshold: 15,
            render: function(V, U, c, d) {
                var X = U.get("value");
                var b = U.get("status");
                this._axisModel = V;
                this._axisPointerModel = U;
                this._api = c;
                if (!d && this._lastValue === X && this._lastStatus === b) {
                    return
                }
                this._lastValue = X;
                this._lastStatus = b;
                var Y = this._group;
                var W = this._handle;
                if (!b || b === "hide") {
                    Y && Y.hide();
                    W && W.hide();
                    return
                }
                Y && Y.show();
                W && W.show();
                var a = {};
                this.makeElOption(a, X, V, U, c);
                var Z = a.graphicKey;
                if (Z !== this._lastGraphicKey) {
                    this.clear(c)
                }
                this._lastGraphicKey = Z;
                var T = this._moveAnimation = this.determineAnimation(V, U);
                if (!Y) {
                    Y = this._group = new J.Group();
                    this.createPointerEl(Y, a, V, U);
                    this.createLabelEl(Y, a, V, U);
                    c.getZr().add(Y)
                } else {
                    var e = D.curry(N, U, T);
                    this.updatePointerEl(Y, a, e, U);
                    this.updateLabelEl(Y, a, e, U)
                }
                L(Y, U, true);
                this._renderHandle(X)
            },
            remove: function(T) {
                this.clear(T)
            },
            dispose: function(T) {
                this.clear(T)
            },
            determineAnimation: function(X, W) {
                var b = W.get("animation");
                var V = X.axis;
                var U = V.type === "category";
                var Y = W.get("snap");
                if (!Y && !U) {
                    return false
                }
                if (b === "auto" || b == null) {
                    var a = this.animationThreshold;
                    if (U && V.getBandWidth() > a) {
                        return true
                    }
                    if (Y) {
                        var T = K.getAxisInfo(X).seriesDataCount;
                        var Z = V.getExtent();
                        return Math.abs(Z[0] - Z[1]) / T > a
                    }
                    return false
                }
                return b === true
            },
            makeElOption: function(T, W, U, V, X) {
            },
            createPointerEl: function(U, T, W, X) {
                var V = T.pointer;
                if (V) {
                    var Y = I(U).pointerEl = new J[V.type](H(T.pointer));
                    U.add(Y)
                }
            },
            createLabelEl: function(U, T, V, W) {
                if (T.label) {
                    var X = I(U).labelEl = new J.Rect(H(T.label));
                    U.add(X);
                    S(X, W)
                }
            },
            updatePointerEl: function(U, T, W) {
                var V = I(U).pointerEl;
                if (V) {
                    V.setStyle(T.pointer.style);
                    W(V, {shape: T.pointer.shape})
                }
            },
            updateLabelEl: function(U, T, X, W) {
                var V = I(U).labelEl;
                if (V) {
                    V.setStyle(T.label.style);
                    X(V, {shape: T.label.shape, position: T.label.position});
                    S(V, W)
                }
            },
            _renderHandle: function(X) {
                if (this._dragging || !this.updateHandleTransform) {
                    return
                }
                var U = this._axisPointerModel;
                var Z = this._api.getZr();
                var W = this._handle;
                var T = U.getModel("handle");
                var a = U.get("status");
                if (!T.get("show") || !a || a === "hide") {
                    W && Z.remove(W);
                    this._handle = null;
                    return
                }
                var V;
                if (!this._handle) {
                    V = true;
                    W = this._handle = R(T, {
                        onmousemove: function(c) {
                            P.stop(c.event)
                        },
                        onmousedown: B(this._onHandleDragMove, this, 0, 0),
                        drift: B(this._onHandleDragMove, this),
                        ondragend: B(this._onHandleDragEnd, this)
                    });
                    Z.add(W)
                }
                L(W, U, false);
                var b = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
                W.setStyle(T.getItemStyle(null, b));
                var Y = T.get("size");
                if (!D.isArray(Y)) {
                    Y = [Y, Y]
                }
                W.attr("scale", [Y[0] / 2, Y[1] / 2]);
                C.createOrUpdate(this, "_doDispatchAxisPointer", T.get("throttle") || 0, "fixRate");
                this._moveHandleToValue(X, V)
            },
            _moveHandleToValue: function(T, U) {
                N(this._axisPointerModel, !U && this._moveAnimation, this._handle, M(this.getHandleTransform(T, this._axisModel, this._axisPointerModel)))
            },
            _onHandleDragMove: function(U, W) {
                var T = this._handle;
                if (!T) {
                    return
                }
                this._dragging = true;
                var V = this.updateHandleTransform(M(T), [U, W], this._axisModel, this._axisPointerModel);
                this._payloadInfo = V;
                T.stopAnimation();
                T.attr(M(V));
                I(T).lastProp = null;
                this._doDispatchAxisPointer()
            },
            _doDispatchAxisPointer: function() {
                var T = this._handle;
                if (!T) {
                    return
                }
                var V = this._payloadInfo;
                var U = this._axisModel;
                this._api.dispatchAction({
                    type: "updateAxisPointer",
                    x: V.cursorPoint[0],
                    y: V.cursorPoint[1],
                    tooltipOption: V.tooltipOption,
                    axesInfo: [{axisDim: U.axis.dim, axisIndex: U.componentIndex}]
                })
            },
            _onHandleDragEnd: function(T) {
                this._dragging = false;
                var U = this._handle;
                if (!U) {
                    return
                }
                var V = this._axisPointerModel.get("value");
                this._moveHandleToValue(V);
                this._api.dispatchAction({type: "hideTip"})
            },
            getHandleTransform: null,
            updateHandleTransform: null,
            clear: function(W) {
                this._lastValue = null;
                this._lastStatus = null;
                var U = W.getZr();
                var V = this._group;
                var T = this._handle;
                if (U && V) {
                    this._lastGraphicKey = null;
                    V && U.remove(V);
                    T && U.remove(T);
                    this._group = null;
                    this._handle = null;
                    this._payloadInfo = null
                }
            },
            doClear: function() {
            },
            buildLabel: function(T, V, U) {
                U = U || 0;
                return {x: T[U], y: T[1 - U], width: V[U], height: V[1 - U]}
            }
        };
        G.prototype.constructor = G;

        function N(W, T, U, V) {
            if (!A(I(U).lastProp, V)) {
                I(U).lastProp = V;
                T ? J.updateProps(U, V, W) : (U.stopAnimation(), U.attr(V))
            }
        }

        function A(T, U) {
            if (D.isObject(T) && D.isObject(U)) {
                var V = true;
                D.each(U, function(X, W) {
                    V &= A(T[W], X)
                });
                return !!V
            } else {
                return T === U
            }
        }

        function S(T, U) {
            T[U.get("label.show") ? "show" : "hide"]()
        }

        function M(T) {
            return {position: T.position.slice(), rotation: T.rotation || 0}
        }

        function R(W, X) {
            var U = W.get("icon");
            var V = {x: -1, y: -1, width: 2, height: 2};
            var T = D.extend({style: {strokeNoScale: true}, rectHover: true, cursor: "move", draggable: true}, X);
            return U.indexOf("image://") === 0 ? (V.image = U.slice(8), T.style = V, new J.Image(T)) : J.makePath(U.replace("path://", ""), T, V, "center")
        }

        function L(T, V, X) {
            var U = V.get("z");
            var W = V.get("zlevel");
            T && T.traverse(function(Y) {
                if (Y.type !== "group") {
                    U != null && (Y.z = U);
                    W != null && (Y.zlevel = W);
                    Y.silent = X
                }
            })
        }

        E.enableClassExtend(G);
        O.exports = G
    }, function(J, L, D) {
        var B = D(4);
        var F = D(18);
        var H = D(8);
        var C = D(6);
        var E = D(11);
        var G = D(101);
        var A = D(135);
        var I = {};
        I.buildElStyle = function(N) {
            var M = N.get("type");
            var O = N.getModel(M + "Style");
            var P;
            if (M === "line") {
                P = O.getLineStyle();
                P.fill = null
            } else {
                if (M === "shadow") {
                    P = O.getAreaStyle();
                    P.stroke = null
                }
            }
            return P
        };
        I.buildLabelElOption = function(R, V, a, U, O) {
            var b = a.get("value");
            var M = I.getValueLabel(b, V.axis, V.ecModel, a.get("seriesDataIndices"), {
                precision: a.get("label.precision"),
                formatter: a.get("label.formatter")
            });
            var N = a.getModel("label");
            var P = N.getModel("textStyle");
            var X = C.normalizeCssArray(N.get("padding") || 0);
            var S = P.getFont();
            var d = H.getBoundingRect(M, S, O.textAlign, O.textBaseline);
            var Z = O.position;
            var W = d.width + X[1] + X[3];
            var c = d.height + X[0] + X[2];
            var Q = O.align;
            Q === "right" && (Z[0] -= W);
            Q === "center" && (Z[0] -= W / 2);
            var Y = O.verticalAlign;
            Y === "bottom" && (Z[1] -= c);
            Y === "middle" && (Z[1] -= c / 2);
            K(Z, W, c, U);
            var T = N.get("backgroundColor");
            if (!T || T === "auto") {
                T = V.get("axisLine.lineStyle.color")
            }
            R.label = {
                shape: {x: 0, y: 0, width: W, height: c, r: N.get("borderRadius")},
                position: Z.slice(),
                style: {
                    text: M,
                    textFont: S,
                    textFill: P.getTextColor(),
                    textPosition: "inside",
                    fill: T,
                    stroke: N.get("borderColor") || "transparent",
                    lineWidth: N.get("borderWidth") || 0,
                    shadowBlur: N.get("shadowBlur"),
                    shadowColor: N.get("shadowColor"),
                    shadowOffsetX: N.get("shadowOffsetX"),
                    shadowOffsetY: N.get("shadowOffsetY")
                },
                z2: 10
            }
        };

        function K(P, Q, N, R) {
            var O = R.getWidth();
            var M = R.getHeight();
            P[0] = Math.min(P[0] + Q, O) - Q;
            P[1] = Math.min(P[1] + N, M) - N;
            P[0] = Math.max(P[0], 0);
            P[1] = Math.max(P[1], 0)
        }

        I.getValueLabel = function(O, M, T, S, N) {
            var R = M.scale.getLabel(O, {precision: N.precision});
            var P = N.formatter;
            if (P) {
                var Q = {value: G.getAxisRawValue(M, O), seriesData: []};
                B.each(S, function(W) {
                    var X = T.getSeriesByIndex(W.seriesIndex);
                    var V = W.dataIndexInside;
                    var U = X && X.getDataParams(V);
                    U && Q.seriesData.push(U)
                });
                if (B.isString(P)) {
                    R = P.replace("{value}", R)
                } else {
                    if (B.isFunction(P)) {
                        R = P(Q)
                    }
                }
            }
            return R
        };
        I.getTransformedPosition = function(P, O, M) {
            var N = E.create();
            E.rotate(N, N, M.rotation);
            E.translate(N, N, M.position);
            return F.applyTransform([P.dataToCoord(O), (M.labelOffset || 0) + (M.labelDirection || 1) * (M.labelMargin || 0)], N)
        };
        I.buildCartesianSingleLabelElOption = function(Q, M, S, N, O, R) {
            var P = A.innerTextLayout(S.rotation, 0, S.labelDirection);
            S.labelMargin = O.get("label.margin");
            I.buildLabelElOption(M, N, O, R, {
                position: I.getTransformedPosition(N.axis, Q, S),
                align: P.textAlign,
                verticalAlign: P.textVerticalAlign
            })
        };
        I.makeLineShape = function(N, O, M) {
            M = M || 0;
            return {x1: N[M], y1: N[1 - M], x2: O[M], y2: O[1 - M]}
        };
        I.makeRectShape = function(M, O, N) {
            N = N || 0;
            return {x: M[N], y: M[1 - N], width: O[N], height: O[1 - N]}
        };
        I.makeSectorShape = function(R, M, Q, N, P, O) {
            return {cx: R, cy: M, r0: Q, r: N, startAngle: P, endAngle: O, clockwise: true}
        };
        J.exports = I
    }, function(M, N, F) {
        var H = F(18);
        var E = F(305);
        var J = F(306);
        var L = F(296);
        var D = F(136);
        var B = ["x", "y"];
        var I = ["width", "height"];
        var K = E.extend({
            makeElOption: function(a, U, S, R, Z) {
                var Q = S.axis;
                var Y = Q.coordinateSystem;
                var X = C(Y, 1 - A(Q));
                var W = Y.dataToPoint(U)[0];
                var P = R.get("type");
                if (P && P !== "none") {
                    var O = J.buildElStyle(R);
                    var T = G[P](Q, W, X, O);
                    T.style = O;
                    a.graphicKey = T.type;
                    a.pointer = T
                }
                var V = L.layout(S);
                J.buildCartesianSingleLabelElOption(U, a, V, S, R, Z)
            }, getHandleTransform: function(Q, O, P) {
                var R = L.layout(O, {labelInside: false});
                R.labelMargin = P.get("handle.margin");
                return {position: J.getTransformedPosition(O.axis, Q, R), rotation: R.rotation + (R.labelDirection < 0 ? Math.PI : 0)}
            }, updateHandleTransform: function(T, X, R, Q) {
                var P = R.axis;
                var Y = P.coordinateSystem;
                var W = A(P);
                var V = C(Y, W);
                var O = T.position;
                O[W] += X[W];
                O[W] = Math.min(V[1], O[W]);
                O[W] = Math.max(V[0], O[W]);
                var U = C(Y, 1 - W);
                var S = (U[1] + U[0]) / 2;
                var Z = [S, S];
                Z[W] = O[W];
                return {position: O, rotation: T.rotation, cursorPoint: Z, tooltipOption: {verticalAlign: "middle"}}
            }
        });
        var G = {
            line: function(S, Q, P, O) {
                var R = J.makeLineShape([Q, P[0]], [Q, P[1]], A(S));
                H.subPixelOptimizeLine({shape: R, style: O});
                return {type: "Line", shape: R}
            }, shadow: function(T, R, Q, P) {
                var S = T.getBandWidth();
                var O = Q[1] - Q[0];
                return {type: "Rect", shape: J.makeRectShape([R - S / 2, Q[0]], [S, O], A(T))}
            }
        };

        function A(O) {
            return O.isHorizontal() ? 0 : 1
        }

        function C(P, O) {
            var Q = P.getRect();
            return [Q[B[O]], Q[B[O]] + Q[I[O]]]
        }

        D.registerAxisPointerClass("SingleAxisPointer", K);
        M.exports = K
    }, function(J, L, C) {
        var A = C(110);
        var G = C(78);
        var K = C(98);
        var B = C(4);
        var F = C(6);
        var H = F.encodeHTML;
        var D = C(255);
        var I = 2;
        var E = G.extend({
            type: "series.themeRiver",
            dependencies: ["singleAxis"],
            nameMap: null,
            init: function(M) {
                E.superApply(this, "init", arguments);
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
            },
            fixData: function(a) {
                var V = a.length;
                var T = D().key(function(d) {
                    return d[2]
                }).entries(a);
                var X = B.map(T, function(e) {
                    return {name: e.key, dataList: e.values}
                });
                var U = X.length;
                var Y = -1;
                var P = -1;
                for (var S = 0; S < U; ++S) {
                    var N = X[S].dataList.length;
                    if (N > Y) {
                        Y = N;
                        P = S
                    }
                }
                for (var R = 0; R < U; ++R) {
                    if (R === P) {
                        continue
                    }
                    var Z = X[R].name;
                    for (var Q = 0; Q < Y; ++Q) {
                        var O = X[P].dataList[Q][0];
                        var M = X[R].dataList.length;
                        var W = -1;
                        for (var c = 0; c < M; ++c) {
                            var b = X[R].dataList[c][0];
                            if (b === O) {
                                W = c;
                                break
                            }
                        }
                        if (W === -1) {
                            a[V] = [];
                            a[V][0] = O;
                            a[V][1] = 0;
                            a[V][2] = Z;
                            V++
                        }
                    }
                }
                return a
            },
            getInitialData: function(W, V) {
                var M = [];
                var Q = V.queryComponents({mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId")})[0];
                var N = Q.get("type");
                M = [{name: "time", type: N === "category" ? "ordinal" : N === "time" ? "time" : "float"}, {name: "value", type: "float"}, {
                    name: "name",
                    type: "ordinal"
                }];
                var S = B.filter(W.data, function(Y) {
                    return Y[2] !== undefined
                });
                var P = this.fixData(S || []);
                var R = [];
                var U = this.nameMap = B.createHashMap();
                var O = 0;
                for (var T = 0; T < P.length; ++T) {
                    R.push(P[T][I]);
                    if (!U.get(P[T][I])) {
                        U.set(P[T][I], O);
                        O++
                    }
                }
                M = A(M, P);
                var X = new K(M, this);
                X.initData(P, R);
                return X
            },
            coordDimToDataDim: function(M) {
                return ["time"]
            },
            getLayerSeries: function() {
                var N = this.getData();
                var S = N.count();
                var Q = [];
                for (var P = 0; P < S; ++P) {
                    Q[P] = P
                }
                var R = D().key(function(U) {
                    return N.get("name", U)
                }).entries(Q);
                var T = B.map(R, function(U) {
                    return {name: U.key, indices: U.values}
                });
                for (var O = 0; O < T.length; ++O) {
                    T[O].indices.sort(M)
                }

                function M(V, U) {
                    return N.get("time", V) - N.get("time", U)
                }

                return T
            },
            getAxisTooltipData: function(S, Q, Y) {
                if (!B.isArray(S)) {
                    S = S ? [S] : []
                }
                var P = this.getData();
                var a = this.getLayerSeries();
                var T = [];
                var O = a.length;
                var X;
                for (var V = 0; V < O; ++V) {
                    var U = Number.MAX_VALUE;
                    var M = -1;
                    var Z = a[V].indices.length;
                    for (var R = 0; R < Z; ++R) {
                        var N = P.get(S[0], a[V].indices[R]);
                        var W = Math.abs(N - Q);
                        if (W <= U) {
                            X = N;
                            U = W;
                            M = a[V].indices[R]
                        }
                    }
                    T.push(M)
                }
                return {dataIndices: T, nestestValue: X}
            },
            formatTooltip: function(M) {
                var P = this.getData();
                var N = P.get("name", M);
                var O = P.get("value", M);
                if (isNaN(O) || O == null) {
                    O = "-"
                }
                return H(N + " : " + O)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "singleAxis",
                boundaryGap: ["10%", "10%"],
                singleAxisIndex: 0,
                animationEasing: "linear",
                label: {
                    normal: {margin: 4, textAlign: "right", show: true, position: "left", textStyle: {color: "#000", fontSize: 11}},
                    emphasis: {show: true}
                }
            }
        });
        J.exports = E
    }, function(B, C, A) {
        (function(H) {
            var E = A(120);
            var D = A(18);
            var G = A(4);
            var I = A(99);
            B.exports = A(1).extendChartView({
                type: "themeRiver", init: function() {
                    this._layers = []
                }, render: function(W, S, T) {
                    var M = W.getData();
                    var J = W.getRawData();
                    if (!M.count()) {
                        return
                    }
                    var P = this.group;
                    var V = W.getLayerSeries();
                    var O = M.getLayout("layoutInfo");
                    var L = O.rect;
                    var R = O.boundaryGap;
                    P.attr("position", [0, L.y + R[0]]);

                    function N(X) {
                        return X.name
                    }

                    var K = new I(this._layersSeries || [], V, N, N);
                    var Q = {};
                    K.add(G.bind(G.curry(U, "add"), this)).update(G.bind(G.curry(U, "update"), this)).remove(G.bind(G.curry(U, "remove"), this)).execute();

                    function U(o, t, d) {
                        var f = this._layers;
                        if (o === "remove") {
                            P.remove(f[t]);
                            return
                        }
                        var l = [];
                        var k = [];
                        var Y;
                        var q = V[t].indices;
                        for (var Z = 0; Z < q.length; Z++) {
                            var h = M.getItemLayout(q[Z]);
                            var r = h.x;
                            var e = h.y0;
                            var s = h.y;
                            l.push([r, e]);
                            k.push([r, e + s]);
                            Y = J.getItemVisual(q[Z], "color")
                        }
                        var c;
                        var i;
                        var n = M.getItemLayout(q[0]);
                        var a = M.getItemModel(q[Z - 1]);
                        var X = a.getModel("label.normal");
                        var g = X.get("margin");
                        if (o === "add") {
                            var p = Q[t] = new D.Group();
                            c = new E.Polygon({
                                shape: {points: l, stackedOnPoints: k, smooth: 0.4, stackedOnSmooth: 0.4, smoothConstraint: false},
                                z2: 0
                            });
                            i = new D.Text({style: {x: n.x - g, y: n.y0 + n.y / 2}});
                            p.add(c);
                            p.add(i);
                            P.add(p);
                            c.setClipPath(F(c.getBoundingRect(), W, function() {
                                c.removeClipPath()
                            }))
                        } else {
                            var p = f[d];
                            c = p.childAt(0);
                            i = p.childAt(1);
                            P.add(p);
                            Q[t] = p;
                            D.updateProps(c, {shape: {points: l, stackedOnPoints: k}}, W);
                            D.updateProps(i, {style: {x: n.x - g, y: n.y0 + n.y / 2}}, W)
                        }
                        var m = a.getModel("itemStyle.emphasis");
                        var u = a.getModel("itemStyle.normal");
                        var b = X.getModel("textStyle");
                        i.setStyle({
                            text: X.get("show") ? W.getFormattedLabel(q[Z - 1], "normal") || M.getName(q[Z - 1]) : "",
                            textFont: b.getFont(),
                            textAlign: X.get("textAlign"),
                            textVerticalAlign: "middle"
                        });
                        c.setStyle(G.extend({fill: Y}, u.getItemStyle(["color"])));
                        D.setHoverStyle(c, m.getItemStyle())
                    }

                    this._layersSeries = V;
                    this._layers = Q
                }, dispose: function() {
                }
            });

            function F(L, K, J) {
                var M = new D.Rect({shape: {x: L.x - 10, y: L.y - 10, width: 0, height: L.height + 20}});
                D.initProps(M, {shape: {width: L.width + 20, height: L.height + 20}}, K, J);
                return M
            }
        }.call(C, A(310)))
    }, function(N, G) {
        var C = N.exports = {};
        var E;
        var H;

        function M() {
            throw new Error("setTimeout has not been defined")
        }

        function L() {
            throw new Error("clearTimeout has not been defined")
        }

        (function() {
            try {
                if (typeof setTimeout === "function") {
                    E = setTimeout
                } else {
                    E = M
                }
            } catch (R) {
                E = M
            }
            try {
                if (typeof clearTimeout === "function") {
                    H = clearTimeout
                } else {
                    H = L
                }
            } catch (R) {
                H = L
            }
        }());

        function F(R) {
            if (E === setTimeout) {
                return setTimeout(R, 0)
            }
            if ((E === M || !E) && setTimeout) {
                E = setTimeout;
                return setTimeout(R, 0)
            }
            try {
                return E(R, 0)
            } catch (S) {
                try {
                    return E.call(null, R, 0)
                } catch (S) {
                    return E.call(this, R, 0)
                }
            }
        }

        function B(S) {
            if (H === clearTimeout) {
                return clearTimeout(S)
            }
            if ((H === L || !H) && clearTimeout) {
                H = clearTimeout;
                return clearTimeout(S)
            }
            try {
                return H(S)
            } catch (R) {
                try {
                    return H.call(null, S)
                } catch (R) {
                    return H.call(this, S)
                }
            }
        }

        var K = [];
        var Q = false;
        var O;
        var D = -1;

        function J() {
            if (!Q || !O) {
                return
            }
            Q = false;
            if (O.length) {
                K = O.concat(K)
            } else {
                D = -1
            }
            if (K.length) {
                P()
            }
        }

        function P() {
            if (Q) {
                return
            }
            var R = F(J);
            Q = true;
            var S = K.length;
            while (S) {
                O = K;
                K = [];
                while (++D < S) {
                    if (O) {
                        O[D].run()
                    }
                }
                D = -1;
                S = K.length
            }
            O = null;
            Q = false;
            B(R)
        }

        C.nextTick = function(S) {
            var T = new Array(arguments.length - 1);
            if (arguments.length > 1) {
                for (var R = 1; R < arguments.length; R++) {
                    T[R - 1] = arguments[R]
                }
            }
            K.push(new A(S, T));
            if (K.length === 1 && !Q) {
                F(P)
            }
        };

        function A(S, R) {
            this.fun = S;
            this.array = R
        }

        A.prototype.run = function() {
            this.fun.apply(null, this.array)
        };
        C.title = "browser";
        C.browser = true;
        C.env = {};
        C.argv = [];
        C.version = "";
        C.versions = {};

        function I() {
        }

        C.on = I;
        C.addListener = I;
        C.once = I;
        C.off = I;
        C.removeListener = I;
        C.removeAllListeners = I;
        C.emit = I;
        C.binding = function(R) {
            throw new Error("process.binding is not supported")
        };
        C.cwd = function() {
            return "/"
        };
        C.chdir = function(R) {
            throw new Error("process.chdir is not supported")
        };
        C.umask = function() {
            return 0
        }
    }, function(D, F, C) {
        var B = C(4);
        var G = C(7);
        D.exports = function(H, I) {
            H.eachSeriesByType("themeRiver", function(R) {
                var M = R.getData();
                var Q = R.coordinateSystem;
                var N = {};
                var L = Q.getRect();
                N.rect = L;
                var P = R.get("boundaryGap");
                var J = Q.getAxis();
                N.boundaryGap = P;
                if (J.orient === "horizontal") {
                    P[0] = G.parsePercent(P[0], L.height);
                    P[1] = G.parsePercent(P[1], L.height);
                    var K = L.height - P[0] - P[1];
                    E(M, R, K)
                } else {
                    P[0] = G.parsePercent(P[0], L.width);
                    P[1] = G.parsePercent(P[1], L.width);
                    var O = L.width - P[0] - P[1];
                    E(M, R, O)
                }
                M.setLayout("layoutInfo", N)
            })
        };

        function E(L, U, K) {
            if (!L.count()) {
                return
            }
            var S = U.coordinateSystem;
            var T = U.getLayerSeries();
            var J = B.map(T, function(V) {
                return B.map(V.indices, function(X) {
                    var W = S.dataToPoint(L.get("time", X));
                    W[1] = L.get("value", X);
                    return W
                })
            });
            var R = A(J);
            var O = R.y0;
            var H = K / R.max;
            var P = T.length;
            var I = T[0].indices.length;
            var Q;
            for (var M = 0; M < I; ++M) {
                Q = O[M] * H;
                L.setItemLayout(T[0].indices[M], {layerIndex: 0, x: J[0][M][0], y0: Q, y: J[0][M][1] * H});
                for (var N = 1; N < P; ++N) {
                    Q += J[N - 1][M][1] * H;
                    L.setItemLayout(T[N].indices[M], {layerIndex: N, x: J[N][M][0], y0: Q, y: J[N][M][1] * H})
                }
            }
        }

        function A(K) {
            var J = K.length;
            var S = K[0].length;
            var I = [];
            var L = [];
            var T = 0;
            var O;
            var Q = {};
            for (var P = 0; P < S; ++P) {
                for (var R = 0, O = 0; R < J; ++R) {
                    O += K[R][P][1]
                }
                if (O > T) {
                    T = O
                }
                I.push(O)
            }
            for (var M = 0; M < S; ++M) {
                L[M] = (T - I[M]) / 2
            }
            T = 0;
            for (var H = 0; H < S; ++H) {
                var N = I[H] + L[H];
                if (N > T) {
                    T = N
                }
            }
            Q.y0 = L;
            Q.max = T;
            return Q
        }
    }, function(A, B) {
        A.exports = function(C) {
            C.eachSeriesByType("themeRiver", function(D) {
                var G = D.getData();
                var F = D.getRawData();
                var E = D.get("color");
                G.each(function(I) {
                    var H = G.getName(I);
                    var J = E[(D.nameMap.get(H) - 1) % E.length];
                    F.setItemVisual(I, "color", J)
                })
            })
        }
    }, function(Q, H, K) {
        var F = K(1);
        var G = K(4);
        var U = K(18);
        var P = K(118);
        var S = K(109);
        var N = K(145);
        var D = ["itemStyle", "normal"];
        var R = ["itemStyle", "emphasis"];
        var T = ["label", "normal"];
        var M = ["label", "emphasis"];
        var I = {cartesian2d: K(314), geo: K(315), singleAxis: K(316), polar: K(317), calendar: K(318)};
        F.extendSeriesModel({
            type: "series.custom",
            dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
            defaultOption: {coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: true},
            getInitialData: function(V, W) {
                return S(V.data, this, W)
            }
        });
        F.extendChartView({
            type: "custom", _data: null, render: function(X, W, a) {
                var V = this._data;
                var b = X.getData();
                var Z = this.group;
                var Y = E(X, b, W, a);
                b.diff(V).add(function(c) {
                    b.hasValue(c) && A(null, c, Y(c), X, Z, b)
                }).update(function(d, e) {
                    var c = V.getItemGraphicEl(e);
                    b.hasValue(d) ? A(c, d, Y(d), X, Z, b) : (c && Z.remove(c))
                }).remove(function(d) {
                    var c = V.getItemGraphicEl(d);
                    c && Z.remove(c)
                }).execute();
                this._data = b
            }, dispose: G.noop
        });

        function C(V) {
            var W = V.type;
            var X;
            if (W === "path") {
                var Z = V.shape;
                X = U.makePath(Z.pathData, null, {x: Z.x || 0, y: Z.y || 0, width: Z.width || 0, height: Z.height || 0}, "center");
                X.__customPathData = V.pathData
            } else {
                if (W === "image") {
                    X = new U.Image({});
                    X.__customImagePath = V.style.image
                } else {
                    if (W === "text") {
                        X = new U.Text({});
                        X.__customText = V.style.text
                    } else {
                        var Y = U[W.charAt(0).toUpperCase() + W.slice(1)];
                        if (true) {
                            G.assert(Y, 'graphic type "' + W + '" can not be found.')
                        }
                        X = new Y()
                    }
                }
            }
            X.__customGraphicType = W;
            return X
        }

        function J(Z, b, e, Y, X, W) {
            var a = {};
            var d = e.style || {};
            e.shape && (a.shape = G.clone(e.shape));
            e.position && (a.position = e.position.slice());
            e.scale && (a.scale = e.scale.slice());
            e.origin && (a.origin = e.origin.slice());
            e.rotation && (a.rotation = e.rotation);
            if (Z.type === "image" && e.style) {
                var V = a.style = {};
                G.each(["x", "y", "width", "height"], function(f) {
                    L(f, V, d, Z.style, W)
                })
            }
            if (Z.type === "text" && e.style) {
                var V = a.style = {};
                G.each(["x", "y"], function(f) {
                    L(f, V, d, Z.style, W)
                })
            }
            if (Z.type !== "group") {
                Z.useStyle(d);
                if (W) {
                    Z.style.opacity = 0;
                    var c = d.opacity;
                    c == null && (c = 1);
                    U.initProps(Z, {style: {opacity: c}}, Y, b)
                }
            }
            if (W) {
                Z.attr(a)
            } else {
                U.updateProps(Z, a, Y, b)
            }
            Z.attr({z2: e.z2 || 0, silent: e.silent});
            e.styleEmphasis !== false && U.setHoverStyle(Z, e.styleEmphasis)
        }

        function L(X, Z, Y, W, V) {
            if (Y[X] != null && !V) {
                Z[X] = Y[X];
                Y[X] = W[X]
            }
        }

        function E(f, n, X, e) {
            var l = f.get("renderItem");
            var g = f.coordinateSystem;
            if (true) {
                G.assert(l, "series.render is required.");
                G.assert(g.prepareCustoms || I[g.type], "This coordSys does not support custom series.")
            }
            var o = g.prepareCustoms ? g.prepareCustoms() : I[g.type](g);
            var h = G.defaults({
                getWidth: e.getWidth,
                getHeight: e.getHeight,
                getZr: e.getZr,
                getDevicePixelRatio: e.getDevicePixelRatio,
                value: p,
                style: d,
                styleEmphasis: a,
                visual: Z,
                barLayout: k,
                currentSeriesIndices: b,
                font: c
            }, o.api);
            var j = {
                context: {},
                seriesId: f.id,
                seriesName: f.name,
                seriesIndex: f.seriesIndex,
                coordSys: o.coordSys,
                dataInsideLength: n.count(),
                encode: B(f.getData())
            };
            var s;
            var W = true;
            var Y;
            var r;
            var m;
            var V;
            var q;
            return function(t) {
                s = t;
                W = true;
                return l && l(G.defaults({dataIndexInside: t, dataIndex: n.getRawIndex(t)}, j), h) || {}
            };

            function i(t) {
                t == null && (t = s);
                if (W) {
                    Y = n.getItemModel(t);
                    r = Y.getModel(T);
                    m = Y.getModel(M);
                    V = P.findLabelValueDim(n);
                    q = n.getItemVisual(t, "color");
                    W = false
                }
            }

            function p(t, u) {
                u == null && (u = s);
                return n.get(n.getDimension(t || 0), u)
            }

            function d(u, w) {
                w == null && (w = s);
                i(w);
                var v = Y.getModel(D).getItemStyle();
                q != null && (v.fill = q);
                var t = n.getItemVisual(w, "opacity");
                t != null && (v.opacity = t);
                P.setTextToStyle(n, w, V, v, f, r, q);
                u && G.extend(v, u);
                return v
            }

            function a(t, v) {
                v == null && (v = s);
                i(v);
                var u = Y.getModel(R).getItemStyle();
                P.setTextToStyle(n, v, V, u, f, m, q);
                t && G.extend(u, t);
                return u
            }

            function Z(t, u) {
                u == null && (u = s);
                return n.getItemVisual(u, t)
            }

            function k(t) {
                if (g.getBaseAxis) {
                    var u = g.getBaseAxis();
                    return N.getLayoutOnAxis(G.defaults({axis: u}, t), e)
                }
            }

            function b() {
                return X.getCurrentSeriesIndices()
            }

            function c(t) {
                return U.getFont(t, X)
            }
        }

        function B(W) {
            var V = {};
            G.each(W.dimensions, function(Z, Y) {
                var b = W.getDimensionInfo(Z);
                if (!b.isExtraCoord) {
                    var a = b.coordDim;
                    var X = V[a] = V[a] || [];
                    X[b.coordDimIndex] = Y
                }
            });
            return V
        }

        function A(V, W, X, a, Z, Y) {
            V = O(V, W, X, a, Z, Y);
            V && Y.setItemGraphicEl(W, V)
        }

        function O(Y, a, c, X, Z, W) {
            var b = c.type;
            if (Y && b !== Y.__customGraphicType && (b !== "path" || c.pathData !== Y.__customPathData) && (b !== "image" || c.style.image !== Y.__customImagePath) && (b !== "text" || c.style.text !== Y.__customText)) {
                Z.remove(Y);
                Y = null
            }
            if (b == null) {
                return
            }
            var V = !Y;
            !Y && (Y = C(c));
            J(Y, a, c, X, W, V);
            b === "group" && G.each(c.children, function(d, e) {
                O(Y.childAt(e), a, d, X, Y, W)
            });
            Z.add(Y);
            return Y
        }
    }, function(C, F, B) {
        var A = B(4);

        function D(G, H) {
            H = H || [0, 0];
            return A.map(["x", "y"], function(J, M) {
                var L = this.getAxis(J);
                var K = H[M];
                var I = G[M] / 2;
                return L.type === "category" ? L.getBandWidth() : Math.abs(L.dataToCoord(K - I) - L.dataToCoord(K + I))
            }, this)
        }

        function E(G) {
            var H = G.grid.getRect();
            return {
                coordSys: {type: "cartesian2d", x: H.x, y: H.y, width: H.width, height: H.height},
                api: {coord: A.bind(G.dataToPoint, G), size: A.bind(D, G)}
            }
        }

        C.exports = E
    }, function(C, F, B) {
        var A = B(4);

        function D(G, H) {
            H = H || [0, 0];
            return A.map([0, 1], function(K) {
                var L = H[K];
                var M = G[K] / 2;
                var J = [];
                var I = [];
                J[K] = L - M;
                I[K] = L + M;
                J[1 - K] = I[1 - K] = H[1 - K];
                return Math.abs(this.dataToPoint(J)[K] - this.dataToPoint(I)[K])
            }, this)
        }

        function E(G) {
            var H = G.getBoundingRect();
            return {
                coordSys: {type: "geo", x: H.x, y: H.y, width: H.width, height: H.height},
                api: {coord: A.bind(G.dataToPoint, G), size: A.bind(D, G)}
            }
        }

        C.exports = E
    }, function(C, F, B) {
        var A = B(4);

        function D(G, H) {
            var K = this.getAxis();
            var I = H instanceof Array ? H[0] : H;
            var J = (G instanceof Array ? G[0] : G) / 2;
            return K.type === "category" ? K.getBandWidth() : Math.abs(K.dataToCoord(I - J) - K.dataToCoord(I + J))
        }

        function E(G) {
            var H = G.getRect();
            return {
                coordSys: {type: "singleAxis", x: H.x, y: H.y, width: H.width, height: H.height},
                api: {coord: A.bind(G.dataToPoint, G), size: A.bind(D, G)}
            }
        }

        C.exports = E
    }, function(C, F, B) {
        var A = B(4);

        function D(G, H) {
            return A.map(["Radius", "Angle"], function(L, O) {
                var N = this["get" + L + "Axis"]();
                var M = H[O];
                var I = G[O] / 2;
                var K = "dataTo" + L;
                var J = N.type === "category" ? N.getBandWidth() : Math.abs(N[K](M - I) - N[K](M + I));
                if (L === "Angle") {
                    J = J * Math.PI / 180
                }
                return J
            }, this)
        }

        function E(H) {
            var G = H.getRadiusAxis();
            var J = H.getAngleAxis();
            var I = G.getExtent();
            I[0] > I[1] && I.reverse();
            return {
                coordSys: {type: "polar", cx: H.cx, cy: H.cy, r: I[1], r0: I[0]}, api: {
                    coord: A.bind(function(N) {
                        var L = G.dataToRadius(N[0]);
                        var K = J.dataToAngle(N[1]);
                        var M = H.coordToPoint([L, K]);
                        M.push(L, K * Math.PI / 180);
                        return M
                    }), size: A.bind(D, H)
                }
            }
        }

        C.exports = E
    }, function(C, E, B) {
        var A = B(4);

        function D(F) {
            var G = F.getRect();
            var H = F.getRangeInfo();
            return {
                coordSys: {
                    type: "calendar",
                    x: G.x,
                    y: G.y,
                    width: G.width,
                    height: G.height,
                    cellWidth: F.getCellWidth(),
                    cellHeight: F.getCellHeight(),
                    rangeInfo: {start: H.start, end: H.end, weeks: H.weeks, dayCount: H.allDay}
                }, api: {coord: A.bind(F.dataToPoint, F)}
            }
        }

        C.exports = D
    }, function(N, P, F) {
        var E = F(1);
        var K = F(4);
        var C = F(5);
        var O = F(18);
        var I = F(71);
        E.registerPreprocessor(function(Q) {
            var R = Q.graphic;
            if (K.isArray(R)) {
                if (!R[0] || !R[0].elements) {
                    Q.graphic = [{elements: R}]
                } else {
                    Q.graphic = [Q.graphic[0]]
                }
            } else {
                if (R && !R.elements) {
                    Q.graphic = [{elements: [R]}]
                }
            }
        });
        var L = E.extendComponentModel({
            type: "graphic",
            defaultOption: {elements: [], parentId: null},
            _elOptionsToUpdate: null,
            mergeOption: function(Q) {
                var R = this.option.elements;
                this.option.elements = null;
                L.superApply(this, "mergeOption", arguments);
                this.option.elements = R
            },
            optionUpdated: function(Q, S) {
                var X = this.option;
                var V = (S ? X : Q).elements;
                var W = X.elements = S ? [] : X.elements;
                var Y = [];
                this._flatten(V, Y);
                var T = C.mappingToExists(W, Y);
                C.makeIdAndName(T);
                var R = this._elOptionsToUpdate = [];
                K.each(T, function(b, a) {
                    var Z = b.option;
                    if (true) {
                        K.assert(K.isObject(Z) || b.exist, "Empty graphic option definition")
                    }
                    if (!Z) {
                        return
                    }
                    R.push(Z);
                    D(b, Z);
                    J(W, a, Z);
                    H(W[a], Z)
                }, this);
                for (var U = W.length - 1; U >= 0; U--) {
                    if (W[U] == null) {
                        W.splice(U, 1)
                    } else {
                        delete W[U].$action
                    }
                }
            },
            _flatten: function(R, Q, S) {
                K.each(R, function(T) {
                    if (!T) {
                        return
                    }
                    if (S) {
                        T.parentOption = S
                    }
                    Q.push(T);
                    var U = T.children;
                    if (T.type === "group" && U) {
                        this._flatten(U, Q, T)
                    }
                    delete T.children
                }, this)
            },
            useElOptionsToUpdate: function() {
                var Q = this._elOptionsToUpdate;
                this._elOptionsToUpdate = null;
                return Q
            }
        });
        E.extendComponentView({
            type: "graphic", init: function(Q, R) {
                this._elMap = K.createHashMap();
                this._lastGraphicModel
            }, render: function(R, Q, S) {
                if (R !== this._lastGraphicModel) {
                    this._clear()
                }
                this._lastGraphicModel = R;
                this._updateElements(R, S);
                this._relocate(R, S)
            }, _updateElements: function(R, T) {
                var U = R.useElOptionsToUpdate();
                if (!U) {
                    return
                }
                var S = this._elMap;
                var Q = this.group;
                K.each(U, function(a) {
                    var V = a.$action;
                    var Y = a.id;
                    var b = S.get(Y);
                    var X = a.parentId;
                    var W = X != null ? S.get(X) : Q;
                    if (a.hv && a.hv[1] && a.type === "text") {
                        a.style = K.defaults({textBaseline: "middle"}, a.style);
                        a.style.textVerticalAlign = null
                    }
                    var c = A(a);
                    if (true) {
                        b && K.assert(W === b.parent, "Changing parent is not supported.")
                    }
                    if (!V || V === "merge") {
                        b ? b.attr(c) : G(Y, W, c, S)
                    } else {
                        if (V === "replace") {
                            B(b, S);
                            G(Y, W, c, S)
                        } else {
                            if (V === "remove") {
                                B(b, S)
                            }
                        }
                    }
                    var Z = S.get(Y);
                    if (Z) {
                        Z.__ecGraphicWidth = a.width;
                        Z.__ecGraphicHeight = a.height
                    }
                })
            }, _relocate: function(Q, Y) {
                var W = Q.option.elements;
                var R = this.group;
                var X = this._elMap;
                for (var T = W.length - 1; T >= 0; T--) {
                    var Z = W[T];
                    var S = X.get(Z.id);
                    if (!S) {
                        continue
                    }
                    var U = S.parent;
                    var V = U === R ? {width: Y.getWidth(), height: Y.getHeight()} : {
                        width: U.__ecGraphicWidth || 0,
                        height: U.__ecGraphicHeight || 0
                    };
                    I.positionElement(S, Z, V, null, {hv: Z.hv, boundingMode: Z.bounding})
                }
            }, _clear: function() {
                var Q = this._elMap;
                Q.each(function(R) {
                    B(R, Q)
                });
                this._elMap = K.createHashMap()
            }, dispose: function() {
                this._clear()
            }
        });

        function G(W, Q, S, U) {
            var R = S.type;
            if (true) {
                K.assert(R, "graphic type MUST be set")
            }
            var T = O[R.charAt(0).toUpperCase() + R.slice(1)];
            if (true) {
                K.assert(T, "graphic type can not be found")
            }
            var V = new T(S);
            Q.add(V);
            U.set(W, V);
            V.__ecGraphicId = W
        }

        function B(S, R) {
            var Q = S && S.parent;
            if (Q) {
                S.type === "group" && S.traverse(function(T) {
                    B(T, R)
                });
                R.removeKey(S.__ecGraphicId);
                Q.remove(S)
            }
        }

        function A(Q) {
            Q = K.extend({}, Q);
            K.each(["id", "parentId", "$action", "hv", "bounding"].concat(I.LOCATION_PARAMS), function(R) {
                delete Q[R]
            });
            return Q
        }

        function M(Q, S) {
            var R;
            K.each(S, function(T) {
                Q[T] != null && Q[T] !== "auto" && (R = true)
            });
            return R
        }

        function D(S, R) {
            var T = S.exist;
            R.id = S.keyInfo.id;
            !R.type && T && (R.type = T.type);
            if (R.parentId == null) {
                var Q = R.parentOption;
                if (Q) {
                    R.parentId = Q.id
                } else {
                    if (T) {
                        R.parentId = T.parentId
                    }
                }
            }
            R.parentOption = null
        }

        function J(T, U, S) {
            var Q = K.extend({}, S);
            var W = T[U];
            var R = S.$action || "merge";
            if (R === "merge") {
                if (W) {
                    if (true) {
                        var V = S.type;
                        K.assert(!V || W.type === V, 'Please set $action: "replace" to change `type`')
                    }
                    K.merge(W, Q, true);
                    I.mergeLayoutParam(W, Q, {ignoreSize: true});
                    I.copyLayoutParams(S, W)
                } else {
                    T[U] = Q
                }
            } else {
                if (R === "replace") {
                    T[U] = Q
                } else {
                    if (R === "remove") {
                        W && (T[U] = null)
                    }
                }
            }
        }

        function H(Q, R) {
            if (!Q) {
                return
            }
            Q.hv = R.hv = [M(R, ["left", "right"]), M(R, ["top", "bottom"])];
            if (Q.type === "group") {
                Q.width == null && (Q.width = R.width = 0);
                Q.height == null && (Q.height = R.height = 0)
            }
        }
    }, function(B, C, A) {
        A(124);
        A(304);
        A(298)
    }, function(B, D, A) {
        A(322);
        A(323);
        A(324);
        var C = A(1);
        C.registerProcessor(A(326))
    }, function(E, F, D) {
        var B = D(4);
        var A = D(12);
        var C = D(1).extendComponentModel({
            type: "legend",
            dependencies: ["series"],
            layoutMode: {type: "box", ignoreSize: true},
            init: function(G, I, H) {
                this.mergeDefaultAndTheme(G, H);
                G.selected = G.selected || {}
            },
            mergeOption: function(G) {
                C.superCall(this, "mergeOption", G)
            },
            optionUpdated: function() {
                this._updateData(this.ecModel);
                var H = this._data;
                if (H[0] && this.get("selectedMode") === "single") {
                    var I = false;
                    for (var G = 0; G < H.length; G++) {
                        var J = H[G].get("name");
                        if (this.isSelected(J)) {
                            this.select(J);
                            I = true;
                            break
                        }
                    }
                    !I && this.select(H[0].get("name"))
                }
            },
            _updateData: function(H) {
                var G = B.map(this.get("data") || [], function(J) {
                    if (typeof J === "string" || typeof J === "number") {
                        J = {name: J}
                    }
                    return new A(J, this, this.ecModel)
                }, this);
                this._data = G;
                var I = B.map(H.getSeries(), function(J) {
                    return J.name
                });
                H.eachSeries(function(J) {
                    if (J.legendDataProvider) {
                        var K = J.legendDataProvider();
                        I = I.concat(K.mapArray(K.getName))
                    }
                });
                this._availableNames = I
            },
            getData: function() {
                return this._data
            },
            select: function(I) {
                var J = this.option.selected;
                var G = this.get("selectedMode");
                if (G === "single") {
                    var H = this._data;
                    B.each(H, function(K) {
                        J[K.get("name")] = false
                    })
                }
                J[I] = true
            },
            unSelect: function(G) {
                if (this.get("selectedMode") !== "single") {
                    this.option.selected[G] = false
                }
            },
            toggleSelected: function(G) {
                var H = this.option.selected;
                if (!H.hasOwnProperty(G)) {
                    H[G] = true
                }
                this[H[G] ? "unSelect" : "select"](G)
            },
            isSelected: function(G) {
                var H = this.option.selected;
                return !(H.hasOwnProperty(G) && !H[G]) && B.indexOf(this._availableNames, G) >= 0
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: true,
                orient: "horizontal",
                left: "center",
                top: "top",
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                inactiveColor: "#ccc",
                textStyle: {color: "#333"},
                selectedMode: true,
                tooltip: {show: false}
            }
        });
        E.exports = C
    }, function(D, F, C) {
        var E = C(1);
        var A = C(4);

        function B(I, J, H) {
            var L = {};
            var G = I === "toggleSelected";
            var K;
            H.eachComponent("legend", function(N) {
                if (G && K != null) {
                    N[K ? "select" : "unSelect"](J.name)
                } else {
                    N[I](J.name);
                    K = N.isSelected(J.name)
                }
                var M = N.getData();
                A.each(M, function(Q) {
                    var P = Q.get("name");
                    if (P === "\n" || P === "") {
                        return
                    }
                    var O = N.isSelected(P);
                    if (L.hasOwnProperty(P)) {
                        L[P] = L[P] && O
                    } else {
                        L[P] = O
                    }
                })
            });
            return {name: J.name, selected: L}
        }

        E.registerAction("legendToggleSelect", "legendselectchanged", A.curry(B, "toggleSelected"));
        E.registerAction("legendSelect", "legendselected", A.curry(B, "select"));
        E.registerAction("legendUnSelect", "legendunselected", A.curry(B, "unSelect"))
    }, function(I, K, E) {
        var D = E(4);
        var A = E(111);
        var G = E(18);
        var H = E(325);
        var C = D.curry;

        function F(L, M) {
            M.dispatchAction({type: "legendToggleSelect", name: L})
        }

        function J(M, N, O) {
            var L = O.getZr().storage.getDisplayList()[0];
            if (!(L && L.useHoverLayer)) {
                M.get("legendHoverLink") && O.dispatchAction({type: "highlight", seriesName: M.name, name: N})
            }
        }

        function B(M, N, O) {
            var L = O.getZr().storage.getDisplayList()[0];
            if (!(L && L.useHoverLayer)) {
                M.get("legendHoverLink") && O.dispatchAction({type: "downplay", seriesName: M.name, name: N})
            }
        }

        I.exports = E(1).extendComponentView({
            type: "legend", init: function() {
                this._symbolTypeStore = {}
            }, render: function(P, N, Q) {
                var L = this.group;
                L.removeAll();
                if (!P.get("show")) {
                    return
                }
                var M = P.get("selectedMode");
                var O = P.get("align");
                if (O === "auto") {
                    O = (P.get("left") === "right" && P.get("orient") === "vertical") ? "right" : "left"
                }
                var R = D.createHashMap();
                D.each(P.getData(), function(S) {
                    var T = S.get("name");
                    if (T === "" || T === "\n") {
                        L.add(new G.Group({newline: true}));
                        return
                    }
                    var Z = N.getSeriesByName(T)[0];
                    if (R.get(T)) {
                        return
                    }
                    if (Z) {
                        var U = Z.getData();
                        var W = U.getVisual("color");
                        if (typeof W === "function") {
                            W = W(Z.getDataParams(0))
                        }
                        var V = U.getVisual("legendSymbol") || "roundRect";
                        var X = U.getVisual("symbol");
                        var Y = this._createItem(T, S, P, V, X, O, W, M);
                        Y.on("click", C(F, T, Q)).on("mouseover", C(J, Z, null, Q)).on("mouseout", C(B, Z, null, Q));
                        R.set(T, true)
                    } else {
                        N.eachRawSeries(function(a) {
                            if (R.get(T)) {
                                return
                            }
                            if (a.legendDataProvider) {
                                var f = a.legendDataProvider();
                                var c = f.indexOfName(T);
                                if (c < 0) {
                                    return
                                }
                                var e = f.getItemVisual(c, "color");
                                var d = "roundRect";
                                var b = this._createItem(T, S, P, d, null, O, e, M);
                                b.on("click", C(F, T, Q)).on("mouseover", C(J, a, T, Q)).on("mouseout", C(B, a, T, Q));
                                R.set(T, true)
                            }
                        }, this)
                    }
                    if (true) {
                        if (!R.get(T)) {
                            console.warn(T + " series not exists. Legend data should be same with series name or data name.")
                        }
                    }
                }, this);
                H.layout(L, P, Q);
                H.addBackground(L, P)
            }, _createItem: function(g, f, R, i, Y, e, N, V) {
                var O = R.get("itemWidth");
                var P = R.get("itemHeight");
                var S = R.get("inactiveColor");
                var X = R.isSelected(g);
                var b = new G.Group();
                var W = f.getModel("textStyle");
                var Z = f.get("icon");
                var h = f.getModel("tooltip");
                var T = h.parentModel;
                i = Z || i;
                b.add(A.createSymbol(i, 0, 0, O, P, X ? N : S));
                if (!Z && Y && ((Y !== i) || Y == "none")) {
                    var Q = P * 0.8;
                    if (Y === "none") {
                        Y = "circle"
                    }
                    b.add(A.createSymbol(Y, (O - Q) / 2, (P - Q) / 2, Q, Q, X ? N : S))
                }
                var c = e === "left" ? O + 5 : -5;
                var U = e;
                var M = R.get("formatter");
                var d = g;
                if (typeof M === "string" && M) {
                    d = M.replace("{name}", g != null ? g : "")
                } else {
                    if (typeof M === "function") {
                        d = M(g)
                    }
                }
                var L = new G.Text({
                    style: {
                        text: d,
                        x: c,
                        y: P / 2,
                        fill: X ? W.getTextColor() : S,
                        textFont: W.getFont(),
                        textAlign: U,
                        textVerticalAlign: "middle"
                    }
                });
                b.add(L);
                var a = new G.Rect({
                    shape: b.getBoundingRect(),
                    invisible: true,
                    tooltip: h.get("show") ? D.extend({
                        content: g, formatter: T.get("formatter", true) || function() {
                            return g
                        }, formatterParams: {componentType: "legend", legendIndex: R.componentIndex, name: g, $vars: ["name"]}
                    }, h.option) : null
                });
                b.add(a);
                b.eachChild(function(j) {
                    j.silent = true
                });
                a.silent = !V;
                this.group.add(b);
                G.setHoverStyle(b);
                return b
            }
        })
    }, function(D, F, C) {
        var E = C(71);
        var G = C(6);
        var A = C(18);

        function B(H, J, I) {
            E.positionElement(H, J.getBoxLayoutParams(), {width: I.getWidth(), height: I.getHeight()}, J.get("padding"))
        }

        D.exports = {
            layout: function(H, J, K) {
                var I = E.getLayoutRect(J.getBoxLayoutParams(), {width: K.getWidth(), height: K.getHeight()}, J.get("padding"));
                E.box(J.get("orient"), H, J.get("itemGap"), I.width, I.height);
                B(H, J, K)
            }, addBackground: function(H, K) {
                var I = G.normalizeCssArray(K.get("padding"));
                var M = H.getBoundingRect();
                var L = K.getItemStyle(["color", "opacity"]);
                L.fill = K.get("backgroundColor");
                var J = new A.Rect({
                    shape: {x: M.x - I[3], y: M.y - I[0], width: M.width + I[1] + I[3], height: M.height + I[0] + I[2]},
                    style: L,
                    silent: true,
                    z2: -1
                });
                A.subPixelOptimizeRect(J);
                H.add(J)
            }
        }
    }, function(A, B) {
        A.exports = function(C) {
            var D = C.findComponents({mainType: "legend"});
            if (D && D.length) {
                C.filterSeries(function(F) {
                    for (var E = 0; E < D.length; E++) {
                        if (!D[E].isSelected(F.name)) {
                            return false
                        }
                    }
                    return true
                })
            }
        }
    }, function(B, C, A) {
        A(298);
        A(328);
        A(329);
        A(1).registerAction({type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip"}, function() {
        });
        A(1).registerAction({type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip"}, function() {
        })
    }, function(B, C, A) {
        A(1).extendComponentModel({
            type: "tooltip",
            dependencies: ["axisPointer"],
            defaultOption: {
                zlevel: 0,
                z: 8,
                show: true,
                showContent: true,
                trigger: "item",
                triggerOn: "mousemove|click",
                alwaysShowContent: false,
                displayMode: "single",
                confine: false,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: 0.4,
                enterable: false,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: "auto",
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    crossStyle: {color: "#999", width: 1, type: "dashed", textStyle: {}}
                },
                textStyle: {color: "#fff", fontSize: 14}
            }
        })
    }, function(S, I, U) {
        var R = U(330);
        var H = U(4);
        var X = U(6);
        var L = U(7);
        var N = U(18);
        var T = U(300);
        var O = U(71);
        var A = U(2);
        var W = U(12);
        var V = U(303);
        var M = U(101);
        var P = U(306);
        var D = H.bind;
        var K = H.each;
        var G = L.parsePercent;
        var F = new N.Rect({shape: {x: -1, y: -1, width: 2, height: 2}});
        U(1).extendComponentView({
            type: "tooltip", init: function(Z, b) {
                if (A.node) {
                    return
                }
                var a = new R(b.getDom(), b);
                this._tooltipContent = a
            }, render: function(a, Z, b) {
                if (A.node) {
                    return
                }
                this.group.removeAll();
                this._tooltipModel = a;
                this._ecModel = Z;
                this._api = b;
                this._lastDataByCoordSys = null;
                this._alwaysShowContent = a.get("alwaysShowContent");
                var c = this._tooltipContent;
                c.update();
                c.setEnterable(a.get("enterable"));
                this._initGlobalListener();
                this._keepShow()
            }, _initGlobalListener: function() {
                var a = this._tooltipModel;
                var Z = a.get("triggerOn");
                V.register("itemTooltip", this._api, D(function(d, b, c) {
                    if (Z !== "none") {
                        if (Z.indexOf(d) >= 0) {
                            this._tryShow(b, c)
                        } else {
                            if (d === "leave") {
                                this._hide(c)
                            }
                        }
                    }
                }, this))
            }, _keepShow: function() {
                var b = this._tooltipModel;
                var a = this._ecModel;
                var c = this._api;
                if (this._lastX != null && this._lastY != null && b.get("triggerOn") !== "none") {
                    var Z = this;
                    clearTimeout(this._refreshUpdateTimeout);
                    this._refreshUpdateTimeout = setTimeout(function() {
                        Z.manuallyShowTip(b, a, c, {x: Z._lastX, y: Z._lastY})
                    })
                }
            }, manuallyShowTip: function(i, a, g, b) {
                if (b.from === this.uid || A.node) {
                    return
                }
                var Z = Y(b, g);
                this._ticket = "";
                var d = b.dataByCoordSys;
                if (b.tooltip && b.x != null && b.y != null) {
                    var f = F;
                    f.position = [b.x, b.y];
                    f.update();
                    f.tooltip = b.tooltip;
                    this._tryShow({offsetX: b.x, offsetY: b.y, target: f}, Z)
                } else {
                    if (d) {
                        this._tryShow({
                            offsetX: b.x,
                            offsetY: b.y,
                            position: b.position,
                            event: {},
                            dataByCoordSys: b.dataByCoordSys,
                            tooltipOption: b.tooltipOption
                        }, Z)
                    } else {
                        if (b.seriesIndex != null) {
                            if (this._manuallyAxisShowTip(i, a, g, b)) {
                                return
                            }
                            var h = T(b, a);
                            var e = h.point[0];
                            var c = h.point[1];
                            if (e != null && c != null) {
                                this._tryShow({offsetX: e, offsetY: c, position: b.position, target: h.el, event: {}}, Z)
                            }
                        } else {
                            if (b.x != null && b.y != null) {
                                g.dispatchAction({type: "updateAxisPointer", x: b.x, y: b.y});
                                this._tryShow({
                                    offsetX: b.x,
                                    offsetY: b.y,
                                    position: b.position,
                                    target: g.getZr().findHover(b.x, b.y).target,
                                    event: {}
                                }, Z)
                            }
                        }
                    }
                }
            }, manuallyHideTip: function(b, Z, c, a) {
                var d = this._tooltipContent;
                if (!this._alwaysShowContent) {
                    d.hideLater(this._tooltipModel.get("hideDelay"))
                }
                this._lastX = this._lastY = null;
                if (a.from !== this.uid) {
                    this._hide(Y(a, c))
                }
            }, _manuallyAxisShowTip: function(d, Z, g, a) {
                var c = a.seriesIndex;
                var f = a.dataIndex;
                var e = Z.getComponent("axisPointer").coordSysAxesInfo;
                if (c == null || f == null || e == null) {
                    return
                }
                var h = Z.getSeriesByIndex(c);
                if (!h) {
                    return
                }
                var b = h.getData();
                var d = C([b.getItemModel(f), h, (h.coordinateSystem || {}).model, d]);
                if (d.get("trigger") !== "axis") {
                    return
                }
                g.dispatchAction({type: "updateAxisPointer", seriesIndex: c, dataIndex: f, position: a.position});
                return true
            }, _tryShow: function(b, d) {
                var Z = b.target;
                var c = this._tooltipModel;
                if (!c) {
                    return
                }
                this._lastX = b.offsetX;
                this._lastY = b.offsetY;
                var a = b.dataByCoordSys;
                if (a && a.length) {
                    this._showAxisTooltip(a, b)
                } else {
                    if (Z && Z.dataIndex != null) {
                        this._lastDataByCoordSys = null;
                        this._showSeriesItemTooltip(b, Z, d)
                    } else {
                        if (Z && Z.tooltip) {
                            this._lastDataByCoordSys = null;
                            this._showComponentItemTooltip(b, Z, d)
                        } else {
                            this._lastDataByCoordSys = null;
                            this._hide(d)
                        }
                    }
                }
            }, _showOrMove: function(a, Z) {
                var b = a.get("showDelay");
                Z = H.bind(Z, this);
                clearTimeout(this._showTimout);
                b > 0 ? (this._showTimout = setTimeout(Z, b)) : Z()
            }, _showAxisTooltip: function(f, Z) {
                var b = this._ecModel;
                var a = this._tooltipModel;
                var i = [Z.offsetX, Z.offsetY];
                var h = [];
                var d = [];
                var g = C([Z.tooltipOption, a]);
                K(f, function(e) {
                    K(e.dataByAxis, function(m) {
                        var l = b.getComponent(m.axisDim + "Axis", m.axisIndex);
                        var j = m.value;
                        var o = [];
                        if (!l || j == null) {
                            return
                        }
                        var k = P.getValueLabel(j, l.axis, b, m.seriesDataIndices, m.valueLabelOpt);
                        H.each(m.seriesDataIndices, function(r) {
                            var s = b.getSeriesByIndex(r.seriesIndex);
                            var q = r.dataIndexInside;
                            var p = s && s.getDataParams(q);
                            p.axisDim = m.axisDim;
                            p.axisIndex = m.axisIndex;
                            p.axisType = m.axisType;
                            p.axisId = m.axisId;
                            p.axisValue = M.getAxisRawValue(l.axis, j);
                            p.axisValueLabel = k;
                            if (p) {
                                d.push(p);
                                o.push(s.formatTooltip(q, true))
                            }
                        });
                        var n = k;
                        h.push((n ? X.encodeHTML(n) + "<br />" : "") + o.join("<br />"))
                    })
                }, this);
                h.reverse();
                h = h.join("<br /><br />");
                var c = Z.position;
                this._showOrMove(g, function() {
                    if (this._updateContentNotChangedOnAxis(f)) {
                        this._updatePosition(g, c, i[0], i[1], this._tooltipContent, d)
                    } else {
                        this._showTooltipContent(g, h, d, Math.random(), i[0], i[1], c)
                    }
                })
            }, _showSeriesItemTooltip: function(c, g, Z) {
                var a = this._ecModel;
                var f = g.seriesIndex;
                var o = a.getSeriesByIndex(f);
                var m = g.dataModel || o;
                var j = g.dataIndex;
                var b = g.dataType;
                var d = m.getData();
                var n = C([d.getItemModel(j), m, o && (o.coordinateSystem || {}).model, this._tooltipModel]);
                var h = n.get("trigger");
                if (h != null && h !== "item") {
                    return
                }
                var i = m.getDataParams(j, b);
                var l = m.formatTooltip(j, false, b);
                var k = "item_" + m.name + "_" + j;
                this._showOrMove(n, function() {
                    this._showTooltipContent(n, l, i, k, c.offsetX, c.offsetY, c.position, c.target)
                });
                Z({type: "showTip", dataIndexInside: j, dataIndex: d.getRawIndex(j), seriesIndex: f, from: this.uid})
            }, _showComponentItemTooltip: function(a, f, Z) {
                var c = f.tooltip;
                if (typeof c === "string") {
                    var h = c;
                    c = {content: h, formatter: h}
                }
                var d = new W(c, this._tooltipModel, this._ecModel);
                var g = d.get("content");
                var b = Math.random();
                this._showOrMove(d, function() {
                    this._showTooltipContent(d, g, d.get("formatterParams") || {}, b, a.offsetX, a.offsetY, a.position, f)
                });
                Z({type: "showTip", from: this.uid})
            }, _showTooltipContent: function(d, j, f, b, h, i, c, Z) {
                this._ticket = "";
                if (!d.get("showContent") || !d.get("show")) {
                    return
                }
                var g = this._tooltipContent;
                var e = d.get("formatter");
                c = c || d.get("position");
                var k = j;
                if (e && typeof e === "string") {
                    k = X.formatTpl(e, f, true)
                } else {
                    if (typeof e === "function") {
                        var a = D(function(m, l) {
                            if (m === this._ticket) {
                                g.setContent(l);
                                this._updatePosition(d, c, h, i, g, f, Z)
                            }
                        }, this);
                        this._ticket = b;
                        k = e(f, b, a)
                    }
                }
                g.setContent(k);
                g.show(d);
                this._updatePosition(d, c, h, i, g, f, Z)
            }, _updatePosition: function(g, e, k, l, n, h, Z) {
                var i = this._api.getWidth();
                var a = this._api.getHeight();
                e = e || g.get("position");
                var c = n.getSize();
                var f = g.get("align");
                var m = g.get("verticalAlign");
                var b = Z && Z.getBoundingRect().clone();
                Z && b.applyTransform(Z.transform);
                if (typeof e === "function") {
                    e = e([k, l], h, n.el, b, {viewSize: [i, a], contentSize: c.slice()})
                }
                if (H.isArray(e)) {
                    k = G(e[0], i);
                    l = G(e[1], a)
                } else {
                    if (H.isObject(e)) {
                        e.width = c[0];
                        e.height = c[1];
                        var j = O.getLayoutRect(e, {width: i, height: a});
                        k = j.x;
                        l = j.y;
                        f = null;
                        m = null
                    } else {
                        if (typeof e === "string" && Z) {
                            var d = J(e, b, c);
                            k = d[0];
                            l = d[1]
                        } else {
                            var d = Q(k, l, n.el, i, a, f ? null : 20, m ? null : 20);
                            k = d[0];
                            l = d[1]
                        }
                    }
                }
                f && (k -= B(f) ? c[0] / 2 : f === "right" ? c[0] : 0);
                m && (l -= B(m) ? c[1] / 2 : m === "bottom" ? c[1] : 0);
                if (g.get("confine")) {
                    var d = E(k, l, n.el, i, a);
                    k = d[0];
                    l = d[1]
                }
                n.moveTo(k, l)
            }, _updateContentNotChangedOnAxis: function(Z) {
                var b = this._lastDataByCoordSys;
                var a = !!b && b.length === Z.length;
                a && K(b, function(e, g) {
                    var c = e.dataByAxis || {};
                    var d = Z[g] || {};
                    var f = d.dataByAxis || [];
                    a &= c.length === f.length;
                    a && K(c, function(k, l) {
                        var h = f[l] || {};
                        var i = k.seriesDataIndices || [];
                        var j = h.seriesDataIndices || [];
                        a &= k.value === h.value && k.axisType === h.axisType && k.axisId === h.axisId && i.length === j.length;
                        a && K(i, function(o, n) {
                            var m = j[n];
                            a &= o.seriesIndex === m.seriesIndex && o.dataIndex === m.dataIndex
                        })
                    })
                });
                this._lastDataByCoordSys = Z;
                return !!a
            }, _hide: function(Z) {
                this._lastDataByCoordSys = null;
                Z({type: "hideTip", from: this.uid})
            }, dispose: function(Z, a) {
                if (A.node) {
                    return
                }
                this._tooltipContent.hide();
                V.unregister("itemTooltip", a)
            }
        });

        function C(b) {
            var Z = b.pop();
            while (b.length) {
                var a = b.pop();
                if (a) {
                    if (a instanceof W) {
                        a = a.get("tooltip", true)
                    }
                    if (typeof a === "string") {
                        a = {formatter: a}
                    }
                    Z = new W(a, Z, Z.ecModel)
                }
            }
            return Z
        }

        function Y(Z, a) {
            return Z.dispatchAction || H.bind(a.dispatchAction, a)
        }

        function Q(f, g, Z, d, h, c, b) {
            var e = Z.clientWidth;
            var a = Z.clientHeight;
            if (c != null) {
                if (f + e + c > d) {
                    f -= e + c
                } else {
                    f += c
                }
            }
            if (b != null) {
                if (g + a + b > h) {
                    g -= a + b
                } else {
                    g += b
                }
            }
            return [f, g]
        }

        function E(d, e, Z, b, c) {
            var f = Z.clientWidth;
            var a = Z.clientHeight;
            d = Math.min(d + f, b) - f;
            e = Math.min(e + a, c) - a;
            d = Math.max(d, 0);
            e = Math.max(e, 0);
            return [d, e]
        }

        function J(e, b, a) {
            var Z = a[0];
            var h = a[1];
            var i = 5;
            var f = 0;
            var g = 0;
            var c = b.width;
            var d = b.height;
            switch (e) {
                case"inside":
                    f = b.x + c / 2 - Z / 2;
                    g = b.y + d / 2 - h / 2;
                    break;
                case"top":
                    f = b.x + c / 2 - Z / 2;
                    g = b.y - h - i;
                    break;
                case"bottom":
                    f = b.x + c / 2 - Z / 2;
                    g = b.y + d + i;
                    break;
                case"left":
                    f = b.x - Z - i;
                    g = b.y + d / 2 - h / 2;
                    break;
                case"right":
                    f = b.x + c + i;
                    g = b.y + d / 2 - h / 2
            }
            return [f, g]
        }

        function B(Z) {
            return Z === "center" || Z === "middle"
        }
    }, function(O, P, E) {
        var D = E(4);
        var J = E(31);
        var H = E(88);
        var L = E(6);
        var A = D.each;
        var N = L.toCamelCase;
        var I = E(2);
        var F = ["", "-webkit-", "-moz-", "-o-"];
        var G = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";

        function B(R) {
            var Q = "cubic-bezier(0.23, 1, 0.32, 1)";
            var S = "left " + R + "s " + Q + ",top " + R + "s " + Q;
            return D.map(F, function(T) {
                return T + "transition:" + S
            }).join(";")
        }

        function M(Q) {
            var S = [];
            var R = Q.get("fontSize");
            var T = Q.getTextColor();
            T && S.push("color:" + T);
            S.push("font:" + Q.getFont());
            R && S.push("line-height:" + Math.round(R * 3 / 2) + "px");
            A(["decoration", "align"], function(U) {
                var V = Q.get(U);
                V && S.push("text-" + U + ":" + V)
            });
            return S.join(";")
        }

        function C(U) {
            var V = [];
            var R = U.get("transitionDuration");
            var Q = U.get("backgroundColor");
            var S = U.getModel("textStyle");
            var T = U.get("padding");
            R && V.push(B(R));
            if (Q) {
                if (I.canvasSupported) {
                    V.push("background-Color:" + Q)
                } else {
                    V.push("background-Color:#" + J.toHex(Q));
                    V.push("filter:alpha(opacity=70)")
                }
            }
            A(["width", "color", "radius"], function(Y) {
                var W = "border-" + Y;
                var Z = N(W);
                var X = U.get(Z);
                X != null && V.push(W + ":" + X + (Y === "color" ? "" : "px"))
            });
            V.push(M(S));
            if (T != null) {
                V.push("padding:" + L.normalizeCssArray(T).join("px ") + "px")
            }
            return V.join(";") + ";"
        }

        function K(T, U) {
            var Q = document.createElement("div");
            var R = this._zr = U.getZr();
            this.el = Q;
            this._x = U.getWidth() / 2;
            this._y = U.getHeight() / 2;
            T.appendChild(Q);
            this._container = T;
            this._show = false;
            this._hideTimeout;
            var S = this;
            Q.onmouseenter = function() {
                if (S._enterable) {
                    clearTimeout(S._hideTimeout);
                    S._show = true
                }
                S._inContent = true
            };
            Q.onmousemove = function(V) {
                V = V || window.event;
                if (!S._enterable) {
                    var W = R.handler;
                    H.normalizeEvent(T, V, true);
                    W.dispatch("mousemove", V)
                }
            };
            Q.onmouseleave = function() {
                if (S._enterable) {
                    if (S._show) {
                        S.hideLater(S._hideDelay)
                    }
                }
                S._inContent = false
            }
        }

        K.prototype = {
            constructor: K, _enterable: true, update: function() {
                var Q = this._container;
                var R = Q.currentStyle || document.defaultView.getComputedStyle(Q);
                var S = Q.style;
                if (S.position !== "absolute" && R.position !== "absolute") {
                    S.position = "relative"
                }
            }, show: function(R) {
                clearTimeout(this._hideTimeout);
                var Q = this.el;
                Q.style.cssText = G + C(R) + ";left:" + this._x + "px;top:" + this._y + "px;" + (R.get("extraCssText") || "");
                Q.style.display = Q.innerHTML ? "block" : "none";
                this._show = true
            }, setContent: function(Q) {
                this.el.innerHTML = Q == null ? "" : Q
            }, setEnterable: function(Q) {
                this._enterable = Q
            }, getSize: function() {
                var Q = this.el;
                return [Q.clientWidth, Q.clientHeight]
            }, moveTo: function(S, T) {
                var Q = this._zr;
                var U;
                if (Q && Q.painter && (U = Q.painter.getViewportRoot())) {
                    S += U.offsetLeft || 0;
                    T += U.offsetTop || 0
                }
                var R = this.el.style;
                R.left = S + "px";
                R.top = T + "px";
                this._x = S;
                this._y = T
            }, hide: function() {
                this.el.style.display = "none";
                this._show = false
            }, hideLater: function(Q) {
                if (this._show && !(this._inContent && this._enterable)) {
                    if (Q) {
                        this._hideDelay = Q;
                        this._show = false;
                        this._hideTimeout = setTimeout(D.bind(this.hide, this), Q)
                    } else {
                        this.hide()
                    }
                }
            }, isShow: function() {
                return this._show
            }
        };
        O.exports = K
    }, function(C, D, B) {
        var A = B(4);
        B(332);
        B(338);
        B(340);
        B(298);
        B(342);
        B(1).registerLayout(A.curry(B(343), "bar"));
        B(1).extendComponentView({type: "polar"})
    }, function(J, L, D) {
        var I = D(333);
        var E = D(7);
        var C = D(4);
        var H = D(101);
        var B = H.niceScaleExtent;
        D(336);

        function K(U, T) {
            var M = U.get("center");
            var R = U.get("radius");
            var S = T.getWidth();
            var N = T.getHeight();
            var Q = E.parsePercent;
            this.cx = Q(M[0], S);
            this.cy = Q(M[1], N);
            var O = this.getRadiusAxis();
            var P = Math.min(S, N) / 2;
            O.setExtent(0, Q(R, P))
        }

        function G(N, R) {
            var S = this;
            var Q = S.getAngleAxis();
            var O = S.getRadiusAxis();
            Q.scale.setExtent(Infinity, -Infinity);
            O.scale.setExtent(Infinity, -Infinity);
            N.eachSeries(function(T) {
                if (T.coordinateSystem === S) {
                    var U = T.getData();
                    O.scale.unionExtentFromData(U, "radius");
                    Q.scale.unionExtentFromData(U, "angle")
                }
            });
            B(Q.scale, Q.model);
            B(O.scale, O.model);
            if (Q.type === "category" && !Q.onBand) {
                var P = Q.getExtent();
                var M = 360 / Q.scale.count();
                Q.inverse ? (P[1] += M) : (P[1] -= M);
                Q.setExtent(P[0], P[1])
            }
        }

        function A(O, M) {
            O.type = M.get("type");
            O.scale = H.createScaleByModel(M);
            O.onBand = M.get("boundaryGap") && O.type === "category";
            if (M.mainType === "angleAxis") {
                var N = M.get("startAngle");
                O.inverse = M.get("inverse") ^ M.get("clockwise");
                O.setExtent(N, N + (O.inverse ? -360 : 360))
            }
            M.axis = O;
            O.model = M
        }

        var F = {
            dimensions: I.prototype.dimensions, create: function(N, O) {
                var M = [];
                N.eachComponent("polar", function(U, T) {
                    var V = new I(T);
                    V.resize = K;
                    V.update = G;
                    var Q = V.getRadiusAxis();
                    var P = V.getAngleAxis();
                    var R = U.findAxisModel("radiusAxis");
                    var S = U.findAxisModel("angleAxis");
                    A(Q, R);
                    A(P, S);
                    V.resize(U, O);
                    M.push(V);
                    U.coordinateSystem = V;
                    V.model = U
                });
                N.eachSeries(function(P) {
                    if (P.get("coordinateSystem") === "polar") {
                        var Q = N.queryComponents({mainType: "polar", index: P.get("polarIndex"), id: P.get("polarId")})[0];
                        if (true) {
                            if (!Q) {
                                throw new Error('Polar "' + C.retrieve(P.get("polarIndex"), P.get("polarId"), 0) + '" not found')
                            }
                        }
                        P.coordinateSystem = Q.coordinateSystem
                    }
                });
                return M
            }
        };
        D(76).register("polar", F)
    }, function(D, F, C) {
        var A = C(334);
        var B = C(335);
        var E = function(G) {
            this.name = G || "";
            this.cx = 0;
            this.cy = 0;
            this._radiusAxis = new A();
            this._angleAxis = new B();
            this._radiusAxis.polar = this._angleAxis.polar = this
        };
        E.prototype = {
            type: "polar",
            axisPointerEnabled: true,
            constructor: E,
            dimensions: ["radius", "angle"],
            model: null,
            containPoint: function(G) {
                var H = this.pointToCoord(G);
                return this._radiusAxis.contain(H[0]) && this._angleAxis.contain(H[1])
            },
            containData: function(G) {
                return this._radiusAxis.containData(G[0]) && this._angleAxis.containData(G[1])
            },
            getAxis: function(G) {
                return this["_" + G + "Axis"]
            },
            getAxes: function() {
                return [this._radiusAxis, this._angleAxis]
            },
            getAxesByScale: function(H) {
                var G = [];
                var I = this._angleAxis;
                var J = this._radiusAxis;
                I.scale.type === H && G.push(I);
                J.scale.type === H && G.push(J);
                return G
            },
            getAngleAxis: function() {
                return this._angleAxis
            },
            getRadiusAxis: function() {
                return this._radiusAxis
            },
            getOtherAxis: function(H) {
                var G = this._angleAxis;
                return H === G ? this._radiusAxis : G
            },
            getBaseAxis: function() {
                return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
            },
            getTooltipAxes: function(G) {
                var H = (G != null && G !== "auto") ? this.getAxis(G) : this.getBaseAxis();
                return {baseAxes: [H], otherAxes: [this.getOtherAxis(H)]}
            },
            dataToPoints: function(G) {
                return G.mapArray(this.dimensions, function(H, I) {
                    return this.dataToPoint([H, I])
                }, true, this)
            },
            dataToPoint: function(H, G) {
                return this.coordToPoint([this._radiusAxis.dataToRadius(H[0], G), this._angleAxis.dataToAngle(H[1], G)])
            },
            pointToData: function(G, H) {
                var I = this.pointToCoord(G);
                return [this._radiusAxis.radiusToData(I[0], H), this._angleAxis.angleToData(I[1], H)]
            },
            pointToCoord: function(O) {
                var N = O[0] - this.cx;
                var L = O[1] - this.cy;
                var H = this.getAngleAxis();
                var J = H.getExtent();
                var P = Math.min(J[0], J[1]);
                var I = Math.max(J[0], J[1]);
                H.inverse ? (P = I - 360) : (I = P + 360);
                var M = Math.sqrt(N * N + L * L);
                N /= M;
                L /= M;
                var K = Math.atan2(-L, N) / Math.PI * 180;
                var G = K < P ? 1 : -1;
                while (K < P || K > I) {
                    K += G * 360
                }
                return [M, K]
            },
            coordToPoint: function(G) {
                var I = G[0];
                var H = G[1] / 180 * Math.PI;
                var J = Math.cos(H) * I + this.cx;
                var K = -Math.sin(H) * I + this.cy;
                return [J, K]
            }
        };
        D.exports = E
    }, function(D, F, B) {
        var A = B(4);
        var E = B(100);

        function C(H, G) {
            E.call(this, "radius", H, G);
            this.type = "category"
        }

        C.prototype = {
            constructor: C, pointToData: function(G, H) {
                return this.polar.pointToData(G, H)[this.dim === "radius" ? 0 : 1]
            }, dataToRadius: E.prototype.dataToCoord, radiusToData: E.prototype.coordToData
        };
        A.inherits(C, E);
        D.exports = C
    }, function(D, F, C) {
        var A = C(4);
        var E = C(100);

        function B(H, G) {
            G = G || [0, 360];
            E.call(this, "angle", H, G);
            this.type = "category"
        }

        B.prototype = {
            constructor: B, pointToData: function(G, H) {
                return this.polar.pointToData(G, H)[this.dim === "radius" ? 0 : 1]
            }, dataToAngle: E.prototype.dataToCoord, angleToData: E.prototype.coordToData
        };
        A.inherits(B, E);
        D.exports = B
    }, function(B, C, A) {
        A(337);
        A(1).extendComponentModel({
            type: "polar", dependencies: ["polarAxis", "angleAxis"], coordinateSystem: null, findAxisModel: function(F) {
                var D;
                var E = this.ecModel;
                E.eachComponent(F, function(G) {
                    if (G.getCoordSysModel() === this) {
                        D = G
                    }
                }, this);
                return D
            }, defaultOption: {zlevel: 0, z: 0, center: ["50%", "50%"], radius: "80%"}
        })
    }, function(G, I, D) {
        var C = D(4);
        var H = D(69);
        var B = D(131);
        var A = H.extend({
            type: "polarAxis", axis: null, getCoordSysModel: function() {
                return this.ecModel.queryComponents({mainType: "polar", index: this.option.polarIndex, id: this.option.polarId})[0]
            }
        });
        C.merge(A.prototype, D(112));
        var E = {angle: {startAngle: 90, clockwise: true, splitNumber: 12, axisLabel: {rotate: false}}, radius: {splitNumber: 5}};

        function F(K, J) {
            return J.type || (J.data ? "category" : "value")
        }

        B("angle", A, F, E.angle);
        B("radius", A, F, E.radius)
    }, function(B, C, A) {
        A(332);
        A(339)
    }, function(G, H, D) {
        var C = D(4);
        var E = D(18);
        var F = D(12);
        var B = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"];

        function A(N, I, J, K) {
            var M = N.coordToPoint([I, K]);
            var L = N.coordToPoint([J, K]);
            return {x1: M[0], y1: M[1], x2: L[0], y2: L[1]}
        }

        D(136).extend({
            type: "angleAxis", axisPointerClass: "PolarAxisPointer", render: function(L, J) {
                this.group.removeAll();
                if (!L.get("show")) {
                    return
                }
                var M = L.axis;
                var N = M.polar;
                var K = N.getRadiusAxis().getExtent();
                var I = M.getTicksCoords();
                if (M.type !== "category") {
                    I.pop()
                }
                C.each(B, function(O) {
                    if (L.get(O + ".show") && (!M.scale.isBlank() || O === "axisLine")) {
                        this["_" + O](L, N, I, K)
                    }
                }, this)
            }, _axisLine: function(K, N, J, L) {
                var M = K.getModel("axisLine.lineStyle");
                var I = new E.Circle({shape: {cx: N.cx, cy: N.cy, r: L[1]}, style: M.getLineStyle(), z2: 1, silent: true});
                I.style.fill = null;
                this.group.add(I)
            }, _axisTick: function(K, O, I, L) {
                var M = K.getModel("axisTick");
                var J = (M.get("inside") ? -1 : 1) * M.get("length");
                var N = C.map(I, function(P) {
                    return new E.Line({shape: A(O, L[1], L[1] + J, P)})
                });
                this.group.add(E.mergePath(N, {style: C.defaults(M.getModel("lineStyle").getLineStyle(), {stroke: K.get("axisLine.lineStyle.color")})}))
            }, _axisLabel: function(Z, P, S, a) {
                var W = Z.axis;
                var U = Z.get("data");
                var J = Z.getModel("axisLabel");
                var T = J.getModel("textStyle");
                var I = Z.getFormattedLabels();
                var R = J.get("margin");
                var V = W.getLabelsCoords();
                for (var O = 0; O < S.length; O++) {
                    var X = a[1];
                    var K = P.coordToPoint([X + R, V[O]]);
                    var L = P.cx;
                    var Y = P.cy;
                    var M = Math.abs(K[0] - L) / X < 0.3 ? "center" : (K[0] > L ? "left" : "right");
                    var Q = Math.abs(K[1] - Y) / X < 0.3 ? "middle" : (K[1] > Y ? "top" : "bottom");
                    var N = T;
                    if (U && U[O] && U[O].textStyle) {
                        N = new F(U[O].textStyle, T)
                    }
                    this.group.add(new E.Text({
                        style: {
                            x: K[0],
                            y: K[1],
                            fill: N.getTextColor() || Z.get("axisLine.lineStyle.color"),
                            text: I[O],
                            textAlign: M,
                            textVerticalAlign: Q,
                            textFont: N.getFont()
                        }, silent: true
                    }))
                }
            }, _splitLine: function(R, J, I, M) {
                var N = R.getModel("splitLine");
                var K = N.getModel("lineStyle");
                var L = K.get("color");
                var O = 0;
                L = L instanceof Array ? L : [L];
                var S = [];
                for (var P = 0; P < I.length; P++) {
                    var Q = (O++) % L.length;
                    S[Q] = S[Q] || [];
                    S[Q].push(new E.Line({shape: A(J, M[0], M[1], I[P])}))
                }
                for (var P = 0; P < S.length; P++) {
                    this.group.add(E.mergePath(S[P], {style: C.defaults({stroke: L[P % L.length]}, K.getLineStyle()), silent: true, z: R.get("z")}))
                }
            }, _splitArea: function(V, J, I, O) {
                var P = V.getModel("splitArea");
                var L = P.getModel("areaStyle");
                var T = L.get("color");
                var R = 0;
                T = T instanceof Array ? T : [T];
                var K = [];
                var M = Math.PI / 180;
                var S = -I[0] * M;
                var W = Math.min(O[0], O[1]);
                var X = Math.max(O[0], O[1]);
                var N = V.get("clockwise");
                for (var U = 1; U < I.length; U++) {
                    var Q = (R++) % T.length;
                    K[Q] = K[Q] || [];
                    K[Q].push(new E.Sector({
                        shape: {cx: J.cx, cy: J.cy, r0: W, r: X, startAngle: S, endAngle: -I[U] * M, clockwise: N},
                        silent: true
                    }));
                    S = -I[U] * M
                }
                for (var U = 0; U < K.length; U++) {
                    this.group.add(E.mergePath(K[U], {style: C.defaults({fill: T[U % T.length]}, L.getAreaStyle()), silent: true}))
                }
            }
        })
    }, function(B, C, A) {
        A(332);
        A(341)
    }, function(H, I, D) {
        var C = D(4);
        var E = D(18);
        var A = D(135);
        var G = ["axisLine", "axisLabel", "axisTick", "axisName"];
        var F = ["splitLine", "splitArea"];
        D(136).extend({
            type: "radiusAxis", axisPointerClass: "PolarAxisPointer", render: function(P, K) {
                this.group.removeAll();
                if (!P.get("show")) {
                    return
                }
                var N = P.axis;
                var J = N.polar;
                var M = J.getAngleAxis();
                var R = N.getTicksCoords();
                var S = M.getExtent()[0];
                var O = N.getExtent();
                var Q = B(J, P, S);
                var L = new A(P, Q);
                C.each(G, L.add, L);
                this.group.add(L.getGroup());
                C.each(F, function(T) {
                    if (P.get(T + ".show") && !N.scale.isBlank()) {
                        this["_" + T](P, J, S, O, R)
                    }
                }, this)
            }, _splitLine: function(P, J, T, N, S) {
                var O = P.getModel("splitLine");
                var L = O.getModel("lineStyle");
                var M = L.get("color");
                var Q = 0;
                M = M instanceof Array ? M : [M];
                var U = [];
                for (var R = 0; R < S.length; R++) {
                    var K = (Q++) % M.length;
                    U[K] = U[K] || [];
                    U[K].push(new E.Circle({shape: {cx: J.cx, cy: J.cy, r: S[R]}, silent: true}))
                }
                for (var R = 0; R < U.length; R++) {
                    this.group.add(E.mergePath(U[R], {style: C.defaults({stroke: M[R % M.length], fill: null}, L.getLineStyle()), silent: true}))
                }
            }, _splitArea: function(P, K, U, N, T) {
                var O = P.getModel("splitArea");
                var M = O.getModel("areaStyle");
                var S = M.get("color");
                var Q = 0;
                S = S instanceof Array ? S : [S];
                var L = [];
                var J = T[0];
                for (var R = 1; R < T.length; R++) {
                    var V = (Q++) % S.length;
                    L[V] = L[V] || [];
                    L[V].push(new E.Sector({shape: {cx: K.cx, cy: K.cy, r0: J, r: T[R], startAngle: 0, endAngle: Math.PI * 2}, silent: true}));
                    J = T[R]
                }
                for (var R = 0; R < L.length; R++) {
                    this.group.add(E.mergePath(L[R], {style: C.defaults({fill: S[R % S.length]}, M.getAreaStyle()), silent: true}))
                }
            }
        });

        function B(L, K, J) {
            return {
                position: [L.cx, L.cy],
                rotation: J / 180 * Math.PI,
                labelDirection: -1,
                tickDirection: -1,
                nameDirection: 1,
                labelRotate: K.getModel("axisLabel").get("rotate"),
                z2: 1
            }
        }
    }, function(K, M, D) {
        var C = D(6);
        var B = D(305);
        var G = D(18);
        var J = D(306);
        var F = D(11);
        var A = D(135);
        var H = D(136);
        var I = B.extend({
            makeElOption: function(a, V, S, Q, Z) {
                var P = S.axis;
                if (P.dim === "angle") {
                    this.animationThreshold = Math.PI / 18
                }
                var O = P.polar;
                var R = O.getOtherAxis(P);
                var X = R.getExtent();
                var Y;
                Y = P["dataTo" + C.capitalFirst(P.dim)](V);
                var W = Q.get("type");
                if (W && W !== "none") {
                    var N = J.buildElStyle(Q);
                    var U = L[W](P, O, Y, X, N);
                    U.style = N;
                    a.graphicKey = U.type;
                    a.pointer = U
                }
                var T = Q.get("label.margin");
                var b = E(V, S, Q, O, T);
                J.buildLabelElOption(a, S, Q, Z, b)
            }
        });

        function E(d, V, O, R, T) {
            var X = V.axis;
            var W = X.dataToCoord(d);
            var N = R.getAngleAxis().getExtent()[0];
            N = N / 180 * Math.PI;
            var e = R.getRadiusAxis().getExtent();
            var b;
            var Q;
            var a;
            if (X.dim === "radius") {
                var S = F.create();
                F.rotate(S, S, N);
                F.translate(S, S, [R.cx, R.cy]);
                b = G.applyTransform([W, -T], S);
                var U = V.getModel("axisLabel").get("rotate") || 0;
                var c = A.innerTextLayout(N, U * Math.PI / 180, -1);
                Q = c.textAlign;
                a = c.textVerticalAlign
            } else {
                var Y = e[1];
                b = R.coordToPoint([Y + T, W]);
                var P = R.cx;
                var Z = R.cy;
                Q = Math.abs(b[0] - P) / Y < 0.3 ? "center" : (b[0] > P ? "left" : "right");
                a = Math.abs(b[1] - Z) / Y < 0.3 ? "middle" : (b[1] > Z ? "top" : "bottom")
            }
            return {position: b, align: Q, verticalAlign: a}
        }

        var L = {
            line: function(R, N, Q, P, O) {
                return R.dim === "angle" ? {type: "Line", shape: J.makeLineShape(N.coordToPoint([P[0], Q]), N.coordToPoint([P[1], Q]))} : {
                    type: "Circle",
                    shape: {cx: N.cx, cy: N.cy, r: Q}
                }
            }, shadow: function(T, N, S, Q, P) {
                var R = T.getBandWidth();
                var O = Math.PI / 180;
                return T.dim === "angle" ? {
                    type: "Sector",
                    shape: J.makeSectorShape(N.cx, N.cy, Q[0], Q[1], (-S - R / 2) * O, (-S + R / 2) * O)
                } : {type: "Sector", shape: J.makeSectorShape(N.cx, N.cy, S - R / 2, S + R / 2, 0, Math.PI * 2)}
            }
        };
        H.registerAxisPointerClass("PolarAxisPointer", I);
        K.exports = I
    }, function(G, I, E) {
        var D = E(4);
        var F = E(7).parsePercent;

        function A(J) {
            return J.get("stack") || "__ec_stack_" + J.seriesIndex
        }

        function H(J) {
            return J.dim
        }

        function C(P, K, Q) {
            var O = Q.getWidth();
            var L = Q.getHeight();
            var M = {};
            var N = {};
            var J = B(D.filter(K.getSeriesByType(P), function(R) {
                return !K.isSeriesFiltered(R) && R.coordinateSystem && R.coordinateSystem.type === "polar"
            }));
            K.eachSeriesByType(P, function(V) {
                if (V.coordinateSystem.type !== "polar") {
                    return
                }
                var f = V.getData();
                var U = V.coordinateSystem;
                var h = U.getAngleAxis();
                var R = U.getBaseAxis();
                var Z = A(V);
                var b = J[H(R)][Z];
                var g = b.offset;
                var j = b.width;
                var a = U.getOtherAxis(R);
                var i = V.get("center") || ["50%", "50%"];
                var S = F(i[0], O);
                var c = F(i[1], L);
                var e = V.get("barMinHeight") || 0;
                var X = V.get("barMinAngle") || 0;
                var W = a.getExtent()[0];
                var d = a.model.get("max");
                var Y = a.model.get("min");
                var T = U.dataToPoints(f);
                M[Z] = M[Z] || [];
                N[Z] = N[Z] || [];
                f.each(a.dim, function(o, m) {
                    if (isNaN(o)) {
                        return
                    }
                    if (!M[Z][m]) {
                        M[Z][m] = {p: W, n: W};
                        N[Z][m] = {p: W, n: W}
                    }
                    var u = o >= 0 ? "p" : "n";
                    var q = U.pointToCoord(T[m]);
                    var n = N[Z][m][u];
                    var v;
                    var k;
                    var w;
                    var l;
                    if (a.dim === "radius") {
                        v = n;
                        k = q[0];
                        w = (-q[1] + g) * Math.PI / 180;
                        l = w + j * Math.PI / 180;
                        if (Math.abs(k) < e) {
                            k = v + (k < 0 ? -1 : 1) * e
                        }
                        N[Z][m][u] = k
                    } else {
                        v = q[0] + g;
                        k = v + j;
                        if (d != null) {
                            o = Math.min(o, d)
                        }
                        if (Y != null) {
                            o = Math.max(o, Y)
                        }
                        var s = h.dataToAngle(o);
                        if (Math.abs(s - n) < X) {
                            s = n - (o < 0 ? -1 : 1) * X
                        }
                        w = -n * Math.PI / 180;
                        l = -s * Math.PI / 180;
                        var p = h.getExtent();
                        var t = s;
                        if (t === p[0] && o > 0) {
                            t = p[1]
                        } else {
                            if (t === p[1] && o < 0) {
                                t = p[0]
                            }
                        }
                        N[Z][m][u] = t
                    }
                    f.setItemLayout(m, {cx: S, cy: c, r0: v, r: k, startAngle: w, endAngle: l})
                }, true)
            }, this)
        }

        function B(K, M) {
            var J = {};
            D.each(K, function(a, R) {
                var P = a.getData();
                var O = a.coordinateSystem;
                var Y = O.getBaseAxis();
                var W = Y.getExtent();
                var N = Y.type === "category" ? Y.getBandWidth() : (Math.abs(W[1] - W[0]) / P.count());
                var X = J[H(Y)] || {bandWidth: N, remainedWidth: N, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {}};
                var V = X.stacks;
                J[H(Y)] = X;
                var U = A(a);
                if (!V[U]) {
                    X.autoWidthCount++
                }
                V[U] = V[U] || {width: 0, maxWidth: 0};
                var Q = F(a.get("barWidth"), N);
                var S = F(a.get("barMaxWidth"), N);
                var T = a.get("barGap");
                var Z = a.get("barCategoryGap");
                if (Q && !V[U].width) {
                    Q = Math.min(X.remainedWidth, Q);
                    V[U].width = Q;
                    X.remainedWidth -= Q
                }
                S && (V[U].maxWidth = S);
                (T != null) && (X.gap = T);
                (Z != null) && (X.categoryGap = Z)
            });
            var L = {};
            D.each(J, function(V, P) {
                L[P] = {};
                var T = V.stacks;
                var N = V.bandWidth;
                var Q = F(V.categoryGap, N);
                var O = F(V.gap, 1);
                var R = V.remainedWidth;
                var S = V.autoWidthCount;
                var X = (R - Q) / (S + (S - 1) * O);
                X = Math.max(X, 0);
                D.each(T, function(b, Z) {
                    var a = b.maxWidth;
                    if (a && a < X) {
                        a = Math.min(a, R);
                        if (b.width) {
                            a = Math.min(a, b.width)
                        }
                        R -= a;
                        b.width = a;
                        S--
                    }
                });
                X = (R - Q) / (S + (S - 1) * O);
                X = Math.max(X, 0);
                var W = 0;
                var Y;
                D.each(T, function(a, Z) {
                    if (!a.width) {
                        a.width = X
                    }
                    Y = a;
                    W += a.width * (1 + O)
                });
                if (Y) {
                    W -= Y.width * O
                }
                var U = -W / 2;
                D.each(T, function(a, Z) {
                    L[P][Z] = L[P][Z] || {offset: U, width: a.width};
                    U += a.width * (1 + O)
                })
            });
            return L
        }

        G.exports = C
    }, function(C, F, B) {
        B(345);
        B(171);
        B(346);
        B(187);
        var E = B(1);
        var A = B(4);

        function D(G, H) {
            H.update = "updateView";
            E.registerAction(H, function(J, I) {
                var K = {};
                I.eachComponent({mainType: "geo", query: J}, function(L) {
                    L[G](J.name);
                    var M = L.coordinateSystem;
                    A.each(M.regions, function(N) {
                        K[N.name] = L.isSelected(N.name) || false
                    })
                });
                return {selected: K, name: J.name}
            })
        }

        D("toggleSelected", {type: "geoToggleSelect", event: "geoselectchanged"});
        D("select", {type: "geoSelect", event: "geoselected"});
        D("unSelect", {type: "geoUnSelect", event: "geounselected"})
    }, function(H, J, D) {
        var B = D(5);
        var I = D(69);
        var G = D(12);
        var C = D(4);
        var E = D(148);
        var A = D(171);
        var F = I.extend({
            type: "geo",
            coordinateSystem: null,
            layoutMode: "box",
            init: function(K) {
                I.prototype.init.apply(this, arguments);
                B.defaultEmphasis(K.label, ["position", "show", "textStyle", "distance", "formatter"])
            },
            optionUpdated: function() {
                var K = this.option;
                var L = this;
                K.regions = A.getFilledRegions(K.regions, K.map);
                this._optionModelMap = C.reduce(K.regions || [], function(M, N) {
                    if (N.name) {
                        M.set(N.name, new G(N, L))
                    }
                    return M
                }, C.createHashMap());
                this.updateSelectedMap(K.regions)
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                show: true,
                left: "center",
                top: "center",
                aspectScale: 0.75,
                silent: false,
                map: "",
                boundingCoords: null,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {normal: {show: false, textStyle: {color: "#000"}}, emphasis: {show: true, textStyle: {color: "rgb(100,0,0)"}}},
                itemStyle: {normal: {borderWidth: 0.5, borderColor: "#444", color: "#eee"}, emphasis: {color: "rgba(255,215,0,0.8)"}},
                regions: []
            },
            getRegionModel: function(K) {
                return this._optionModelMap.get(K) || new G(null, this, this.ecModel)
            },
            getFormattedLabel: function(N, P) {
                var M = this.getRegionModel(N);
                var K = M.get("label." + P + ".formatter");
                var O = {name: N};
                if (typeof K === "function") {
                    O.status = P;
                    return K(O)
                } else {
                    if (typeof K === "string") {
                        var L = O.seriesName;
                        return K.replace("{a}", L != null ? L : "")
                    }
                }
            },
            setZoom: function(K) {
                this.option.zoom = K
            },
            setCenter: function(K) {
                this.option.center = K
            }
        });
        C.mixin(F, E);
        H.exports = F
    }, function(C, D, A) {
        var B = A(182);
        C.exports = A(1).extendComponentView({
            type: "geo", init: function(E, G) {
                var F = new B(G, true);
                this._mapDraw = F;
                this.group.add(F.group)
            }, render: function(F, E, I, G) {
                if (G && G.type === "geoToggleSelect" && G.from === this.uid) {
                    return
                }
                var H = this._mapDraw;
                if (F.get("show")) {
                    H.draw(F, E, I, this, G)
                } else {
                    this._mapDraw.group.removeAll()
                }
                this.group.silent = F.get("silent")
            }, dispose: function() {
                this._mapDraw && this._mapDraw.remove()
            }
        })
    }, function(B, C, A) {
        A(1).registerPreprocessor(A(348));
        A(349);
        A(353);
        A(354);
        A(355);
        A(356)
    }, function(D, F, C) {
        var B = C(4);
        var E = ["rect", "polygon", "keep", "clear"];
        D.exports = function(K, L) {
            var H = K && K.brush;
            if (!B.isArray(H)) {
                H = H ? [H] : []
            }
            if (!H.length) {
                return
            }
            var N = [];
            B.each(H, function(P) {
                var O = P.hasOwnProperty("toolbox") ? P.toolbox : [];
                if (O instanceof Array) {
                    N = N.concat(O)
                }
            });
            var M = K && K.toolbox;
            if (B.isArray(M)) {
                M = M[0]
            }
            if (!M) {
                M = {feature: {}};
                K.toolbox = [M]
            }
            var I = (M.feature || (M.feature = {}));
            var G = I.brush || (I.brush = {});
            var J = G.type || (G.type = []);
            J.push.apply(J, N);
            A(J);
            if (L && !J.length) {
                J.push.apply(J, E)
            }
        };

        function A(H) {
            var G = {};
            B.each(H, function(I) {
                G[I] = 1
            });
            H.length = 0;
            B.each(G, function(J, I) {
                H.push(I)
            })
        }
    }, function(Q, J, R) {
        var G = R(1);
        var V = R(350);
        var H = R(4);
        var S = R(9);
        var I = R(351);
        var F = R(81);
        var M = R(352);
        var C = ["inBrush", "outOfBrush"];
        var L = "__ecBrushSelect";
        var P = "__ecInBrushSelectEvent";
        var O = G.PRIORITY.VISUAL.BRUSH;
        G.registerLayout(O, function(W, Y, X) {
            W.eachComponent({mainType: "brush"}, function(a) {
                X && X.type === "takeGlobalCursor" && a.setBrushOption(X.key === "brush" ? X.brushOption : {brushType: false});
                var Z = a.brushTargetManager = new M(a.option, W);
                Z.setInputRanges(a.areas, W)
            })
        });
        G.registerVisual(O, function(X, b, Y) {
            var a = [];
            var W;
            var Z;
            X.eachComponent({mainType: "brush"}, function(n, f) {
                var h = {brushId: n.id, brushIndex: f, brushName: n.name, areas: H.clone(n.areas), selected: []};
                a.push(h);
                var o = n.option;
                var j = o.brushLink;
                var c = [];
                var m = [];
                var i = [];
                var p = 0;
                if (!f) {
                    W = o.throttleType;
                    Z = o.throttleDelay
                }
                var l = H.map(n.areas, function(r) {
                    return E(H.defaults({boundingRect: A[r.brushType](r)}, r))
                });
                var q = V.createVisualMappings(n.option, C, function(r) {
                    r.mappingMethod = "fixed"
                });
                H.isArray(j) && H.each(j, function(r) {
                    c[r] = 1
                });

                function k(r) {
                    return j === "all" || c[r]
                }

                function g(r) {
                    return !!r.length
                }

                X.eachSeries(function(r, s) {
                    var t = i[s] = [];
                    r.subType === "parallel" ? e(r, s, t) : d(r, s, t)
                });

                function e(r, s) {
                    var t = r.coordinateSystem;
                    p |= t.hasAxisBrushed();
                    k(s) && t.eachActiveState(r.getData(), function(u, v) {
                        u === "active" && (m[v] = 1)
                    })
                }

                function d(r, s, u) {
                    var t = D(r);
                    if (!t || N(n, s)) {
                        return
                    }
                    H.each(l, function(w) {
                        t[w.brushType] && n.brushTargetManager.controlSeries(w, r, X) && u.push(w);
                        p |= g(u)
                    });
                    if (k(s) && g(u)) {
                        var v = r.getData();
                        v.each(function(w) {
                            if (U(t, u, v, w)) {
                                m[w] = 1
                            }
                        })
                    }
                }

                X.eachSeries(function(s, t) {
                    var u = {seriesId: s.id, seriesIndex: t, seriesName: s.name, dataIndex: []};
                    h.selected.push(u);
                    var v = D(s);
                    var w = i[t];
                    var x = s.getData();
                    var r = k(t) ? function(y) {
                        return m[y] ? (u.dataIndex.push(x.getRawIndex(y)), "inBrush") : "outOfBrush"
                    } : function(y) {
                        return U(v, w, x, y) ? (u.dataIndex.push(x.getRawIndex(y)), "inBrush") : "outOfBrush"
                    };
                    (k(t) ? p : g(w)) && V.applyVisual(C, q, x, r)
                })
            });
            B(b, W, Z, a, Y)
        });

        function B(c, W, a, b, Z) {
            if (!Z) {
                return
            }
            var X = c.getZr();
            if (X[P]) {
                return
            }
            if (!X[L]) {
                X[L] = T
            }
            var Y = F.createOrUpdate(X, L, a, W);
            Y(c, b)
        }

        function T(Y, X) {
            if (!Y.isDisposed()) {
                var W = Y.getZr();
                W[P] = true;
                Y.dispatchAction({type: "brushSelect", batch: X});
                W[P] = false
            }
        }

        function U(a, b, c, W) {
            for (var X = 0, Z = b.length; X < Z; X++) {
                var Y = b[X];
                if (a[Y.brushType](W, c, Y.selectors, Y)) {
                    return true
                }
            }
        }

        function D(W) {
            var Y = W.brushSelector;
            if (H.isString(Y)) {
                var X = [];
                H.each(I, function(a, b) {
                    X[b] = function(c, g, e, d) {
                        var f = g.getItemLayout(c);
                        return a[Y](f, e, d)
                    }
                });
                return X
            } else {
                if (H.isFunction(Y)) {
                    var Z = {};
                    H.each(I, function(a, b) {
                        Z[b] = Y
                    });
                    return Z
                }
            }
            return Y
        }

        function N(X, W) {
            var Y = X.option.seriesIndex;
            return Y != null && Y !== "all" && (H.isArray(Y) ? H.indexOf(Y, W) < 0 : W !== Y)
        }

        function E(X) {
            var W = X.selectors = {};
            H.each(I[X.brushType], function(Z, Y) {
                W[Y] = function(a) {
                    return Z(a, W, X)
                }
            });
            return X
        }

        var A = {
            lineX: H.noop, lineY: H.noop, rect: function(W) {
                return K(W.range)
            }, polygon: function(b) {
                var X;
                var a = b.range;
                for (var W = 0, Z = a.length; W < Z; W++) {
                    X = X || [[Infinity, -Infinity], [Infinity, -Infinity]];
                    var Y = a[W];
                    Y[0] < X[0][0] && (X[0][0] = Y[0]);
                    Y[0] > X[0][1] && (X[0][1] = Y[0]);
                    Y[1] < X[1][0] && (X[1][0] = Y[1]);
                    Y[1] > X[1][1] && (X[1][1] = Y[1])
                }
                return X && K(X)
            }
        };

        function K(W) {
            return new S(W[0][0], W[1][0], W[0][1] - W[0][0], W[1][1] - W[1][0])
        }
    }, function(G, H, D) {
        var C = D(4);
        var B = D(203);
        var A = C.each;

        function F(I) {
            if (I) {
                for (var J in I) {
                    if (I.hasOwnProperty(J)) {
                        return true
                    }
                }
            }
        }

        var E = {
            createVisualMappings: function(I, L, K) {
                var J = {};
                A(L, function(O) {
                    var N = J[O] = M();
                    A(I[O], function(R, Q) {
                        if (!B.isValidType(Q)) {
                            return
                        }
                        var P = {type: Q, visual: R};
                        K && K(P, O);
                        N[Q] = new B(P);
                        if (Q === "opacity") {
                            P = C.clone(P);
                            P.type = "colorAlpha";
                            N.__hidden.__alphaForOpacity = new B(P)
                        }
                    })
                });
                return J;

                function M() {
                    var O = function() {
                    };
                    O.prototype.__hidden = O.prototype;
                    var N = new O();
                    return N
                }
            }, replaceVisualOption: function(L, K, J) {
                var I;
                C.each(J, function(M) {
                    if (K.hasOwnProperty(M) && F(K[M])) {
                        I = true
                    }
                });
                I && C.each(J, function(M) {
                    if (K.hasOwnProperty(M) && F(K[M])) {
                        L[M] = C.clone(K[M])
                    } else {
                        delete L[M]
                    }
                })
            }, applyVisual: function(Q, S, J, O, L, K) {
                var M = {};
                C.each(Q, function(U) {
                    var T = B.prepareVisualTypes(S[U]);
                    M[U] = T
                });
                var R;

                function I(T) {
                    return J.getItemVisual(R, T)
                }

                function N(T, U) {
                    J.setItemVisual(R, T, U)
                }

                if (K == null) {
                    J.each(P, true)
                } else {
                    J.each([K], P, true)
                }

                function P(U, V) {
                    R = K == null ? U : V;
                    var b = J.getRawDataItem(R);
                    if (b && b.visualMap === false) {
                        return
                    }
                    var Z = O.call(L, U);
                    var Y = S[Z];
                    var X = M[Z];
                    for (var W = 0, T = X.length; W < T; W++) {
                        var a = X[W];
                        Y[a] && Y[a].applyVisual(U, I, N)
                    }
                }
            }
        };
        G.exports = E
    }, function(J, L, C) {
        var A = C(175).contain;
        var G = C(9);
        var H = {
            lineX: K(0), lineY: K(1), rect: {
                point: function(N, M, O) {
                    return O.boundingRect.contain(N[0], N[1])
                }, rect: function(N, M, O) {
                    return O.boundingRect.intersect(N)
                }
            }, polygon: {
                point: function(N, M, O) {
                    return O.boundingRect.contain(N[0], N[1]) && A(O.range, N[0], N[1])
                }, rect: function(T, U, P) {
                    var O = P.range;
                    if (O.length <= 1) {
                        return false
                    }
                    var R = T.x;
                    var S = T.y;
                    var Q = T.width;
                    var N = T.height;
                    var M = O[0];
                    if (A(O, R, S) || A(O, R + Q, S) || A(O, R, S + N) || A(O, R + Q, S + N) || G.create(T).contain(M[0], M[1]) || E(R, S, R + Q, S, O) || E(R, S, R, S + N, O) || E(R + Q, S, R + Q, S + N, O) || E(R, S + N, R + Q, S + N, O)) {
                        return true
                    }
                }
            }
        };

        function K(N) {
            var M = ["x", "y"];
            var O = ["width", "height"];
            return {
                point: function(R, Q, T) {
                    var S = T.range;
                    var P = R[N];
                    return I(P, S)
                }, rect: function(R, P, T) {
                    var S = T.range;
                    var Q = [R[M[N]], R[M[N]] + R[O[N]]];
                    Q[1] < Q[0] && Q.reverse();
                    return I(Q[0], S) || I(Q[1], S) || I(S[0], Q) || I(S[1], Q)
                }
            }
        }

        function I(M, N) {
            return N[0] <= M && M <= N[1]
        }

        function E(O, N, S, T, R) {
            for (var P = 0, Q = R[R.length - 1]; P < R.length; P++) {
                var M = R[P];
                if (B(O, N, S, T, M[0], M[1], Q[0], Q[1])) {
                    return true
                }
                Q = M
            }
        }

        function B(P, W, S, R, N, O, Q, T) {
            var V = D(S - P, N - Q, R - W, O - T);
            if (F(V)) {
                return false
            }
            var U = D(N - P, N - Q, O - W, O - T) / V;
            if (U < 0 || U > 1) {
                return false
            }
            var M = D(S - P, N - P, R - W, O - W) / V;
            if (M < 0 || M > 1) {
                return false
            }
            return true
        }

        function F(M) {
            return M <= (1e-06) && M >= -(1e-06)
        }

        function D(O, P, M, N) {
            return O * N - P * M
        }

        J.exports = H
    }, function(S, H, U) {
        var G = U(4);
        var N = U(18);
        var E = U(5);
        var M = U(246);
        var J = G.each;
        var W = G.indexOf;
        var P = G.curry;
        var Q = ["dataToPoint", "pointToData"];
        var C = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];

        function L(Z, b, a) {
            var c = this._targetInfoList = [];
            var d = {};
            var e = F(b, Z);
            J(Y, function(g, f) {
                if (!a || !a.include || W(a.include, f) >= 0) {
                    g(e, c, d)
                }
            })
        }

        var D = L.prototype;
        D.setOutputRanges = function(Z, a) {
            this.matchOutputRanges(Z, a, function(e, b, d) {
                (e.coordRanges || (e.coordRanges = [])).push(b);
                if (!e.coordRange) {
                    e.coordRange = b;
                    var c = K[e.brushType](0, d, b);
                    e.__rangeOffset = {offset: X[e.brushType](c.values, e.range, [1, 1]), xyMinMax: c.xyMinMax}
                }
            })
        };
        D.matchOutputRanges = function(a, b, Z) {
            J(a, function(d) {
                var c = this.findTargetInfo(d, b);
                if (c && c !== true) {
                    G.each(c.coordSyses, function(f) {
                        var e = K[d.brushType](1, f, d.range);
                        Z(d, e.values, f, b)
                    })
                }
            }, this)
        };
        D.setInputRanges = function(Z, a) {
            J(Z, function(e) {
                var d = this.findTargetInfo(e, a);
                if (true) {
                    G.assert(!d || d === true || e.coordRange, "coordRange must be specified when coord index specified.");
                    G.assert(!d || d !== true || e.range, "range must be specified in global brush.")
                }
                e.range = e.range || [];
                if (d && d !== true) {
                    e.panelId = d.panelId;
                    var b = K[e.brushType](0, d.coordSys, e.coordRange);
                    var c = e.__rangeOffset;
                    e.range = c ? X[e.brushType](b.values, c.offset, R(b.xyMinMax, c.xyMinMax)) : b.values
                }
            }, this)
        };
        D.makePanelOpts = function(Z, a) {
            return G.map(this._targetInfoList, function(c) {
                var b = c.getPanelRect();
                return {
                    panelId: c.panelId,
                    defaultBrushType: a && a(c),
                    clipPath: M.makeRectPanelClipPath(b),
                    isTargetByCursor: M.makeRectIsTargetByCursor(b, Z, c.coordSysModel),
                    getLinearBrushOtherExtent: M.makeLinearBrushOtherExtent(b)
                }
            })
        };
        D.controlSeries = function(c, Z, a) {
            var b = this.findTargetInfo(c, a);
            return b === true || (b && W(b.coordSyses, Z.coordinateSystem) >= 0)
        };
        D.findTargetInfo = function(f, b) {
            var c = this._targetInfoList;
            var a = F(b, f);
            for (var Z = 0; Z < c.length; Z++) {
                var e = c[Z];
                var d = f.panelId;
                if (d) {
                    if (e.panelId === d) {
                        return e
                    }
                } else {
                    for (var Z = 0; Z < A.length; Z++) {
                        if (A[Z](a, e)) {
                            return e
                        }
                    }
                }
            }
            return true
        };

        function B(Z) {
            Z[0] > Z[1] && Z.reverse();
            return Z
        }

        function F(a, Z) {
            return E.parseFinder(a, Z, {includeMainTypes: C})
        }

        var Y = {
            grid: function(d, b) {
                var g = d.xAxisModels;
                var f = d.yAxisModels;
                var c = d.gridModels;
                var e = G.createHashMap();
                var Z = {};
                var a = {};
                if (!g && !f && !c) {
                    return
                }
                J(g, function(i) {
                    var h = i.axis.grid.model;
                    e.set(h.id, h);
                    Z[h.id] = true
                });
                J(f, function(i) {
                    var h = i.axis.grid.model;
                    e.set(h.id, h);
                    a[h.id] = true
                });
                J(c, function(h) {
                    e.set(h.id, h);
                    Z[h.id] = true;
                    a[h.id] = true
                });
                e.each(function(h) {
                    var j = h.coordinateSystem;
                    var i = [];
                    J(j.getCartesians(), function(l, k) {
                        if (W(g, l.getAxis("x").model) >= 0 || W(f, l.getAxis("y").model) >= 0) {
                            i.push(l)
                        }
                    });
                    b.push({
                        panelId: "grid--" + h.id,
                        gridModel: h,
                        coordSysModel: h,
                        coordSys: i[0],
                        coordSyses: i,
                        getPanelRect: I.grid,
                        xAxisDeclared: Z[h.id],
                        yAxisDeclared: a[h.id]
                    })
                })
            }, geo: function(Z, a) {
                J(Z.geoModels, function(b) {
                    var c = b.coordinateSystem;
                    a.push({panelId: "geo--" + b.id, geoModel: b, coordSysModel: b, coordSys: c, coordSyses: [c], getPanelRect: I.geo})
                })
            }
        };
        var A = [function(b, c) {
            var d = b.xAxisModel;
            var Z = b.yAxisModel;
            var a = b.gridModel;
            !a && d && (a = d.axis.grid.model);
            !a && Z && (a = Z.axis.grid.model);
            return a && a === c.gridModel
        }, function(Z, b) {
            var a = Z.geoModel;
            return a && a === b.geoModel
        }];
        var I = {
            grid: function() {
                return this.coordSys.grid.getRect().clone()
            }, geo: function() {
                var Z = this.coordSys;
                var a = Z.getBoundingRect().clone();
                a.applyTransform(N.getTransform(Z));
                return a
            }
        };
        var K = {
            lineX: P(V, 0), lineY: P(V, 1), rect: function(a, b, c) {
                var Z = b[Q[a]]([c[0][0], c[1][0]]);
                var e = b[Q[a]]([c[0][1], c[1][1]]);
                var d = [B([Z[0], e[0]]), B([Z[1], e[1]])];
                return {values: d, xyMinMax: d}
            }, polygon: function(Z, a, b) {
                var d = [[Infinity, -Infinity], [Infinity, -Infinity]];
                var c = G.map(b, function(f) {
                    var e = a[Q[Z]](f);
                    d[0][0] = Math.min(d[0][0], e[0]);
                    d[1][0] = Math.min(d[1][0], e[1]);
                    d[0][1] = Math.max(d[0][1], e[0]);
                    d[1][1] = Math.max(d[1][1], e[1]);
                    return e
                });
                return {values: c, xyMinMax: d}
            }
        };

        function V(c, a, b, d) {
            if (true) {
                G.assert(b.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.")
            }
            var f = b.getAxis(["x", "y"][c]);
            var e = B(G.map([0, 1], function(g) {
                return a ? f.coordToData(f.toLocalCoord(d[g])) : f.toGlobalCoord(f.dataToCoord(d[g]))
            }));
            var Z = [];
            Z[c] = e;
            Z[1 - c] = [NaN, NaN];
            return {values: e, xyMinMax: Z}
        }

        var X = {
            lineX: P(T, 0), lineY: P(T, 1), rect: function(b, a, Z) {
                return [[b[0][0] - Z[0] * a[0][0], b[0][1] - Z[0] * a[0][1]], [b[1][0] - Z[1] * a[1][0], b[1][1] - Z[1] * a[1][1]]]
            }, polygon: function(b, a, Z) {
                return G.map(b, function(c, d) {
                    return [c[0] - Z[0] * a[d][0], c[1] - Z[1] * a[d][1]]
                })
            }
        };

        function T(a, b, c, Z) {
            return [b[0] - Z[a] * c[0], b[1] - Z[a] * c[1]]
        }

        function R(d, Z) {
            var c = O(d);
            var a = O(Z);
            var b = [c[0] / a[0], c[1] / a[1]];
            isNaN(b[0]) && (b[0] = 1);
            isNaN(b[1]) && (b[1] = 1);
            return b
        }

        function O(Z) {
            return Z ? [Z[0][1] - Z[0][0], Z[1][1] - Z[1][0]] : [NaN, NaN]
        }

        S.exports = L
    }, function(I, J, D) {
        var C = D(1);
        var F = D(4);
        var E = D(350);
        var H = D(12);
        var G = ["#ddd"];
        var B = C.extendComponentModel({
            type: "brush",
            dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
            defaultOption: {
                toolbox: null,
                brushLink: null,
                seriesIndex: "all",
                geoIndex: null,
                xAxisIndex: null,
                yAxisIndex: null,
                brushType: "rect",
                brushMode: "single",
                transformable: true,
                brushStyle: {borderWidth: 1, color: "rgba(120,140,180,0.3)", borderColor: "rgba(120,140,180,0.8)"},
                throttleType: "fixRate",
                throttleDelay: 0,
                removeOnClick: true,
                z: 10000
            },
            areas: [],
            brushType: null,
            brushOption: {},
            coordInfoList: [],
            optionUpdated: function(K, L) {
                var M = this.option;
                !L && E.replaceVisualOption(M, K, ["inBrush", "outOfBrush"]);
                M.inBrush = M.inBrush || {};
                M.outOfBrush = M.outOfBrush || {color: G}
            },
            setAreas: function(K) {
                if (true) {
                    F.assert(F.isArray(K));
                    F.each(K, function(L) {
                        F.assert(L.brushType, "Illegal areas")
                    })
                }
                if (!K) {
                    return
                }
                this.areas = F.map(K, function(L) {
                    return A(this.option, L)
                }, this)
            },
            setBrushOption: function(K) {
                this.brushOption = A(this.option, K);
                this.brushType = this.brushOption.brushType
            }
        });

        function A(K, L) {
            return F.merge({
                brushType: K.brushType,
                brushMode: K.brushMode,
                transformable: K.transformable,
                brushStyle: new H(K.brushStyle).getItemStyle(),
                removeOnClick: K.removeOnClick,
                z: K.z
            }, L, true)
        }

        I.exports = B
    }, function(C, F, B) {
        var A = B(4);
        var G = B(245);
        var E = B(1);
        C.exports = E.extendComponentView({
            type: "brush", init: function(H, I) {
                this.ecModel = H;
                this.api = I;
                this.model;
                (this._brushController = new G(I.getZr())).on("brush", A.bind(this._onBrush, this)).mount()
            }, render: function(H) {
                this.model = H;
                return D.apply(this, arguments)
            }, updateView: D, updateLayout: D, updateVisual: D, dispose: function() {
                this._brushController.dispose()
            }, _onBrush: function(H, I) {
                var J = this.model.id;
                this.model.brushTargetManager.setOutputRanges(H, this.ecModel);
                (!I.isEnd || I.removeOnClick) && this.api.dispatchAction({type: "brush", brushId: J, areas: A.clone(H), $from: J})
            }
        });

        function D(J, I, K, H) {
            (!H || H.$from !== J.id) && this._brushController.setPanels(J.brushTargetManager.makePanelOpts(K)).enableBrush(J.brushOption).updateCovers(J.areas.slice())
        }
    }, function(B, D, A) {
        var C = A(1);
        C.registerAction({type: "brush", event: "brush", update: "updateView"}, function(F, E) {
            E.eachComponent({mainType: "brush", query: F}, function(G) {
                G.setAreas(F.areas)
            })
        });
        C.registerAction({type: "brushSelect", event: "brushSelected", update: "none"}, function() {
        })
    }, function(E, F, C) {
        var A = C(357);
        var B = C(4);

        function G(J, H, I) {
            this.model = J;
            this.ecModel = H;
            this.api = I;
            this._brushType;
            this._brushMode
        }

        G.defaultOption = {
            show: true,
            type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
            icon: {
                rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
                polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
                lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
                lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
                keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
                clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
            },
            title: {rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: ""}
        };
        var D = G.prototype;
        D.render = D.updateView = D.updateLayout = function(L, H, M) {
            var I;
            var K;
            var J;
            H.eachComponent({mainType: "brush"}, function(N) {
                I = N.brushType;
                K = N.brushOption.brushMode || "single";
                J |= N.areas.length
            });
            this._brushType = I;
            this._brushMode = K;
            B.each(L.get("type", true), function(N) {
                L.setIconStatus(N, (N === "keep" ? K === "multiple" : N === "clear" ? J : N === I) ? "emphasis" : "normal")
            })
        };
        D.getIcons = function() {
            var I = this.model;
            var J = I.get("icon", true);
            var H = {};
            B.each(I.get("type", true), function(K) {
                if (J[K]) {
                    H[K] = J[K]
                }
            });
            return H
        };
        D.onclick = function(I, L, H) {
            var L = this.api;
            var K = this._brushType;
            var J = this._brushMode;
            if (H === "clear") {
                L.dispatchAction({type: "axisAreaSelect", intervals: []});
                L.dispatchAction({type: "brush", command: "clear", areas: []})
            } else {
                L.dispatchAction({
                    type: "takeGlobalCursor",
                    key: "brush",
                    brushOption: {
                        brushType: H === "keep" ? K : (K === H ? false : H),
                        brushMode: H === "keep" ? (J === "multiple" ? "single" : "multiple") : J
                    }
                })
            }
        };
        A.register("brush", G);
        E.exports = G
    }, function(B, C) {
        var A = {};
        B.exports = {
            register: function(E, D) {
                A[E] = D
            }, get: function(D) {
                return A[D]
            }
        }
    }, function(B, C, A) {
        A(359);
        A(360);
        A(361)
    }, function(G, I, B) {
        var D = B(71);
        var C = B(7);
        var A = B(4);
        var H = 86400000;

        function F(J, K, L) {
            this._model = J
        }

        F.prototype = {
            constructor: F, type: "calendar", dimensions: ["time", "value"], getDimensionsInfo: function() {
                return [{name: "time", type: "time"}]
            }, getRangeInfo: function() {
                return this._rangeInfo
            }, getModel: function() {
                return this._model
            }, getRect: function() {
                return this._rect
            }, getCellWidth: function() {
                return this._sw
            }, getCellHeight: function() {
                return this._sh
            }, getOrient: function() {
                return this._orient
            }, getFirstDayOfWeek: function() {
                return this._firstDayOfWeek
            }, getDateInfo: function(N) {
                N = C.parseDate(N);
                var M = N.getFullYear();
                var L = N.getMonth() + 1;
                L = L < 10 ? "0" + L : L;
                var J = N.getDate();
                J = J < 10 ? "0" + J : J;
                var K = N.getDay();
                K = Math.abs((K + 7 - this.getFirstDayOfWeek()) % 7);
                return {y: M, m: L, d: J, day: K, time: N.getTime(), formatedDate: M + "-" + L + "-" + J, date: N}
            }, getNextNDay: function(L, J) {
                J = J || 0;
                if (J === 0) {
                    return this.getDateInfo(L)
                }
                var K = this.getDateInfo(L).time;
                return this.getDateInfo(K + H * J)
            }, update: function(K, R) {
                this._firstDayOfWeek = this._model.getModel("dayLabel").get("firstDay");
                this._orient = this._model.get("orient");
                this._lineWidth = this._model.getModel("itemStyle.normal").getItemStyle().lineWidth || 0;
                this._rangeInfo = this._getRangeInfo(this._initRangeOption());
                var O = this._rangeInfo.weeks || 1;
                var J = ["width", "height"];
                var L = this._model.get("cellSize").slice();
                var P = this._model.getBoxLayoutParams();
                var S = this._orient === "horizontal" ? [O, 7] : [7, O];
                A.each([0, 1], function(T) {
                    if (N(L, T)) {
                        P[J[T]] = L[T] * S[T]
                    }
                });
                var Q = {width: R.getWidth(), height: R.getHeight()};
                var M = this._rect = D.getLayoutRect(P, Q);
                A.each([0, 1], function(T) {
                    if (!N(L, T)) {
                        L[T] = M[J[T]] / S[T]
                    }
                });

                function N(T, U) {
                    return T[U] != null && T[U] !== "auto"
                }

                this._sw = L[0];
                this._sh = L[1]
            }, dataToPoint: function(P, L) {
                A.isArray(P) && (P = P[0]);
                L == null && (L = true);
                var K = this.getDateInfo(P);
                var O = this._rangeInfo;
                var N = K.formatedDate;
                if (L && !(K.time >= O.start.time && K.time <= O.end.time)) {
                    return [NaN, NaN]
                }
                var J = K.day;
                var M = this._getRangeInfo([O.start.time, N]).weeks;
                if (this._orient === "vertical") {
                    return [this._rect.x + J * this._sw + this._sw / 2, this._rect.y + (M - 1) * this._sh + this._sh / 2]
                }
                return [this._rect.x + (M - 1) * this._sw + this._sw / 2, this._rect.y + J * this._sh + this._sh / 2]
            }, pointToData: function(J) {
                var K = this.pointToDate(J);
                return K && K.time
            }, dataToRect: function(L, K) {
                var J = this.dataToPoint(L, K);
                return {
                    contentShape: {
                        x: J[0] - (this._sw - this._lineWidth) / 2,
                        y: J[1] - (this._sh - this._lineWidth) / 2,
                        width: this._sw - this._lineWidth,
                        height: this._sh - this._lineWidth
                    },
                    center: J,
                    tl: [J[0] - this._sw / 2, J[1] - this._sh / 2],
                    tr: [J[0] + this._sw / 2, J[1] - this._sh / 2],
                    br: [J[0] + this._sw / 2, J[1] + this._sh / 2],
                    bl: [J[0] - this._sw / 2, J[1] + this._sh / 2]
                }
            }, pointToDate: function(K) {
                var J = Math.floor((K[0] - this._rect.x) / this._sw) + 1;
                var L = Math.floor((K[1] - this._rect.y) / this._sh) + 1;
                var M = this._rangeInfo.range;
                if (this._orient === "vertical") {
                    return this._getDateByWeeksAndDay(L, J - 1, M)
                }
                return this._getDateByWeeksAndDay(J, L - 1, M)
            }, convertToPixel: A.curry(E, "dataToPoint"), convertFromPixel: A.curry(E, "pointToData"), _initRangeOption: function() {
                var N = this._model.get("range");
                var L = N;
                if (A.isArray(L) && L.length === 1) {
                    L = L[0]
                }
                if (/^\d{4}$/.test(L)) {
                    N = [L + "-01-01", L + "-12-31"]
                }
                if (/^\d{4}[\/|-]\d{1,2}$/.test(L)) {
                    var O = this.getDateInfo(L);
                    var K = O.date;
                    K.setMonth(K.getMonth() + 1);
                    var M = this.getNextNDay(K, -1);
                    N = [O.formatedDate, M.formatedDate]
                }
                if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(L)) {
                    N = [L, L]
                }
                var J = this._getRangeInfo(N);
                if (J.start.time > J.end.time) {
                    N.reverse()
                }
                return N
            }, _getRangeInfo: function(M) {
                var N = this.getDateInfo(M[0]);
                var L = this.getDateInfo(M[1]);
                var J = Math.floor(L.time / H) - Math.floor(N.time / H) + 1;
                var K = Math.floor((J + N.day + 6) / 7);
                return {range: [N.formatedDate, L.formatedDate], start: N, end: L, allDay: J, weeks: K, fweek: N.day, lweek: L.day}
            }, _getDateByWeeksAndDay: function(M, L, O) {
                var N = this._getRangeInfo(O);
                if (M > N.weeks || (M === 0 && L < N.fweek) || (M === N.weeks && L > N.lweek)) {
                    return false
                }
                var J = (M - 1) * 7 - N.fweek + L;
                var K = N.start.time + J * H;
                return this.getDateInfo(K)
            }
        };
        F.dimensions = F.prototype.dimensions;
        F.getDimensionsInfo = F.prototype.getDimensionsInfo;
        F.create = function(J, L) {
            var K = [];
            J.eachComponent("calendar", function(N) {
                var M = new F(N, J, L);
                K.push(M);
                N.coordinateSystem = M
            });
            J.eachSeries(function(M) {
                if (M.get("coordinateSystem") === "calendar") {
                    M.coordinateSystem = K[M.get("calendarIndex") || 0]
                }
            });
            return K
        };

        function E(L, K, O, N) {
            var J = O.calendarModel;
            var M = O.seriesModel;
            var P = J ? J.coordinateSystem : M ? M.coordinateSystem : null;
            return P === this ? P[L](N) : null
        }

        B(76).register("calendar", F);
        G.exports = F
    }, function(F, H, C) {
        var G = C(69);
        var B = C(4);
        var D = C(71);
        var E = G.extend({
            type: "calendar",
            coordinateSystem: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                left: 80,
                top: 60,
                cellSize: 20,
                orient: "horizontal",
                splitLine: {show: true, lineStyle: {color: "#000", width: 1, type: "solid"}},
                itemStyle: {normal: {color: "#fff", borderWidth: 1, borderColor: "#ccc"}},
                dayLabel: {show: true, firstDay: 0, position: "start", margin: "50%", nameMap: "en", textStyle: {color: "#000"}},
                monthLabel: {show: true, position: "start", margin: 5, align: "center", nameMap: "en", formatter: null, textStyle: {color: "#000"}},
                yearLabel: {
                    show: true,
                    position: null,
                    margin: 30,
                    formatter: null,
                    textStyle: {color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20}
                }
            },
            init: function(J, M, K, L) {
                var I = D.getLayoutParams(J);
                E.superApply(this, "init", arguments);
                A(J, I)
            },
            mergeOption: function(I, J) {
                E.superApply(this, "mergeOption", arguments);
                A(this.option, I)
            }
        });

        function A(K, L) {
            var J = K.cellSize;
            if (!B.isArray(J)) {
                J = K.cellSize = [J, J]
            } else {
                if (J.length === 1) {
                    J[1] = J[0]
                }
            }
            var I = B.map([0, 1], function(M) {
                if (D.sizeCalculable(L, M)) {
                    J[M] = "auto"
                }
                return J[M] != null && J[M] !== "auto"
            });
            D.mergeLayoutParam(K, L, {type: "box", ignoreSize: I})
        }

        F.exports = E
    }, function(G, I, C) {
        var A = C(4);
        var F = C(18);
        var B = C(6);
        var D = C(7);
        var E = {
            EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            CN: ["", "", "", "", "", "", "", "", "", "", "", ""]
        };
        var H = {EN: ["S", "M", "T", "W", "T", "F", "S"], CN: ["", "", "", "", "", "", ""]};
        G.exports = C(1).extendComponentView({
            type: "calendar",
            _tlpoints: null,
            _blpoints: null,
            _firstDayOfMonth: null,
            _firstDayPoints: null,
            render: function(J, L, O) {
                var N = this.group;
                N.removeAll();
                var M = J.coordinateSystem;
                var K = M.getRangeInfo();
                var P = M.getOrient();
                this._renderDayRect(J, K, N);
                this._renderLines(J, K, P, N);
                this._renderYearText(J, K, P, N);
                this._renderMonthText(J, P, N);
                this._renderWeekText(J, K, P, N)
            },
            _renderDayRect: function(M, L, O) {
                var J = M.coordinateSystem;
                var P = M.getModel("itemStyle.normal").getItemStyle();
                var N = J.getCellWidth();
                var R = J.getCellHeight();
                for (var Q = L.start.time; Q <= L.end.time; Q = J.getNextNDay(Q, 1).time) {
                    var S = J.dataToRect([Q], false).tl;
                    var K = new F.Rect({shape: {x: S[0], y: S[1], width: N, height: R}, cursor: "default", style: P});
                    O.add(K)
                }
            },
            _renderLines: function(M, L, Q, P) {
                var T = this;
                var J = M.coordinateSystem;
                var K = M.getModel("splitLine.lineStyle").getLineStyle();
                var V = M.get("splitLine.show");
                var R = K.lineWidth;
                this._tlpoints = [];
                this._blpoints = [];
                this._firstDayOfMonth = [];
                this._firstDayPoints = [];
                var N = L.start;
                for (var O = 0; N.time <= L.end.time; O++) {
                    S(N.formatedDate);
                    if (O === 0) {
                        N = J.getDateInfo(L.start.y + "-" + L.start.m)
                    }
                    var U = N.date;
                    U.setMonth(U.getMonth() + 1);
                    N = J.getDateInfo(U)
                }
                S(J.getNextNDay(L.end.time, 1).formatedDate);

                function S(X) {
                    T._firstDayOfMonth.push(J.getDateInfo(X));
                    T._firstDayPoints.push(J.dataToRect([X], false).tl);
                    var W = T._getLinePointsOfOneWeek(M, X, Q);
                    T._tlpoints.push(W[0]);
                    T._blpoints.push(W[W.length - 1]);
                    V && T._drawSplitline(W, K, P)
                }

                V && this._drawSplitline(T._getEdgesPoints(T._tlpoints, R, Q), K, P);
                V && this._drawSplitline(T._getEdgesPoints(T._blpoints, R, Q), K, P)
            },
            _getEdgesPoints: function(L, M, N) {
                var J = [L[0].slice(), L[L.length - 1].slice()];
                var K = N === "horizontal" ? 0 : 1;
                J[0][K] = J[0][K] - M / 2;
                J[1][K] = J[1][K] + M / 2;
                return J
            },
            _drawSplitline: function(L, K, J) {
                var M = new F.Polyline({z2: 20, shape: {points: L}, style: K});
                J.add(M)
            },
            _getLinePointsOfOneWeek: function(K, Q, M) {
                var J = K.coordinateSystem;
                Q = J.getDateInfo(Q);
                var N = [];
                for (var L = 0; L < 7; L++) {
                    var P = J.getNextNDay(Q.time, L);
                    var O = J.dataToRect([P.time], false);
                    N[2 * P.day] = O.tl;
                    N[2 * P.day + 1] = O[M === "horizontal" ? "bl" : "tr"]
                }
                return N
            },
            _formatterLabel: function(J, K) {
                if (typeof J === "string" && J) {
                    return B.formatTplSimple(J, K)
                }
                if (typeof J === "function") {
                    return J(K)
                }
                return K.nameMap
            },
            _yearTextPositionControl: function(L, O, M, J) {
                L = L.slice();
                var K = ["center", "bottom"];
                if (M === "top") {
                    L[1] -= J
                }
                if (M === "bottom") {
                    L[1] += J;
                    K = ["center", "top"]
                }
                if (M === "left") {
                    L[0] -= J
                }
                if (M === "right") {
                    L[0] += J;
                    K = ["center", "top"]
                }
                var N = 0;
                if (M === "left" || M === "right") {
                    N = Math.PI / 2
                }
                return {rotation: N, origin: L, style: {x: L[0], y: L[1], textAlign: K[0], textVerticalAlign: K[1]}}
            },
            _renderYearText: function(P, R, Q, S) {
                var N = P.getModel("yearLabel");
                if (!N.get("show")) {
                    return
                }
                var X = P.getModel("yearLabel.textStyle");
                var O = N.get("margin");
                var Z = N.get("position");
                if (!Z) {
                    Z = Q !== "horizontal" ? "top" : "left"
                }
                var T = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
                var L = (T[0][0] + T[1][0]) / 2;
                var M = (T[0][1] + T[1][1]) / 2;
                var a = Q === "horizontal" ? 0 : 1;
                var U = {top: [L, T[a][1]], bottom: [L, T[1 - a][1]], left: [T[1 - a][0], M], right: [T[a][0], M]};
                var Y = R.start.y;
                if (+R.end.y > +R.start.y) {
                    Y = Y + "-" + R.end.y
                }
                var K = N.get("formatter");
                var W = {start: R.start.y, end: R.end.y, nameMap: Y};
                var V = this._formatterLabel(K, W);
                var J = new F.Text(A.merge({
                    z2: 30,
                    style: {text: V, font: X.getFont(), fill: X.getTextColor()}
                }, this._yearTextPositionControl(U[Z], Q, Z, O)));
                S.add(J)
            },
            _monthTextPositionControl: function(Q, K, M, N, J) {
                var L = "left";
                var R = "top";
                var O = Q[0];
                var P = Q[1];
                if (M === "horizontal") {
                    P = P + J;
                    if (K) {
                        L = "center"
                    }
                    if (N === "start") {
                        R = "bottom"
                    }
                } else {
                    O = O + J;
                    if (K) {
                        R = "middle"
                    }
                    if (N === "start") {
                        L = "right"
                    }
                }
                return {x: O, y: P, textAlign: L, textVerticalAlign: R}
            },
            _renderMonthText: function(U, S, Y) {
                var e = U.getModel("monthLabel");
                if (!e.get("show")) {
                    return
                }
                var V = U.getModel("monthLabel.textStyle");
                var T = e.get("nameMap");
                var O = e.get("margin");
                var X = e.get("position");
                var M = e.get("align");
                var Z = [this._tlpoints, this._blpoints];
                if (A.isString(T)) {
                    T = E[T.toUpperCase()] || []
                }
                var c = X === "start" ? 0 : 1;
                var W = S === "horizontal" ? 0 : 1;
                O = X === "start" ? -O : O;
                var b = (M === "center");
                for (var Q = 0; Q < Z[c].length - 1; Q++) {
                    var L = Z[c][Q].slice();
                    var P = this._firstDayOfMonth[Q];
                    if (b) {
                        var R = this._firstDayPoints[Q];
                        L[W] = (R[W] + Z[0][Q + 1][W]) / 2
                    }
                    var J = e.get("formatter");
                    var a = T[+P.m - 1];
                    var K = {yyyy: P.y, yy: (P.y + "").slice(2), MM: P.m, M: +P.m, nameMap: a};
                    var N = this._formatterLabel(J, K);
                    var d = new F.Text({
                        z2: 30,
                        style: A.extend({text: N, font: V.getFont(), fill: V.getTextColor()}, this._monthTextPositionControl(L, b, S, X, O))
                    });
                    Y.add(d)
                }
            },
            _weekTextPositionControl: function(Q, M, N, J, L) {
                var K = "center";
                var S = "middle";
                var O = Q[0];
                var P = Q[1];
                var R = N === "start";
                if (M === "horizontal") {
                    O = O + J + (R ? 1 : -1) * L[0] / 2;
                    K = R ? "right" : "left"
                } else {
                    P = P + J + (R ? 1 : -1) * L[1] / 2;
                    S = R ? "bottom" : "top"
                }
                return {x: O, y: P, textAlign: K, textVerticalAlign: S}
            },
            _renderWeekText: function(N, S, P, V) {
                var W = N.getModel("dayLabel");
                if (!W.get("show")) {
                    return
                }
                var T = N.coordinateSystem;
                var X = N.getModel("dayLabel.textStyle");
                var Z = W.get("position");
                var R = W.get("nameMap");
                var M = W.get("margin");
                var J = T.getFirstDayOfWeek();
                if (A.isString(R)) {
                    R = H[R.toUpperCase()] || []
                }
                var a = T.getNextNDay(S.end.time, (7 - S.lweek)).time;
                var K = [T.getCellWidth(), T.getCellHeight()];
                M = D.parsePercent(M, K[P === "horizontal" ? 0 : 1]);
                if (Z === "start") {
                    a = T.getNextNDay(S.start.time, -(7 + S.fweek)).time;
                    M = -M
                }
                for (var O = 0; O < 7; O++) {
                    var U = T.getNextNDay(a, O);
                    var L = T.dataToRect([U.time], false).center;
                    var Y = O;
                    Y = Math.abs((O + J) % 7);
                    var Q = new F.Text({
                        z2: 30,
                        style: A.extend({text: R[Y], font: X.getFont(), fill: X.getTextColor()}, this._weekTextPositionControl(L, P, Z, M, K))
                    });
                    V.add(Q)
                }
            }
        })
    }, function(C, F, B) {
        var E = B(1);
        var A = B(18);
        var D = B(71);
        E.extendComponentModel({
            type: "title",
            layoutMode: {type: "box", ignoreSize: true},
            defaultOption: {
                zlevel: 0,
                z: 6,
                show: true,
                text: "",
                target: "blank",
                subtext: "",
                subtarget: "blank",
                left: 0,
                top: 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                textStyle: {fontSize: 18, fontWeight: "bolder", color: "#333"},
                subtextStyle: {color: "#aaa"}
            }
        });
        E.extendComponentView({
            type: "title", render: function(Q, I, K) {
                this.group.removeAll();
                if (!Q.get("show")) {
                    return
                }
                var T = this.group;
                var O = Q.getModel("textStyle");
                var W = Q.getModel("subtextStyle");
                var M = Q.get("textAlign");
                var H = Q.get("textBaseline");
                var X = new A.Text({style: {text: Q.get("text"), textFont: O.getFont(), fill: O.getTextColor()}, z2: 10});
                var a = X.getBoundingRect();
                var Y = Q.get("subtext");
                var V = new A.Text({
                    style: {text: Y, textFont: W.getFont(), fill: W.getTextColor(), y: a.height + Q.get("itemGap"), textBaseline: "top"},
                    z2: 10
                });
                var R = Q.get("link");
                var U = Q.get("sublink");
                X.silent = !R;
                V.silent = !U;
                if (R) {
                    X.on("click", function() {
                        window.open(R, "_" + Q.get("target"))
                    })
                }
                if (U) {
                    V.on("click", function() {
                        window.open(U, "_" + Q.get("subtarget"))
                    })
                }
                T.add(X);
                Y && T.add(V);
                var J = T.getBoundingRect();
                var N = Q.getBoxLayoutParams();
                N.width = J.width;
                N.height = J.height;
                var S = D.getLayoutRect(N, {width: K.getWidth(), height: K.getHeight()}, Q.get("padding"));
                if (!M) {
                    M = Q.get("left") || Q.get("right");
                    if (M === "middle") {
                        M = "center"
                    }
                    if (M === "right") {
                        S.x += S.width
                    } else {
                        if (M === "center") {
                            S.x += S.width / 2
                        }
                    }
                }
                if (!H) {
                    H = Q.get("top") || Q.get("bottom");
                    if (H === "center") {
                        H = "middle"
                    }
                    if (H === "bottom") {
                        S.y += S.height
                    } else {
                        if (H === "middle") {
                            S.y += S.height / 2
                        }
                    }
                    H = H || "top"
                }
                T.attr("position", [S.x, S.y]);
                var G = {textAlign: M, textVerticalAlign: H};
                X.setStyle(G);
                V.setStyle(G);
                J = T.getBoundingRect();
                var P = S.margin;
                var Z = Q.getItemStyle(["color", "opacity"]);
                Z.fill = Q.get("backgroundColor");
                var L = new A.Rect({
                    shape: {x: J.x - P[3], y: J.y - P[0], width: J.width + P[1] + P[3], height: J.height + P[0] + P[2]},
                    style: Z,
                    silent: true
                });
                A.subPixelOptimizeRect(L);
                T.add(L)
            }
        })
    }, function(B, C, A) {
        A(364);
        A(365);
        A(368);
        A(369);
        A(370);
        A(371);
        A(372);
        A(374);
        A(375)
    }, function(B, C, A) {
        A(69).registerSubTypeDefaulter("dataZoom", function(D) {
            return "slider"
        })
    }, function(M, N, E) {
        var I = E(4);
        var G = E(2);
        var D = E(1);
        var B = E(5);
        var L = E(366);
        var C = E(367);
        var A = I.each;
        var F = L.eachAxisDim;
        var H = D.extendComponentModel({
            type: "dataZoom",
            dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                filterMode: "filter",
                throttle: null,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null,
                minSpan: null,
                maxSpan: null,
                minValueSpan: null,
                maxValueSpan: null
            },
            init: function(O, R, Q) {
                this._dataIntervalByAxis = {};
                this._dataInfo = {};
                this._axisProxies = {};
                this.textStyleModel;
                this._autoThrottle = true;
                this._rangePropMode = ["percent", "percent"];
                var P = J(O);
                this.mergeDefaultAndTheme(O, Q);
                this.doInit(P)
            },
            mergeOption: function(P) {
                var O = J(P);
                I.merge(this.option, P, true);
                this.doInit(O)
            },
            doInit: function(O) {
                var P = this.option;
                if (!G.canvasSupported) {
                    P.realtime = false
                }
                this._setDefaultThrottle(O);
                K(this, O);
                A([["start", "startValue"], ["end", "endValue"]], function(R, Q) {
                    if (this._rangePropMode[Q] === "value") {
                        P[R[0]] = null
                    }
                }, this);
                this.textStyleModel = this.getModel("textStyle");
                this._resetTarget();
                this._giveAxisProxies()
            },
            _giveAxisProxies: function() {
                var O = this._axisProxies;
                this.eachTargetAxis(function(S, U, T, Q) {
                    var R = this.dependentModels[S.axis][U];
                    var P = R.__dzAxisProxy || (R.__dzAxisProxy = new C(S.name, U, this, Q));
                    O[S.name + "_" + U] = P
                }, this)
            },
            _resetTarget: function() {
                var P = this.option;
                var O = this._judgeAutoMode();
                F(function(Q) {
                    var R = Q.axisIndex;
                    P[R] = B.normalizeToArray(P[R])
                }, this);
                if (O === "axisIndex") {
                    this._autoSetAxisIndex()
                } else {
                    if (O === "orient") {
                        this._autoSetOrient()
                    }
                }
            },
            _judgeAutoMode: function() {
                var Q = this.option;
                var O = false;
                F(function(R) {
                    if (Q[R.axisIndex] != null) {
                        O = true
                    }
                }, this);
                var P = Q.orient;
                if (P == null && O) {
                    return "orient"
                } else {
                    if (!O) {
                        if (P == null) {
                            Q.orient = "horizontal"
                        }
                        return "axisIndex"
                    }
                }
            },
            _autoSetAxisIndex: function() {
                var Q = true;
                var R = this.get("orient", true);
                var S = this.option;
                var O = this.dependentModels;
                if (Q) {
                    var P = R === "vertical" ? "y" : "x";
                    if (O[P + "Axis"].length) {
                        S[P + "AxisIndex"] = [0];
                        Q = false
                    } else {
                        A(O.singleAxis, function(T) {
                            if (Q && T.get("orient", true) === R) {
                                S.singleAxisIndex = [T.componentIndex];
                                Q = false
                            }
                        })
                    }
                }
                if (Q) {
                    F(function(V) {
                        if (!Q) {
                            return
                        }
                        var T = [];
                        var X = this.dependentModels[V.axis];
                        if (X.length && !T.length) {
                            for (var U = 0, W = X.length; U < W; U++) {
                                if (X[U].get("type") === "category") {
                                    T.push(U)
                                }
                            }
                        }
                        S[V.axisIndex] = T;
                        if (T.length) {
                            Q = false
                        }
                    }, this)
                }
                if (Q) {
                    this.ecModel.eachSeries(function(T) {
                        if (this._isSeriesHasAllAxesTypeOf(T, "value")) {
                            F(function(W) {
                                var U = S[W.axisIndex];
                                var Y = T.get(W.axisIndex);
                                var X = T.get(W.axisId);
                                var V = T.ecModel.queryComponents({mainType: W.axis, index: Y, id: X})[0];
                                if (true) {
                                    if (!V) {
                                        throw new Error(W.axis + ' "' + I.retrieve(Y, X, 0) + '" not found')
                                    }
                                }
                                Y = V.componentIndex;
                                if (I.indexOf(U, Y) < 0) {
                                    U.push(Y)
                                }
                            })
                        }
                    }, this)
                }
            },
            _autoSetOrient: function() {
                var O;
                this.eachTargetAxis(function(P) {
                    !O && (O = P.name)
                }, this);
                this.option.orient = O === "y" ? "vertical" : "horizontal"
            },
            _isSeriesHasAllAxesTypeOf: function(P, Q) {
                var O = true;
                F(function(T) {
                    var R = P.get(T.axisIndex);
                    var S = this.dependentModels[T.axis][R];
                    if (!S || S.get("type") !== Q) {
                        O = false
                    }
                }, this);
                return O
            },
            _setDefaultThrottle: function(O) {
                if (O.hasOwnProperty("throttle")) {
                    this._autoThrottle = false
                }
                if (this._autoThrottle) {
                    var P = this.ecModel.option;
                    this.option.throttle = (P.animation && P.animationDurationUpdate > 0) ? 100 : 20
                }
            },
            getFirstTargetAxisModel: function() {
                var O;
                F(function(Q) {
                    if (O == null) {
                        var P = this.get(Q.axisIndex);
                        if (P.length) {
                            O = this.dependentModels[Q.axis][P[0]]
                        }
                    }
                }, this);
                return O
            },
            eachTargetAxis: function(O, P) {
                var Q = this.ecModel;
                F(function(R) {
                    A(this.get(R.axisIndex), function(S) {
                        O.call(P, R, S, this, Q)
                    }, this)
                }, this)
            },
            getAxisProxy: function(O, P) {
                return this._axisProxies[O + "_" + P]
            },
            getAxisModel: function(O, Q) {
                var P = this.getAxisProxy(O, Q);
                return P && P.getAxisModel()
            },
            setRawRange: function(O, P) {
                A(["start", "end", "startValue", "endValue"], function(Q) {
                    this.option[Q] = O[Q]
                }, this);
                !P && K(this, O)
            },
            getPercentRange: function() {
                var O = this.findRepresentativeAxisProxy();
                if (O) {
                    return O.getDataPercentWindow()
                }
            },
            getValueRange: function(Q, O) {
                if (Q == null && O == null) {
                    var P = this.findRepresentativeAxisProxy();
                    if (P) {
                        return P.getDataValueWindow()
                    }
                } else {
                    return this.getAxisProxy(Q, O).getDataValueWindow()
                }
            },
            findRepresentativeAxisProxy: function(P) {
                if (P) {
                    return P.__dzAxisProxy
                }
                var Q = this._axisProxies;
                for (var O in Q) {
                    if (Q.hasOwnProperty(O) && Q[O].hostedBy(this)) {
                        return Q[O]
                    }
                }
                for (var O in Q) {
                    if (Q.hasOwnProperty(O) && !Q[O].hostedBy(this)) {
                        return Q[O]
                    }
                }
            },
            getRangePropMode: function() {
                return this._rangePropMode.slice()
            }
        });

        function J(O) {
            var P = {};
            A(["start", "end", "startValue", "endValue", "throttle"], function(Q) {
                O.hasOwnProperty(Q) && (P[Q] = O[Q])
            });
            return P
        }

        function K(P, O) {
            A([["start", "startValue"], ["end", "endValue"]], function(S, R) {
                var Q = P._rangePropMode;
                if (O[S[0]] != null) {
                    Q[R] = "percent"
                } else {
                    if (O[S[1]] != null) {
                        Q[R] = "value"
                    }
                }
            })
        }

        M.exports = H
    }, function(G, H, E) {
        var D = E(6);
        var C = E(4);
        var F = {};
        var B = ["x", "y", "z", "radius", "angle", "single"];
        var A = ["cartesian2d", "polar", "singleAxis"];
        F.isCoordSupported = function(I) {
            return C.indexOf(A, I) >= 0
        };
        F.createNameEach = function(K, I) {
            K = K.slice();
            var J = C.map(K, D.capitalFirst);
            I = (I || []).slice();
            var L = C.map(I, D.capitalFirst);
            return function(M, N) {
                C.each(K, function(P, Q) {
                    var O = {name: P, capital: J[Q]};
                    for (var R = 0; R < I.length; R++) {
                        O[I[R]] = P + L[R]
                    }
                    M.call(N, O)
                })
            }
        };
        F.eachAxisDim = F.createNameEach(B, ["axisIndex", "axis", "index", "id"]);
        F.createLinkedNodesFinder = function(I, L, J) {
            return function(O) {
                var P = {nodes: [], records: {}};
                L(function(S) {
                    P.records[S.name] = {}
                });
                if (!O) {
                    return P
                }
                N(O, P);
                var R;
                do {
                    R = false;
                    I(Q)
                } while (R);

                function Q(S) {
                    if (!K(S, P) && M(S, P)) {
                        N(S, P);
                        R = true
                    }
                }

                return P
            };

            function K(P, O) {
                return C.indexOf(O.nodes, P) >= 0
            }

            function M(P, O) {
                var Q = false;
                L(function(R) {
                    C.each(J(P, R) || [], function(S) {
                        O.records[R.name][S] && (Q = true)
                    })
                });
                return Q
            }

            function N(P, O) {
                O.nodes.push(P);
                L(function(Q) {
                    C.each(J(P, Q) || [], function(R) {
                        O.records[Q.name][R] = true
                    })
                })
            }
        };
        G.exports = F
    }, function(K, M, D) {
        var C = D(4);
        var F = D(7);
        var J = D(366);
        var A = C.each;
        var B = F.asc;
        var G = function(O, Q, P, N) {
            this._dimName = O;
            this._axisIndex = Q;
            this._valueWindow;
            this._percentWindow;
            this._dataExtent;
            this._minMaxSpan;
            this.ecModel = N;
            this._dataZoomModel = P
        };
        G.prototype = {
            constructor: G, hostedBy: function(N) {
                return this._dataZoomModel === N
            }, getDataValueWindow: function() {
                return this._valueWindow.slice()
            }, getDataPercentWindow: function() {
                return this._percentWindow.slice()
            }, getTargetSeriesModels: function() {
                var O = [];
                var N = this.ecModel;
                N.eachSeries(function(P) {
                    if (J.isCoordSupported(P.get("coordinateSystem"))) {
                        var R = this._dimName;
                        var Q = N.queryComponents({mainType: R + "Axis", index: P.get(R + "AxisIndex"), id: P.get(R + "AxisId")})[0];
                        if (this._axisIndex === (Q && Q.componentIndex)) {
                            O.push(P)
                        }
                    }
                }, this);
                return O
            }, getAxisModel: function() {
                return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
            }, getOtherAxisModel: function() {
                var S = this._dimName;
                var P = this.ecModel;
                var Q = this.getAxisModel();
                var R = S === "x" || S === "y";
                var O;
                var N;
                if (R) {
                    N = "gridIndex";
                    O = S === "x" ? "y" : "x"
                } else {
                    N = "polarIndex";
                    O = S === "angle" ? "radius" : "angle"
                }
                var T;
                P.eachComponent(O + "Axis", function(U) {
                    if ((U.get(N) || 0) === (Q.get(N) || 0)) {
                        T = U
                    }
                });
                return T
            }, getMinMaxSpan: function() {
                return C.clone(this._minMaxSpan)
            }, calculateDataWindow: function(O) {
                var P = this._dataExtent;
                var Q = this.getAxisModel();
                var N = Q.axis.scale;
                var S = this._dataZoomModel.getRangePropMode();
                var R = [0, 100];
                var T = [O.start, O.end];
                var U = [];
                A(["startValue", "endValue"], function(V) {
                    U.push(O[V] != null ? N.parse(O[V]) : null)
                });
                A([0, 1], function(W) {
                    var V = U[W];
                    var X = T[W];
                    if (S[W] === "percent") {
                        if (X == null) {
                            X = R[W]
                        }
                        V = N.parse(F.linearMap(X, R, P, true))
                    } else {
                        X = F.linearMap(V, P, R, true)
                    }
                    U[W] = V;
                    T[W] = X
                });
                return {valueWindow: B(U), percentWindow: B(T)}
            }, reset: function(O) {
                if (O !== this._dataZoomModel) {
                    return
                }
                this._dataExtent = L(this, this._dimName, this.getTargetSeriesModels());
                var N = this.calculateDataWindow(O.option);
                this._valueWindow = N.valueWindow;
                this._percentWindow = N.percentWindow;
                H(this);
                E(this)
            }, restore: function(N) {
                if (N !== this._dataZoomModel) {
                    return
                }
                this._valueWindow = this._percentWindow = null;
                E(this, true)
            }, filterData: function(S) {
                if (S !== this._dataZoomModel) {
                    return
                }
                var O = this._dimName;
                var P = this.getTargetSeriesModels();
                var R = S.get("filterMode");
                var N = this._valueWindow;
                if (R === "none") {
                    return
                }
                var T = this.getOtherAxisModel();
                if (S.get("$fromToolbox") && T && T.get("type") === "category") {
                    R = "empty"
                }
                A(P, function(V) {
                    var W = V.getData();
                    var U = V.coordDimToDataDim(O);
                    if (R === "weakFilter") {
                        W && W.filterSelf(function(d) {
                            var X;
                            var a;
                            var e;
                            for (var c = 0; c < U.length; c++) {
                                var b = W.get(U[c], d);
                                var Z = !isNaN(b);
                                var f = b < N[0];
                                var Y = b > N[1];
                                if (Z && !f && !Y) {
                                    return true
                                }
                                Z && (e = true);
                                f && (X = true);
                                Y && (a = true)
                            }
                            return e && X && a
                        })
                    } else {
                        W && A(U, function(X) {
                            if (R === "empty") {
                                V.setData(W.map(X, function(Y) {
                                    return !Q(Y) ? NaN : Y
                                }))
                            } else {
                                W.filterSelf(X, Q)
                            }
                        })
                    }
                });

                function Q(U) {
                    return U >= N[0] && U <= N[1]
                }
            }
        };

        function L(O, P, N) {
            var Q = [Infinity, -Infinity];
            A(N, function(R) {
                var S = R.getData();
                if (S) {
                    A(R.coordDimToDataDim(P), function(T) {
                        var U = S.getDataExtent(T);
                        U[0] < Q[0] && (Q[0] = U[0]);
                        U[1] > Q[1] && (Q[1] = U[1])
                    })
                }
            });
            if (Q[1] < Q[0]) {
                Q = [NaN, NaN]
            }
            I(O, Q);
            return Q
        }

        function I(R, S) {
            var P = R.getAxisModel();
            var N = P.getMin(true);
            var Q = P.get("type") === "category";
            var O = Q && (P.get("data") || []).length;
            if (N != null && N !== "dataMin") {
                S[0] = N
            } else {
                if (Q) {
                    S[0] = O > 0 ? 0 : NaN
                }
            }
            var T = P.getMax(true);
            if (T != null && T !== "dataMax") {
                S[1] = T
            } else {
                if (Q) {
                    S[1] = O > 0 ? O - 1 : NaN
                }
            }
            if (!P.get("scale", true)) {
                S[0] > 0 && (S[0] = 0);
                S[1] < 0 && (S[1] = 0)
            }
            return S
        }

        function E(R, T) {
            var P = R.getAxisModel();
            var Q = R._percentWindow;
            var N = R._valueWindow;
            if (!Q) {
                return
            }
            var O = F.getPixelPrecision(N, [0, 500]);
            var S = T || (Q[0] === 0 && Q[1] === 100);
            P.setRange(S ? null : +N[0].toFixed(O), S ? null : +N[1].toFixed(O))
        }

        function H(O) {
            var N = O._minMaxSpan = {};
            var P = O._dataZoomModel;
            A(["min", "max"], function(Q) {
                N[Q + "Span"] = P.get(Q + "Span");
                var R = P.get(Q + "ValueSpan");
                if (R != null) {
                    N[Q + "ValueSpan"] = R;
                    R = O.getAxisModel().axis.scale.parse(R);
                    if (R != null) {
                        N[Q + "Span"] = F.linearMap(R, O._dataExtent, [0, 100], true)
                    }
                }
            })
        }

        K.exports = G
    }, function(C, D, B) {
        var A = B(79);
        C.exports = A.extend({
            type: "dataZoom", render: function(G, E, H, F) {
                this.dataZoomModel = G;
                this.ecModel = E;
                this.api = H
            }, getTargetCoordInfo: function() {
                var H = this.dataZoomModel;
                var F = this.ecModel;
                var G = {};
                H.eachTargetAxis(function(K, L) {
                    var J = F.getComponent(K.axis, L);
                    if (J) {
                        var I = J.getCoordSysModel();
                        I && E(I, J, G[I.mainType] || (G[I.mainType] = []), I.componentIndex)
                    }
                }, this);

                function E(K, L, I, N) {
                    var M;
                    for (var J = 0; J < I.length; J++) {
                        if (I[J].model === K) {
                            M = I[J];
                            break
                        }
                    }
                    if (!M) {
                        I.push(M = {model: K, axisModels: [], coordIndex: N})
                    }
                    M.axisModels.push(L)
                }

                return G
            }
        })
    }, function(D, E, B) {
        var C = B(365);
        var A = C.extend({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: true,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackground: {lineStyle: {color: "#2f4554", width: 0.5, opacity: 0.3}, areaStyle: {color: "rgba(47,69,84,0.3)", opacity: 0.3}},
                borderColor: "#ddd",
                fillerColor: "rgba(167,183,204,0.4)",
                handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                handleSize: "100%",
                handleStyle: {color: "#a7b7cc"},
                labelPrecision: null,
                labelFormatter: null,
                showDetail: true,
                showDataShadow: "auto",
                realtime: true,
                zoomLock: false,
                textStyle: {color: "#333"}
            }
        });
        D.exports = A
    }, function(T, H, V) {
        var G = V(4);
        var N = V(18);
        var E = V(81);
        var X = V(368);
        var I = N.Rect;
        var Q = V(7);
        var P = Q.linearMap;
        var K = V(71);
        var L = V(239);
        var U = V(88);
        var D = Q.asc;
        var C = G.bind;
        var J = G.each;
        var R = 7;
        var O = 1;
        var A = 30;
        var B = "horizontal";
        var S = "vertical";
        var M = 5;
        var W = ["line", "bar", "candlestick", "scatter"];
        var F = X.extend({
            type: "dataZoom.slider", init: function(Z, a) {
                this._displayables = {};
                this._orient;
                this._range;
                this._handleEnds;
                this._size;
                this._handleWidth;
                this._handleHeight;
                this._location;
                this._dragging;
                this._dataShadowInfo;
                this.api = a
            }, render: function(b, Z, c, a) {
                F.superApply(this, "render", arguments);
                E.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate");
                this._orient = b.get("orient");
                if (this.dataZoomModel.get("show") === false) {
                    this.group.removeAll();
                    return
                }
                if (!a || a.type !== "dataZoom" || a.from !== this.uid) {
                    this._buildView()
                }
                this._updateView()
            }, remove: function() {
                F.superApply(this, "remove", arguments);
                E.clear(this, "_dispatchZoomAction")
            }, dispose: function() {
                F.superApply(this, "dispose", arguments);
                E.clear(this, "_dispatchZoomAction")
            }, _buildView: function() {
                var a = this.group;
                a.removeAll();
                this._resetLocation();
                this._resetInterval();
                var Z = this._displayables.barGroup = new N.Group();
                this._renderBackground();
                this._renderHandle();
                this._renderDataShadow();
                a.add(Z);
                this._positionGroup()
            }, _resetLocation: function() {
                var d = this.dataZoomModel;
                var e = this.api;
                var Z = this._findCoordRect();
                var f = {width: e.getWidth(), height: e.getHeight()};
                var b = this._orient === B ? {right: f.width - Z.x - Z.width, top: (f.height - A - R), width: Z.width, height: A} : {
                    right: R,
                    top: Z.y,
                    width: A,
                    height: Z.height
                };
                var a = K.getLayoutParams(d.option);
                G.each(["right", "top", "width", "height"], function(g) {
                    if (a[g] === "ph") {
                        a[g] = b[g]
                    }
                });
                var c = K.getLayoutRect(a, f, d.padding);
                this._location = {x: c.x, y: c.y};
                this._size = [c.width, c.height];
                this._orient === S && this._size.reverse()
            }, _positionGroup: function() {
                var g = this.group;
                var e = this._location;
                var d = this._orient;
                var c = this.dataZoomModel.getFirstTargetAxisModel();
                var f = c && c.get("inverse");
                var Z = this._displayables.barGroup;
                var a = (this._dataShadowInfo || {}).otherAxisInverse;
                Z.attr((d === B && !f) ? {scale: a ? [1, 1] : [1, -1]} : (d === B && f) ? {scale: a ? [-1, 1] : [-1, -1]} : (d === S && !f) ? {
                    scale: a ? [1, -1] : [1, 1],
                    rotation: Math.PI / 2
                } : {scale: a ? [-1, -1] : [-1, 1], rotation: Math.PI / 2});
                var b = g.getBoundingRect([Z]);
                g.attr("position", [e.x - b.x, e.y - b.y])
            }, _getViewExtent: function() {
                return [0, this._size[0]]
            }, _renderBackground: function() {
                var a = this.dataZoomModel;
                var Z = this._size;
                var b = this._displayables.barGroup;
                b.add(new I({silent: true, shape: {x: 0, y: 0, width: Z[0], height: Z[1]}, style: {fill: a.get("backgroundColor")}, z2: -40}));
                b.add(new I({
                    shape: {x: 0, y: 0, width: Z[0], height: Z[1]},
                    style: {fill: "transparent"},
                    z2: 0,
                    onclick: G.bind(this._onClickPanelClick, this)
                }))
            }, _renderDataShadow: function() {
                var j = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (!j) {
                    return
                }
                var f = this._size;
                var e = j.series;
                var a = e.getRawData();
                var c = e.getShadowDim ? e.getShadowDim() : j.otherDim;
                if (c == null) {
                    return
                }
                var o = a.getDataExtent(c);
                var m = (o[1] - o[0]) * 0.3;
                o = [o[0] - m, o[1] + m];
                var Z = [0, f[1]];
                var d = [0, f[0]];
                var l = [[f[0], 0], [0, 0]];
                var h = [];
                var i = d[1] / (a.count() - 1);
                var k = 0;
                var n = Math.round(a.count() / f[0]);
                var b;
                a.each([c], function(r, q) {
                    if (n > 0 && (q % n)) {
                        k += i;
                        return
                    }
                    var p = r == null || isNaN(r) || r === "";
                    var s = p ? 0 : P(r, o, Z, true);
                    if (p && !b && q) {
                        l.push([l[l.length - 1][0], 0]);
                        h.push([h[h.length - 1][0], 0])
                    } else {
                        if (!p && b) {
                            l.push([k, 0]);
                            h.push([k, 0])
                        }
                    }
                    l.push([k, s]);
                    h.push([k, s]);
                    k += i;
                    b = p
                });
                var g = this.dataZoomModel;
                this._displayables.barGroup.add(new N.Polygon({
                    shape: {points: l},
                    style: G.defaults({fill: g.get("dataBackgroundColor")}, g.getModel("dataBackground.areaStyle").getAreaStyle()),
                    silent: true,
                    z2: -20
                }));
                this._displayables.barGroup.add(new N.Polyline({
                    shape: {points: h},
                    style: g.getModel("dataBackground.lineStyle").getLineStyle(),
                    silent: true,
                    z2: -19
                }))
            }, _prepareDataShadowInfo: function() {
                var b = this.dataZoomModel;
                var c = b.get("showDataShadow");
                if (c === false) {
                    return
                }
                var Z;
                var a = this.ecModel;
                b.eachTargetAxis(function(e, f) {
                    var d = b.getAxisProxy(e.name, f).getTargetSeriesModels();
                    G.each(d, function(g) {
                        if (Z) {
                            return
                        }
                        if (c !== true && G.indexOf(W, g.get("type")) < 0) {
                            return
                        }
                        var j = a.getComponent(e.axis, f).axis;
                        var k = Y(e.name);
                        var h;
                        var i = g.coordinateSystem;
                        if (k != null && i.getOtherAxis) {
                            h = i.getOtherAxis(j).inverse
                        }
                        Z = {thisAxis: j, series: g, thisDim: e.name, otherDim: k, otherAxisInverse: h}
                    }, this)
                }, this);
                return Z
            }, _renderHandle: function() {
                var a = this._displayables;
                var b = a.handles = [];
                var d = a.handleLabels = [];
                var e = this._displayables.barGroup;
                var Z = this._size;
                var c = this.dataZoomModel;
                e.add(a.filler = new I({
                    draggable: true,
                    cursor: "move",
                    drift: C(this._onDragMove, this, "all"),
                    onmousemove: function(g) {
                        U.stop(g.event)
                    },
                    ondragstart: C(this._showDataInfo, this, true),
                    ondragend: C(this._onDragEnd, this),
                    onmouseover: C(this._showDataInfo, this, true),
                    onmouseout: C(this._showDataInfo, this, false),
                    style: {fill: c.get("fillerColor"), textPosition: "inside"}
                }));
                e.add(new I(N.subPixelOptimizeRect({
                    silent: true,
                    shape: {x: 0, y: 0, width: Z[0], height: Z[1]},
                    style: {stroke: c.get("dataBackgroundColor") || c.get("borderColor"), lineWidth: O, fill: "rgba(0,0,0,0)"}
                })));
                var f = c.get("handleIcon");
                J([0, 1], function(j) {
                    var m = {
                        style: {strokeNoScale: true},
                        rectHover: true,
                        cursor: this._orient === "vertical" ? "ns-resize" : "ew-resize",
                        draggable: true,
                        drift: C(this._onDragMove, this, j),
                        onmousemove: function(n) {
                            U.stop(n.event)
                        },
                        ondragend: C(this._onDragEnd, this),
                        onmouseover: C(this._showDataInfo, this, true),
                        onmouseout: C(this._showDataInfo, this, false)
                    };
                    var l = {x: -1, y: 0, width: 2, height: 2};
                    var h = f.indexOf("image://") === 0 ? (l.image = f.slice(8), m.style = l, new N.Image(m)) : N.makePath(f.replace("path://", ""), m, l, "center");
                    var i = h.getBoundingRect();
                    this._handleHeight = Q.parsePercent(c.get("handleSize"), this._size[1]);
                    this._handleWidth = i.width / i.height * this._handleHeight;
                    h.setStyle(c.getModel("handleStyle").getItemStyle());
                    var k = c.get("handleColor");
                    if (k != null) {
                        h.style.fill = k
                    }
                    e.add(b[j] = h);
                    var g = c.textStyleModel;
                    this.group.add(d[j] = new N.Text({
                        silent: true,
                        invisible: true,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            fill: g.getTextColor(),
                            textFont: g.getFont()
                        },
                        z2: 10
                    }))
                }, this)
            }, _resetInterval: function() {
                var Z = this._range = this.dataZoomModel.getPercentRange();
                var a = this._getViewExtent();
                this._handleEnds = [P(Z[0], [0, 100], a, true), P(Z[1], [0, 100], a, true)]
            }, _updateInterval: function(c, a) {
                var f = this.dataZoomModel;
                var Z = this._handleEnds;
                var d = this._getViewExtent();
                var b = f.findRepresentativeAxisProxy().getMinMaxSpan();
                var e = [0, 100];
                L(a, Z, d, f.get("zoomLock") ? "all" : c, b.minSpan != null ? P(b.minSpan, e, d, true) : null, b.maxSpan != null ? P(b.maxSpan, e, d, true) : null);
                this._range = D([P(Z[0], d, e, true), P(Z[1], d, e, true)])
            }, _updateView: function(a) {
                var b = this._displayables;
                var Z = this._handleEnds;
                var d = D(Z.slice());
                var c = this._size;
                J([0, 1], function(g) {
                    var e = b.handles[g];
                    var f = this._handleHeight;
                    e.attr({scale: [f / 2, f / 2], position: [Z[g], c[1] / 2 - f / 2]})
                }, this);
                b.filler.setShape({x: d[0], y: 0, width: d[1] - d[0], height: c[1]});
                this._updateDataInfo(a)
            }, _updateDataInfo: function(Z) {
                var g = this.dataZoomModel;
                var a = this._displayables;
                var h = a.handleLabels;
                var i = this._orient;
                var f = ["", ""];
                if (g.get("showDetail")) {
                    var c = g.findRepresentativeAxisProxy();
                    if (c) {
                        var b = c.getAxisModel().axis;
                        var k = this._range;
                        var j = Z ? c.calculateDataWindow({start: k[0], end: k[1]}).valueWindow : c.getDataValueWindow();
                        f = [this._formatLabel(j[0], b), this._formatLabel(j[1], b)]
                    }
                }
                var d = D(this._handleEnds.slice());
                e.call(this, 0);
                e.call(this, 1);

                function e(n) {
                    var p = N.getTransform(a.handles[n].parent, this.group);
                    var m = N.transformDirection(n === 0 ? "right" : "left", p);
                    var l = this._handleWidth / 2 + M;
                    var o = N.applyTransform([d[n] + (n === 0 ? -l : l), this._size[1] / 2], p);
                    h[n].setStyle({x: o[0], y: o[1], textVerticalAlign: i === B ? "middle" : m, textAlign: i === B ? m : "center", text: f[n]})
                }
            }, _formatLabel: function(c, e) {
                var d = this.dataZoomModel;
                var a = d.get("labelFormatter");
                var b = d.get("labelPrecision");
                if (b == null || b === "auto") {
                    b = e.getPixelPrecision()
                }
                var Z = (c == null || isNaN(c)) ? "" : (e.type === "category" || e.type === "time") ? e.scale.getLabel(Math.round(c)) : c.toFixed(Math.min(b, 20));
                return G.isFunction(a) ? a(c, Z) : G.isString(a) ? a.replace("{value}", Z) : Z
            }, _showDataInfo: function(Z) {
                Z = this._dragging || Z;
                var a = this._displayables.handleLabels;
                a[0].attr("invisible", !Z);
                a[1].attr("invisible", !Z)
            }, _onDragMove: function(a, Z, b) {
                this._dragging = true;
                var d = this._displayables.barGroup.getLocalTransform();
                var c = N.applyTransform([Z, b], d, true);
                this._updateInterval(a, c[0]);
                var e = this.dataZoomModel.get("realtime");
                this._updateView(!e);
                if (e) {
                    e && this._dispatchZoomAction()
                }
            }, _onDragEnd: function() {
                this._dragging = false;
                this._showDataInfo(false);
                this._dispatchZoomAction()
            }, _onClickPanelClick: function(a) {
                var Z = this._size;
                var d = this._displayables.barGroup.transformCoordToLocal(a.offsetX, a.offsetY);
                if (d[0] < 0 || d[0] > Z[0] || d[1] < 0 || d[1] > Z[1]) {
                    return
                }
                var c = this._handleEnds;
                var b = (c[0] + c[1]) / 2;
                this._updateInterval("all", d[0] - b);
                this._updateView();
                this._dispatchZoomAction()
            }, _dispatchZoomAction: function() {
                var Z = this._range;
                this.api.dispatchAction({type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, start: Z[0], end: Z[1]})
            }, _findCoordRect: function() {
                var a;
                J(this.getTargetCoordInfo(), function(d) {
                    if (!a && d.length) {
                        var c = d[0].model.coordinateSystem;
                        a = c.getRect && c.getRect()
                    }
                });
                if (!a) {
                    var b = this.api.getWidth();
                    var Z = this.api.getHeight();
                    a = {x: b * 0.2, y: Z * 0.2, width: b * 0.6, height: Z * 0.6}
                }
                return a
            }
        });

        function Y(a) {
            var Z = {x: "y", y: "x", radius: "angle", angle: "radius"};
            return Z[a]
        }

        T.exports = F
    }, function(B, C, A) {
        B.exports = A(365).extend({
            type: "dataZoom.inside",
            defaultOption: {disabled: false, zoomLock: false, zoomOnMouseWheel: true, moveOnMouseMove: true, preventDefaultMouseMove: true}
        })
    }, function(I, J, E) {
        var H = E(368);
        var D = E(4);
        var B = E(239);
        var F = E(373);
        var A = D.bind;
        var G = H.extend({
            type: "dataZoom.inside", init: function(K, L) {
                this._range
            }, render: function(M, K, N, L) {
                G.superApply(this, "render", arguments);
                if (F.shouldRecordRange(L, M.id)) {
                    this._range = M.getPercentRange()
                }
                D.each(this.getTargetCoordInfo(), function(Q, O) {
                    var P = D.map(Q, function(R) {
                        return F.generateCoordId(R.model)
                    });
                    D.each(Q, function(T) {
                        var R = T.model;
                        var S = M.option;
                        F.register(N, {
                            coordId: F.generateCoordId(R),
                            allCoordIds: P,
                            containsPoint: function(U, V, W) {
                                return R.coordinateSystem.containPoint([V, W])
                            },
                            dataZoomId: M.id,
                            throttleRate: M.get("throttle", true),
                            panGetRange: A(this._onPan, this, T, O),
                            zoomGetRange: A(this._onZoom, this, T, O),
                            zoomLock: S.zoomLock,
                            disabled: S.disabled,
                            roamControllerOpt: {
                                zoomOnMouseWheel: S.zoomOnMouseWheel,
                                moveOnMouseMove: S.moveOnMouseMove,
                                preventDefaultMouseMove: S.preventDefaultMouseMove
                            }
                        })
                    }, this)
                }, this)
            }, dispose: function() {
                F.unregister(this.api, this.dataZoomModel.id);
                G.superApply(this, "dispose", arguments);
                this._range = null
            }, _onPan: function(P, M, O, S, Q, K, V, W, U) {
                var T = this._range.slice();
                var N = P.axisModels[0];
                if (!N) {
                    return
                }
                var R = C[M]([K, V], [W, U], N, O, P);
                var L = R.signal * (T[1] - T[0]) * R.pixel / R.pixelLength;
                B(L, T, [0, 100], "all");
                return (this._range = T)
            }, _onZoom: function(Q, K, P, M, S, R) {
                var T = this._range.slice();
                var N = Q.axisModels[0];
                if (!N) {
                    return
                }
                var O = C[K](null, [S, R], N, P, Q);
                var L = (O.signal > 0 ? (O.pixelStart + O.pixelLength - O.pixel) : (O.pixel - O.pixelStart)) / O.pixelLength * (T[1] - T[0]) + T[0];
                M = Math.max(1 / M, 0);
                T[0] = (T[0] - L) * M + L;
                T[1] = (T[1] - L) * M + L;
                var U = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                B(0, T, [0, 100], 0, U.minSpan, U.maxSpan);
                return (this._range = T)
            }
        });
        var C = {
            grid: function(Q, K, N, O, P) {
                var L = N.axis;
                var R = {};
                var M = P.model.coordinateSystem.getRect();
                Q = Q || [0, 0];
                if (L.dim === "x") {
                    R.pixel = K[0] - Q[0];
                    R.pixelLength = M.width;
                    R.pixelStart = M.x;
                    R.signal = L.inverse ? 1 : -1
                } else {
                    R.pixel = K[1] - Q[1];
                    R.pixelLength = M.height;
                    R.pixelStart = M.y;
                    R.signal = L.inverse ? -1 : 1
                }
                return R
            }, polar: function(S, K, O, Q, R) {
                var M = O.axis;
                var T = {};
                var L = R.model.coordinateSystem;
                var P = L.getRadiusAxis().getExtent();
                var N = L.getAngleAxis().getExtent();
                S = S ? L.pointToCoord(S) : [0, 0];
                K = L.pointToCoord(K);
                if (O.mainType === "radiusAxis") {
                    T.pixel = K[0] - S[0];
                    T.pixelLength = P[1] - P[0];
                    T.pixelStart = P[0];
                    T.signal = M.inverse ? 1 : -1
                } else {
                    T.pixel = K[1] - S[1];
                    T.pixelLength = N[1] - N[0];
                    T.pixelStart = N[0];
                    T.signal = M.inverse ? -1 : 1
                }
                return T
            }, singleAxis: function(Q, K, N, O, P) {
                var L = N.axis;
                var M = P.model.coordinateSystem.getRect();
                var R = {};
                Q = Q || [0, 0];
                if (L.orient === "horizontal") {
                    R.pixel = K[0] - Q[0];
                    R.pixelLength = M.width;
                    R.pixelStart = M.x;
                    R.signal = L.inverse ? 1 : -1
                } else {
                    R.pixel = K[1] - Q[1];
                    R.pixelLength = M.height;
                    R.pixelStart = M.y;
                    R.signal = L.inverse ? -1 : 1
                }
                return R
            }
        };
        I.exports = G
    }, function(L, F, M) {
        var P = M(4);
        var N = M(183);
        var D = M(81);
        var C = P.curry;
        var E = "\0_ec_dataZoom_roams";
        var I = {
            register: function(X, T) {
                var S = B(X);
                var R = T.dataZoomId;
                var U = T.coordId;
                P.each(S, function(Y, Z) {
                    var a = Y.dataZoomInfos;
                    if (a[R] && P.indexOf(T.allCoordIds, U) < 0) {
                        delete a[R];
                        Y.count--
                    }
                });
                K(S);
                var W = S[U];
                if (!W) {
                    W = S[U] = {coordId: U, dataZoomInfos: {}, count: 0};
                    W.controller = G(X, W);
                    W.dispatchAction = P.curry(A, X)
                }
                !(W.dataZoomInfos[R]) && W.count++;
                W.dataZoomInfos[R] = T;
                var V = O(W.dataZoomInfos);
                W.controller.enable(V.controlType, V.opt);
                W.controller.setPointerChecker(T.containsPoint);
                D.createOrUpdate(W, "dispatchAction", T.throttleRate, "fixRate")
            }, unregister: function(T, S) {
                var R = B(T);
                P.each(R, function(U) {
                    U.controller.dispose();
                    var V = U.dataZoomInfos;
                    if (V[S]) {
                        delete V[S];
                        U.count--
                    }
                });
                K(R)
            }, shouldRecordRange: function(T, S) {
                if (T && T.type === "dataZoom" && T.batch) {
                    for (var R = 0, U = T.batch.length; R < U; R++) {
                        if (T.batch[R].dataZoomId === S) {
                            return false
                        }
                    }
                }
                return true
            }, generateCoordId: function(R) {
                return R.type + "\0_" + R.id
            }
        };

        function B(S) {
            var R = S.getZr();
            return R[E] || (R[E] = {})
        }

        function G(S, R) {
            var T = new N(S.getZr());
            T.on("pan", C(H, R));
            T.on("zoom", C(J, R));
            return T
        }

        function K(R) {
            P.each(R, function(S, T) {
                if (!S.count) {
                    S.controller.dispose();
                    delete R[T]
                }
            })
        }

        function H(U, T, V, R, X, S, W) {
            Q(U, function(Y) {
                return Y.panGetRange(U.controller, T, V, R, X, S, W)
            })
        }

        function J(R, T, S, U) {
            Q(R, function(V) {
                return V.zoomGetRange(R.controller, T, S, U)
            })
        }

        function Q(R, T) {
            var S = [];
            P.each(R.dataZoomInfos, function(U) {
                var V = T(U);
                !U.disabled && V && S.push({dataZoomId: U.dataZoomId, start: V[0], end: V[1]})
            });
            R.dispatchAction(S)
        }

        function A(S, R) {
            S.dispatchAction({type: "dataZoom", batch: R})
        }

        function O(U) {
            var T;
            var S = {};
            var R = {"true": 2, "move": 1, "false": 0, "undefined": -1};
            P.each(U, function(V) {
                var W = V.disabled ? false : V.zoomLock ? "move" : true;
                R[W] > R[T] && (T = W);
                P.extend(S, V.roamControllerOpt)
            });
            return {controlType: T, opt: S}
        }

        L.exports = I
    }, function(C, E, B) {
        var D = B(1);
        D.registerProcessor(function(G, H) {
            G.eachComponent("dataZoom", function(I) {
                I.eachTargetAxis(F);
                I.eachTargetAxis(A)
            });
            G.eachComponent("dataZoom", function(L) {
                var K = L.findRepresentativeAxisProxy();
                var I = K.getDataPercentWindow();
                var J = K.getDataValueWindow();
                L.setRawRange({start: I[0], end: I[1], startValue: J[0], endValue: J[1]}, true)
            })
        });

        function F(G, I, H) {
            H.getAxisProxy(G.name, I).reset(H)
        }

        function A(G, I, H) {
            H.getAxisProxy(G.name, I).filterData(H)
        }
    }, function(C, F, B) {
        var A = B(4);
        var D = B(366);
        var E = B(1);
        E.registerAction("dataZoom", function(J, I) {
            var H = D.createLinkedNodesFinder(A.bind(I.eachComponent, I, "dataZoom"), D.eachAxisDim, function(L, K) {
                return L.get(K.axisIndex)
            });
            var G = [];
            I.eachComponent({mainType: "dataZoom", query: J}, function(L, K) {
                G.push.apply(G, H(L).nodes)
            });
            A.each(G, function(L, K) {
                L.setRawRange({start: J.start, end: J.end, startValue: J.startValue, endValue: J.endValue})
            })
        })
    }, function(B, C, A) {
        A(377);
        A(388)
    }, function(B, C, A) {
        A(1).registerPreprocessor(A(378));
        A(379);
        A(380);
        A(381);
        A(384);
        A(387)
    }, function(D, E, C) {
        var B = C(4);
        var A = B.each;
        D.exports = function(G) {
            var H = G && G.visualMap;
            if (!B.isArray(H)) {
                H = H ? [H] : []
            }
            A(H, function(I) {
                if (!I) {
                    return
                }
                if (F(I, "splitList") && !F(I, "pieces")) {
                    I.pieces = I.splitList;
                    delete I.splitList
                }
                var J = I.pieces;
                if (J && B.isArray(J)) {
                    A(J, function(K) {
                        if (B.isObject(K)) {
                            if (F(K, "start") && !F(K, "min")) {
                                K.min = K.start
                            }
                            if (F(K, "end") && !F(K, "max")) {
                                K.max = K.end
                            }
                        }
                    })
                }
            })
        };

        function F(G, H) {
            return G && G.hasOwnProperty && G.hasOwnProperty(H)
        }
    }, function(B, C, A) {
        A(69).registerSubTypeDefaulter("visualMap", function(D) {
            return (!D.categories && (!(D.pieces ? D.pieces.length > 0 : D.splitNumber > 0) || D.calculable)) ? "continuous" : "piecewise"
        })
    }, function(I, J, D) {
        var C = D(1);
        var F = D(350);
        var B = D(203);
        var G = D(4);
        C.registerVisual(C.PRIORITY.VISUAL.COMPONENT, function(K) {
            K.eachComponent("visualMap", function(L) {
                H(L, K)
            });
            A(K)
        });

        function H(L, K) {
            L.eachTargetSeries(function(M) {
                var N = M.getData();
                F.applyVisual(L.stateList, L.targetVisuals, N, L.getValueState, L, L.getDataDimension(N))
            })
        }

        function A(K) {
            K.eachSeries(function(M) {
                var N = M.getData();
                var L = [];
                K.eachComponent("visualMap", function(P) {
                    if (P.isTargetSeries(M)) {
                        var O = P.getVisualMeta(G.bind(E, null, M, P)) || {stops: [], outerColors: []};
                        O.dimension = P.getDataDimension(N);
                        L.push(O)
                    }
                });
                M.getData().setVisual("visualMeta", L)
            })
        }

        function E(W, U, P, O) {
            var T = U.targetVisuals[O];
            var S = B.prepareVisualTypes(T);
            var L = {color: W.getData().getVisual("color")};
            for (var Q = 0, K = S.length; Q < K; Q++) {
                var V = S[Q];
                var R = T[V === "opacity" ? "__alphaForOpacity" : V];
                R && R.applyVisual(P, M, N)
            }
            return L.color;

            function M(X) {
                return L[X]
            }

            function N(X, Y) {
                L[X] = Y
            }
        }
    }, function(H, I, C) {
        var G = C(382);
        var B = C(4);
        var D = C(7);
        var A = [20, 140];
        var F = G.extend({
            type: "visualMap.continuous",
            defaultOption: {
                align: "auto",
                calculable: false,
                range: null,
                realtime: true,
                itemHeight: null,
                itemWidth: null,
                hoverLink: true,
                hoverLinkDataSize: null,
                hoverLinkOnHandle: true
            },
            optionUpdated: function(J, K) {
                F.superApply(this, "optionUpdated", arguments);
                this.resetTargetSeries();
                this.resetExtent();
                this.resetVisual(function(L) {
                    L.mappingMethod = "linear";
                    L.dataExtent = this.getExtent()
                });
                this._resetRange()
            },
            resetItemSize: function() {
                F.superApply(this, "resetItemSize", arguments);
                var J = this.itemSize;
                this._orient === "horizontal" && J.reverse();
                (J[0] == null || isNaN(J[0])) && (J[0] = A[0]);
                (J[1] == null || isNaN(J[1])) && (J[1] = A[1])
            },
            _resetRange: function() {
                var K = this.getExtent();
                var J = this.option.range;
                if (!J || J.auto) {
                    K.auto = 1;
                    this.option.range = K
                } else {
                    if (B.isArray(J)) {
                        if (J[0] > J[1]) {
                            J.reverse()
                        }
                        J[0] = Math.max(J[0], K[0]);
                        J[1] = Math.min(J[1], K[1])
                    }
                }
            },
            completeVisualOption: function() {
                G.prototype.completeVisualOption.apply(this, arguments);
                B.each(this.stateList, function(K) {
                    var J = this.option.controller[K].symbolSize;
                    if (J && J[0] !== J[1]) {
                        J[0] = 0
                    }
                }, this)
            },
            setSelected: function(J) {
                this.option.range = J.slice();
                this._resetRange()
            },
            getSelected: function() {
                var K = this.getExtent();
                var J = D.asc((this.get("range") || []).slice());
                J[0] > K[1] && (J[0] = K[1]);
                J[1] > K[1] && (J[1] = K[1]);
                J[0] < K[0] && (J[0] = K[0]);
                J[1] < K[0] && (J[1] = K[0]);
                return J
            },
            getValueState: function(K) {
                var L = this.option.range;
                var J = this.getExtent();
                return ((L[0] <= J[0] || L[0] <= K) && (L[1] >= J[1] || K <= L[1])) ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function(K) {
                var J = [];
                this.eachTargetSeries(function(L) {
                    var N = [];
                    var M = L.getData();
                    M.each(this.getDataDimension(M), function(P, O) {
                        K[0] <= P && P <= K[1] && N.push(O)
                    }, true, this);
                    J.push({seriesId: L.id, dataIndex: N})
                }, this);
                return J
            },
            getVisualMeta: function(N) {
                var O = E(this, "outOfRange", this.getExtent());
                var K = E(this, "inRange", this.option.range.slice());
                var R = [];

                function Q(V, U) {
                    R.push({value: V, color: N(V, U)})
                }

                var L = 0;
                var M = 0;
                var J = K.length;
                var T = O.length;
                for (; M < T && (!K.length || O[M] <= K[0]); M++) {
                    if (O[M] < K[L]) {
                        Q(O[M], "outOfRange")
                    }
                }
                for (var P = 1; L < J; L++, P = 0) {
                    P && R.length && Q(K[L], "outOfRange");
                    Q(K[L], "inRange")
                }
                for (var P = 1; M < T; M++) {
                    if (!K.length || K[K.length - 1] < O[M]) {
                        if (P) {
                            R.length && Q(R[R.length - 1].value, "outOfRange");
                            P = 0
                        }
                        Q(O[M], "outOfRange")
                    }
                }
                var S = R.length;
                return {stops: R, outerColors: [S ? R[0].color : "transparent", S ? R[S - 1].color : "transparent"]}
            }
        });

        function E(Q, J, M) {
            if (M[0] === M[1]) {
                return M.slice()
            }
            var L = 200;
            var N = (M[1] - M[0]) / L;
            var O = M[0];
            var K = [];
            for (var P = 0; P <= L && O < M[1]; P++) {
                K.push(O);
                O += N
            }
            K.push(M[1]);
            return K
        }

        H.exports = F
    }, function(O, G, Q) {
        var E = Q(1);
        var F = Q(4);
        var A = Q(2);
        var I = Q(383);
        var P = Q(203);
        var T = Q(350);
        var R = P.mapVisual;
        var C = Q(5);
        var S = P.eachVisual;
        var M = Q(7);
        var K = F.isArray;
        var H = F.each;
        var B = M.asc;
        var L = M.linearMap;
        var J = F.noop;
        var N = ["#f6efa6", "#d88273", "#bf444c"];
        var D = E.extendComponentModel({
            type: "visualMap",
            dependencies: ["series"],
            stateList: ["inRange", "outOfRange"],
            replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
            dataBound: [-Infinity, Infinity],
            layoutMode: {type: "box", ignoreSize: true},
            defaultOption: {
                show: true,
                zlevel: 0,
                z: 4,
                seriesIndex: null,
                min: 0,
                max: 200,
                dimension: null,
                inRange: null,
                outOfRange: null,
                left: 0,
                right: null,
                top: null,
                bottom: 0,
                itemWidth: null,
                itemHeight: null,
                inverse: false,
                orient: "vertical",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                contentColor: "#5793f3",
                inactiveColor: "#aaa",
                borderWidth: 0,
                padding: 5,
                textGap: 10,
                precision: 0,
                color: null,
                formatter: null,
                text: null,
                textStyle: {color: "#333"}
            },
            init: function(U, W, V) {
                this._dataExtent;
                this.targetVisuals = {};
                this.controllerVisuals = {};
                this.textStyleModel;
                this.itemSize;
                this.mergeDefaultAndTheme(U, V)
            },
            optionUpdated: function(U, V) {
                var W = this.option;
                if (!A.canvasSupported) {
                    W.realtime = false
                }
                !V && T.replaceVisualOption(W, U, this.replacableOptionKeys);
                this.textStyleModel = this.getModel("textStyle");
                this.resetItemSize();
                this.completeVisualOption()
            },
            resetVisual: function(U) {
                var V = this.stateList;
                U = F.bind(U, this);
                this.controllerVisuals = T.createVisualMappings(this.option.controller, V, U);
                this.targetVisuals = T.createVisualMappings(this.option.target, V, U)
            },
            resetTargetSeries: function() {
                var V = this.option;
                var U = V.seriesIndex == null;
                V.seriesIndex = U ? [] : C.normalizeToArray(V.seriesIndex);
                U && this.ecModel.eachSeries(function(W, X) {
                    V.seriesIndex.push(X)
                })
            },
            eachTargetSeries: function(U, V) {
                F.each(this.option.seriesIndex, function(W) {
                    U.call(V, this.ecModel.getSeriesByIndex(W))
                }, this)
            },
            isTargetSeries: function(V) {
                var U = false;
                this.eachTargetSeries(function(W) {
                    W === V && (U = true)
                });
                return U
            },
            formatValueText: function(X, Z, U) {
                var c = this.option;
                var V = c.precision;
                var W = this.dataBound;
                var b = c.formatter;
                var d;
                var a;
                U = U || ["<", ">"];
                if (F.isArray(X)) {
                    X = X.slice();
                    d = true
                }
                a = Z ? X : (d ? [Y(X[0]), Y(X[1])] : Y(X));
                if (F.isString(b)) {
                    return b.replace("{value}", d ? a[0] : a).replace("{value2}", d ? a[1] : a)
                } else {
                    if (F.isFunction(b)) {
                        return d ? b(X[0], X[1]) : b(X)
                    }
                }
                if (d) {
                    if (X[0] === W[0]) {
                        return U[0] + " " + a[1]
                    } else {
                        if (X[1] === W[1]) {
                            return U[1] + " " + a[0]
                        } else {
                            return a[0] + " - " + a[1]
                        }
                    }
                } else {
                    return a
                }

                function Y(e) {
                    return e === W[0] ? "min" : e === W[1] ? "max" : (+e).toFixed(V)
                }
            },
            resetExtent: function() {
                var V = this.option;
                var U = B([V.min, V.max]);
                this._dataExtent = U
            },
            getDataDimension: function(V) {
                var U = this.option.dimension;
                return U != null ? U : V.dimensions.length - 1
            },
            getExtent: function() {
                return this._dataExtent.slice()
            },
            completeVisualOption: function() {
                var b = this.option;
                var U = {inRange: b.inRange, outOfRange: b.outOfRange};
                var Z = b.target || (b.target = {});
                var X = b.controller || (b.controller = {});
                F.merge(Z, U);
                F.merge(X, U);
                var Y = this.isCategory();
                W.call(this, Z);
                W.call(this, X);
                a.call(this, Z, "inRange", "outOfRange");
                V.call(this, X);

                function W(c) {
                    if (K(b.color) && !c.inRange) {
                        c.inRange = {color: b.color.slice().reverse()}
                    }
                    c.inRange = c.inRange || {color: N};
                    H(this.stateList, function(f) {
                        var d = c[f];
                        if (F.isString(d)) {
                            var e = I.get(d, "active", Y);
                            if (e) {
                                c[f] = {};
                                c[f][d] = e
                            } else {
                                delete c[f]
                            }
                        }
                    }, this)
                }

                function a(g, c, f) {
                    var e = g[c];
                    var d = g[f];
                    if (e && !d) {
                        d = g[f] = {};
                        H(e, function(j, h) {
                            if (!P.isValidType(h)) {
                                return
                            }
                            var i = I.get(h, "inactive", Y);
                            if (i != null) {
                                d[h] = i;
                                if (h === "color" && !d.hasOwnProperty("opacity") && !d.hasOwnProperty("colorAlpha")) {
                                    d.opacity = [0, 0]
                                }
                            }
                        })
                    }
                }

                function V(f) {
                    var e = (f.inRange || {}).symbol || (f.outOfRange || {}).symbol;
                    var d = (f.inRange || {}).symbolSize || (f.outOfRange || {}).symbolSize;
                    var c = this.get("inactiveColor");
                    H(this.stateList, function(k) {
                        var h = this.itemSize;
                        var i = f[k];
                        if (!i) {
                            i = f[k] = {color: Y ? c : [c]}
                        }
                        if (i.symbol == null) {
                            i.symbol = e && F.clone(e) || (Y ? "roundRect" : ["roundRect"])
                        }
                        if (i.symbolSize == null) {
                            i.symbolSize = d && F.clone(d) || (Y ? h[0] : [h[0], h[0]])
                        }
                        i.symbol = R(i.symbol, function(l) {
                            return (l === "none" || l === "square") ? "roundRect" : l
                        });
                        var j = i.symbolSize;
                        if (j != null) {
                            var g = -Infinity;
                            S(j, function(l) {
                                l > g && (g = l)
                            });
                            i.symbolSize = R(j, function(l) {
                                return L(l, [0, g], [0, h[0]], true)
                            })
                        }
                    }, this)
                }
            },
            resetItemSize: function() {
                this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
            },
            isCategory: function() {
                return !!this.option.categories
            },
            setSelected: J,
            getValueState: J,
            getVisualMeta: J
        });
        O.exports = D
    }, function(D, E, C) {
        var B = C(4);
        var A = {
            get: function(I, G, H) {
                var J = B.clone((F[I] || {})[G]);
                return H ? (B.isArray(J) ? J[J.length - 1] : J) : J
            }
        };
        var F = {
            color: {active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"]},
            colorHue: {active: [0, 360], inactive: [0, 0]},
            colorSaturation: {active: [0.3, 1], inactive: [0, 0]},
            colorLightness: {active: [0.9, 0.5], inactive: [0, 0]},
            colorAlpha: {active: [0.3, 1], inactive: [0, 0]},
            opacity: {active: [0.3, 1], inactive: [0, 0]},
            symbol: {active: ["circle", "roundRect", "diamond"], inactive: ["none"]},
            symbolSize: {active: [10, 50], inactive: [0, 0]}
        };
        D.exports = A
    }, function(P, E, R) {
        var F = R(385);
        var I = R(18);
        var D = R(4);
        var N = R(7);
        var H = R(239);
        var J = R(65);
        var K = R(386);
        var C = R(5);
        var Q = R(88);
        var A = N.linearMap;
        var G = D.each;
        var T = Math.min;
        var L = Math.max;
        var W = 12;
        var B = 6;
        var O = F.extend({
            type: "visualMap.continuous", init: function() {
                O.superApply(this, "init", arguments);
                this._shapes = {};
                this._dataInterval = [];
                this._handleEnds = [];
                this._orient;
                this._useHandle;
                this._hoverLinkDataIndices = [];
                this._dragging;
                this._hovering
            }, doRender: function(a, Z, b, Y) {
                if (!Y || Y.type !== "selectDataRange" || Y.from !== this.uid) {
                    this._buildView()
                }
            }, _buildView: function() {
                this.group.removeAll();
                var Y = this.visualMapModel;
                var Z = this.group;
                this._orient = Y.get("orient");
                this._useHandle = Y.get("calculable");
                this._resetInterval();
                this._renderBar(Z);
                var a = Y.get("text");
                this._renderEndsText(Z, a, 0);
                this._renderEndsText(Z, a, 1);
                this._updateView(true);
                this.renderBackground(Z);
                this._updateView();
                this._enableHoverLinkToSeries();
                this._enableHoverLinkFromSeries();
                this.positionGroup(Z)
            }, _renderEndsText: function(d, j, g) {
                if (!j) {
                    return
                }
                var e = j[1 - g];
                e = e != null ? e + "" : "";
                var h = this.visualMapModel;
                var a = h.get("textGap");
                var i = h.itemSize;
                var Y = this._shapes.barGroup;
                var f = this._applyTransform([i[0] / 2, g === 0 ? -a : i[1] + a], Y);
                var c = this._applyTransform(g === 0 ? "bottom" : "top", Y);
                var Z = this._orient;
                var b = this.visualMapModel.textStyleModel;
                this.group.add(new I.Text({
                    style: {
                        x: f[0],
                        y: f[1],
                        textVerticalAlign: Z === "horizontal" ? "middle" : c,
                        textAlign: Z === "horizontal" ? c : "center",
                        text: e,
                        textFont: b.getFont(),
                        fill: b.getTextColor()
                    }
                }))
            }, _renderBar: function(b) {
                var f = this.visualMapModel;
                var h = this._shapes;
                var g = f.itemSize;
                var d = this._orient;
                var Y = this._useHandle;
                var Z = K.getItemAlign(f, this.api, g);
                var e = h.barGroup = this._createBarGroup(Z);
                e.add(h.outOfRange = V());
                e.add(h.inRange = V(null, Y ? "move" : null, D.bind(this._dragHandle, this, "all", false), D.bind(this._dragHandle, this, "all", true)));
                var a = f.textStyleModel.getTextRect("");
                var c = L(a.width, a.height);
                if (Y) {
                    h.handleThumbs = [];
                    h.handleLabels = [];
                    h.handleLabelPoints = [];
                    this._createHandle(e, 0, g, c, d, Z);
                    this._createHandle(e, 1, g, c, d, Z)
                }
                this._createIndicator(e, g, c, d);
                b.add(e)
            }, _createHandle: function(Y, c, i, d, f) {
                var e = D.bind(this._dragHandle, this, c, false);
                var a = D.bind(this._dragHandle, this, c, true);
                var b = V(U(c, d), "move", e, a);
                b.position[0] = i[0];
                Y.add(b);
                var j = this.visualMapModel.textStyleModel;
                var h = new I.Text({
                    draggable: true, drift: e, onmousemove: function(k) {
                        Q.stop(k.event)
                    }, ondragend: a, style: {x: 0, y: 0, text: "", textFont: j.getFont(), fill: j.getTextColor()}
                });
                this.group.add(h);
                var g = [f === "horizontal" ? d / 2 : d * 1.5, f === "horizontal" ? (c === 0 ? -(d * 1.5) : (d * 1.5)) : (c === 0 ? -d / 2 : d / 2)];
                var Z = this._shapes;
                Z.handleThumbs[c] = b;
                Z.handleLabelPoints[c] = g;
                Z.handleLabels[c] = h
            }, _createIndicator: function(Y, e, b, c) {
                var f = V([[0, 0]], "move");
                f.position[0] = e[0];
                f.attr({invisible: true, silent: true});
                Y.add(f);
                var g = this.visualMapModel.textStyleModel;
                var d = new I.Text({silent: true, invisible: true, style: {x: 0, y: 0, text: "", textFont: g.getFont(), fill: g.getTextColor()}});
                this.group.add(d);
                var Z = [c === "horizontal" ? b / 2 : B + 3, 0];
                var a = this._shapes;
                a.indicator = f;
                a.indicatorLabel = d;
                a.indicatorLabelPoint = Z
            }, _dragHandle: function(Z, b, Y, a) {
                if (!this._useHandle) {
                    return
                }
                this._dragging = !b;
                if (!b) {
                    var c = this._applyTransform([Y, a], this._shapes.barGroup, true);
                    this._updateInterval(Z, c[1]);
                    this._updateView()
                }
                if (b === !this.visualMapModel.get("realtime")) {
                    this.api.dispatchAction({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    })
                }
                if (b) {
                    !this._hovering && this._clearHoverLinkToSeries()
                } else {
                    if (X(this.visualMapModel)) {
                        this._doHoverLinkToSeries(this._handleEnds[Z], false)
                    }
                }
            }, _resetInterval: function() {
                var Y = this.visualMapModel;
                var Z = this._dataInterval = Y.getSelected();
                var b = Y.getExtent();
                var a = [0, Y.itemSize[1]];
                this._handleEnds = [A(Z[0], b, a, true), A(Z[1], b, a, true)]
            }, _updateInterval: function(b, Z) {
                Z = Z || 0;
                var c = this.visualMapModel;
                var Y = this._handleEnds;
                var d = [0, c.itemSize[1]];
                H(Z, Y, d, b, 0);
                var a = c.getExtent();
                this._dataInterval = [A(Y[0], d, a, true), A(Y[1], d, a, true)]
            }, _updateView: function(c) {
                var b = this.visualMapModel;
                var a = b.getExtent();
                var f = this._shapes;
                var d = [0, b.itemSize[1]];
                var Y = c ? d : this._handleEnds;
                var Z = this._createBarVisual(this._dataInterval, a, Y, "inRange");
                var e = this._createBarVisual(a, a, d, "outOfRange");
                f.inRange.setStyle({fill: Z.barColor, opacity: Z.opacity}).setShape("points", Z.barPoints);
                f.outOfRange.setStyle({fill: e.barColor, opacity: e.opacity}).setShape("points", e.barPoints);
                this._updateHandle(Y, Z)
            }, _createBarVisual: function(d, Z, e, Y) {
                var c = {forceState: Y, convertOpacityToAlpha: true};
                var b = this._makeColorGradient(d, c);
                var f = [this.getControllerVisual(d[0], "symbolSize", c), this.getControllerVisual(d[1], "symbolSize", c)];
                var a = this._createBarPoints(e, f);
                return {barColor: new J(0, 0, 0, 1, b), barPoints: a, handlesColor: [b[0].color, b[b.length - 1].color]}
            }, _makeColorGradient: function(b, a) {
                var c = 100;
                var d = [];
                var Y = (b[1] - b[0]) / c;
                d.push({color: this.getControllerVisual(b[0], "color", a), offset: 0});
                for (var Z = 1; Z < c; Z++) {
                    var e = b[0] + Y * Z;
                    if (e > b[1]) {
                        break
                    }
                    d.push({color: this.getControllerVisual(e, "color", a), offset: Z / c})
                }
                d.push({color: this.getControllerVisual(b[1], "color", a), offset: 1});
                return d
            }, _createBarPoints: function(Y, a) {
                var Z = this.visualMapModel.itemSize;
                return [[Z[0] - a[0], Y[0]], [Z[0], Y[0]], [Z[0], Y[1]], [Z[0] - a[1], Y[1]]]
            }, _createBarGroup: function(Z) {
                var a = this._orient;
                var Y = this.visualMapModel.get("inverse");
                return new I.Group((a === "horizontal" && !Y) ? {
                    scale: Z === "bottom" ? [1, 1] : [-1, 1],
                    rotation: Math.PI / 2
                } : (a === "horizontal" && Y) ? {
                    scale: Z === "bottom" ? [-1, 1] : [1, 1],
                    rotation: -Math.PI / 2
                } : (a === "vertical" && !Y) ? {scale: Z === "left" ? [1, -1] : [-1, -1]} : {scale: Z === "left" ? [1, 1] : [-1, 1]})
            }, _updateHandle: function(Y, Z) {
                if (!this._useHandle) {
                    return
                }
                var a = this._shapes;
                var b = this.visualMapModel;
                var c = a.handleThumbs;
                var d = a.handleLabels;
                G([0, 1], function(f) {
                    var g = c[f];
                    g.setStyle("fill", Z.handlesColor[f]);
                    g.position[1] = Y[f];
                    var e = I.applyTransform(a.handleLabelPoints[f], I.getTransform(g, this.group));
                    d[f].setStyle({
                        x: e[0],
                        y: e[1],
                        text: b.formatValueText(this._dataInterval[f]),
                        textVerticalAlign: "middle",
                        textAlign: this._applyTransform(this._orient === "horizontal" ? (f === 0 ? "bottom" : "top") : "left", a.barGroup)
                    })
                }, this)
            }, _showIndicator: function(g, i, e, j) {
                var Z = this.visualMapModel;
                var f = Z.getExtent();
                var h = Z.itemSize;
                var Y = [0, h[1]];
                var m = A(g, f, Y, true);
                var o = this._shapes;
                var n = o.indicator;
                if (!n) {
                    return
                }
                n.position[1] = m;
                n.attr("invisible", false);
                n.setShape("points", S(!!e, j, m, h[1]));
                var k = {convertOpacityToAlpha: true};
                var d = this.getControllerVisual(g, "color", k);
                n.setStyle("fill", d);
                var l = I.applyTransform(o.indicatorLabelPoint, I.getTransform(n, this.group));
                var b = o.indicatorLabel;
                b.attr("invisible", false);
                var a = this._applyTransform("left", o.barGroup);
                var c = this._orient;
                b.setStyle({
                    text: (e ? e : "") + Z.formatValueText(i),
                    textVerticalAlign: c === "horizontal" ? a : "middle",
                    textAlign: c === "horizontal" ? "center" : a,
                    x: l[0],
                    y: l[1]
                })
            }, _enableHoverLinkToSeries: function() {
                var Y = this;
                this._shapes.barGroup.on("mousemove", function(Z) {
                    Y._hovering = true;
                    if (!Y._dragging) {
                        var b = Y.visualMapModel.itemSize;
                        var a = Y._applyTransform([Z.offsetX, Z.offsetY], Y._shapes.barGroup, true, true);
                        a[1] = T(L(0, a[1]), b[1]);
                        Y._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= b[0])
                    }
                }).on("mouseout", function() {
                    Y._hovering = false;
                    !Y._dragging && Y._clearHoverLinkToSeries()
                })
            }, _enableHoverLinkFromSeries: function() {
                var Y = this.api.getZr();
                if (this.visualMapModel.option.hoverLink) {
                    Y.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
                    Y.on("mouseout", this._hideIndicator, this)
                } else {
                    this._clearHoverLinkFromSeries()
                }
            }, _doHoverLinkToSeries: function(c, k) {
                var j = this.visualMapModel;
                var h = j.itemSize;
                if (!j.option.hoverLink) {
                    return
                }
                var g = [0, h[1]];
                var b = j.getExtent();
                c = T(L(g[0], c), g[1]);
                var a = M(j, b, g);
                var e = [c - a, c + a];
                var Y = A(c, g, b, true);
                var i = [A(e[0], g, b, true), A(e[1], g, b, true)];
                e[0] < g[0] && (i[0] = -Infinity);
                e[1] > g[1] && (i[1] = Infinity);
                if (k) {
                    if (i[0] === -Infinity) {
                        this._showIndicator(Y, i[1], "< ", a)
                    } else {
                        if (i[1] === Infinity) {
                            this._showIndicator(Y, i[0], "> ", a)
                        } else {
                            this._showIndicator(Y, Y, " ", a)
                        }
                    }
                }
                var f = this._hoverLinkDataIndices;
                var d = [];
                if (k || X(j)) {
                    d = this._hoverLinkDataIndices = j.findTargetDataIndices(i)
                }
                var Z = C.compressBatches(f, d);
                this._dispatchHighDown("downplay", K.convertDataIndex(Z[0]));
                this._dispatchHighDown("highlight", K.convertDataIndex(Z[1]))
            }, _hoverLinkFromSeriesMouseOver: function(Z) {
                var Y = Z.target;
                var c = this.visualMapModel;
                if (!Y || Y.dataIndex == null) {
                    return
                }
                var d = this.ecModel.getSeriesByIndex(Y.seriesIndex);
                if (!c.isTargetSeries(d)) {
                    return
                }
                var f = d.getData(Y.dataType);
                var a = f.getDimension(c.getDataDimension(f));
                var b = f.get(a, Y.dataIndex, true);
                if (!isNaN(b)) {
                    this._showIndicator(b, b)
                }
            }, _hideIndicator: function() {
                var Y = this._shapes;
                Y.indicator && Y.indicator.attr("invisible", true);
                Y.indicatorLabel && Y.indicatorLabel.attr("invisible", true)
            }, _clearHoverLinkToSeries: function() {
                this._hideIndicator();
                var Y = this._hoverLinkDataIndices;
                this._dispatchHighDown("downplay", K.convertDataIndex(Y));
                Y.length = 0
            }, _clearHoverLinkFromSeries: function() {
                this._hideIndicator();
                var Y = this.api.getZr();
                Y.off("mouseover", this._hoverLinkFromSeriesMouseOver);
                Y.off("mouseout", this._hideIndicator)
            }, _applyTransform: function(Z, b, Y, a) {
                var c = I.getTransform(b, a ? null : this.group);
                return I[D.isArray(Z) ? "applyTransform" : "transformDirection"](Z, c, Y)
            }, _dispatchHighDown: function(Y, Z) {
                Z && Z.length && this.api.dispatchAction({type: Y, batch: Z})
            }, dispose: function() {
                this._clearHoverLinkFromSeries();
                this._clearHoverLinkToSeries()
            }, remove: function() {
                this._clearHoverLinkFromSeries();
                this._clearHoverLinkToSeries()
            }
        });

        function V(Z, Y, a, b) {
            return new I.Polygon({
                shape: {points: Z}, draggable: !!a, cursor: Y, drift: a, onmousemove: function(c) {
                    Q.stop(c.event)
                }, ondragend: b
            })
        }

        function U(Y, Z) {
            return Y === 0 ? [[0, 0], [Z, 0], [Z, -Z]] : [[0, 0], [Z, 0], [Z, Z]]
        }

        function S(Y, b, Z, a) {
            return Y ? [[0, -T(b, L(Z, 0))], [B, 0], [0, T(b, L(a - Z, 0))]] : [[0, 0], [5, -5], [5, 5]]
        }

        function M(Y, b, Z) {
            var a = W / 2;
            var c = Y.get("hoverLinkDataSize");
            if (c) {
                a = A(c, b, Z, true) / 2
            }
            return a
        }

        function X(Y) {
            return !Y.get("realtime") && Y.get("hoverLinkOnHandle")
        }

        P.exports = O
    }, function(G, I, D) {
        var B = D(4);
        var F = D(18);
        var C = D(6);
        var E = D(71);
        var H = D(1);
        var A = D(203);
        G.exports = H.extendComponentView({
            type: "visualMap", autoPositionValues: {left: 1, right: 1, top: 1, bottom: 1}, init: function(J, K) {
                this.ecModel = J;
                this.api = K;
                this.visualMapModel
            }, render: function(L, K, M, J) {
                this.visualMapModel = L;
                if (L.get("show") === false) {
                    this.group.removeAll();
                    return
                }
                this.doRender.apply(this, arguments)
            }, renderBackground: function(J) {
                var M = this.visualMapModel;
                var K = C.normalizeCssArray(M.get("padding") || 0);
                var L = J.getBoundingRect();
                J.add(new F.Rect({
                    z2: -1,
                    silent: true,
                    shape: {x: L.x - K[3], y: L.y - K[0], width: L.width + K[3] + K[1], height: L.height + K[0] + K[2]},
                    style: {fill: M.get("backgroundColor"), stroke: M.get("borderColor"), lineWidth: M.get("borderWidth")}
                }))
            }, getControllerVisual: function(Q, J, N) {
                N = N || {};
                var K = N.forceState;
                var R = this.visualMapModel;
                var S = {};
                if (J === "symbol") {
                    S.symbol = R.get("itemSymbol")
                }
                if (J === "color") {
                    var T = R.get("contentColor");
                    S.color = T
                }

                function L(U) {
                    return S[U]
                }

                function M(U, V) {
                    S[U] = V
                }

                var P = R.controllerVisuals[K || R.getValueState(Q)];
                var O = A.prepareVisualTypes(P);
                B.each(O, function(U) {
                    var V = P[U];
                    if (N.convertOpacityToAlpha && U === "opacity") {
                        U = "colorAlpha";
                        V = P.__alphaForOpacity
                    }
                    if (A.dependsOn(U, J)) {
                        V && V.applyVisual(Q, L, M)
                    }
                });
                return S[J]
            }, positionGroup: function(J) {
                var L = this.visualMapModel;
                var K = this.api;
                E.positionElement(J, L.getBoxLayoutParams(), {width: K.getWidth(), height: K.getHeight()})
            }, doRender: B.noop
        })
    }, function(C, F, B) {
        var A = B(4);
        var E = B(71);
        var D = {
            getItemAlign: function(Q, R, I) {
                var J = Q.option;
                var G = J.align;
                if (G != null && G !== "auto") {
                    return G
                }
                var M = {width: R.getWidth(), height: R.getHeight()};
                var S = J.orient === "horizontal" ? 1 : 0;
                var L = [["left", "right", "width"], ["top", "bottom", "height"]];
                var N = L[S];
                var H = [0, null, 10];
                var O = {};
                for (var P = 0; P < 3; P++) {
                    O[L[1 - S][P]] = H[P];
                    O[N[P]] = P === 2 ? I[0] : J[N[P]]
                }
                var T = [["x", "width", 3], ["y", "height", 0]][S];
                var K = E.getLayoutRect(O, M, J.padding);
                return N[(K.margin[T[2]] || 0) + K[T[0]] + K[T[1]] * 0.5 < M[T[1]] * 0.5 ? 0 : 1]
            }, convertDataIndex: function(G) {
                A.each(G || [], function(H) {
                    if (G.dataIndex != null) {
                        G.dataIndexInside = G.dataIndex;
                        G.dataIndex = null
                    }
                });
                return G
            }
        };
        C.exports = D
    }, function(C, E, A) {
        var D = A(1);
        var B = {type: "selectDataRange", event: "dataRangeSelected", update: "update"};
        D.registerAction(B, function(G, F) {
            F.eachComponent({mainType: "visualMap", query: G}, function(H) {
                H.setSelected(G.selected)
            })
        })
    }, function(B, C, A) {
        A(1).registerPreprocessor(A(378));
        A(379);
        A(380);
        A(389);
        A(390);
        A(387)
    }, function(I, K, E) {
        var G = E(382);
        var D = E(4);
        var B = E(203);
        var A = E(383);
        var C = E(7).reformIntervals;
        var H = G.extend({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                minOpen: false,
                maxOpen: false,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: true,
                showLabel: null
            },
            optionUpdated: function(M, N) {
                H.superApply(this, "optionUpdated", arguments);
                this._pieceList = [];
                this.resetTargetSeries();
                this.resetExtent();
                var L = this._mode = this._determineMode();
                F[this._mode].call(this);
                this._resetSelected(M, N);
                var O = this.option.categories;
                this.resetVisual(function(P, Q) {
                    if (L === "categories") {
                        P.mappingMethod = "category";
                        P.categories = D.clone(O)
                    } else {
                        P.dataExtent = this.getExtent();
                        P.mappingMethod = "piecewise";
                        P.pieceList = D.map(this._pieceList, function(R) {
                            var R = D.clone(R);
                            if (Q !== "inRange") {
                                R.visual = null
                            }
                            return R
                        })
                    }
                })
            },
            completeVisualOption: function() {
                var L = this.option;
                var N = {};
                var O = B.listVisualTypes();
                var M = this.isCategory();
                D.each(L.pieces, function(Q) {
                    D.each(O, function(R) {
                        if (Q.hasOwnProperty(R)) {
                            N[R] = 1
                        }
                    })
                });
                D.each(N, function(R, Q) {
                    var S = 0;
                    D.each(this.stateList, function(T) {
                        S |= P(L, T, Q) || P(L.target, T, Q)
                    }, this);
                    !S && D.each(this.stateList, function(T) {
                        (L[T] || (L[T] = {}))[Q] = A.get(Q, T === "inRange" ? "active" : "inactive", M)
                    })
                }, this);

                function P(Q, S, R) {
                    return Q && Q[S] && (D.isObject(Q[S]) ? Q[S].hasOwnProperty(R) : Q[S] === R)
                }

                G.prototype.completeVisualOption.apply(this, arguments)
            },
            _resetSelected: function(O, P) {
                var Q = this.option;
                var N = this._pieceList;
                var M = (P ? Q : O).selected || {};
                Q.selected = M;
                D.each(N, function(S, T) {
                    var R = this.getSelectedMapKey(S);
                    if (!M.hasOwnProperty(R)) {
                        M[R] = true
                    }
                }, this);
                if (Q.selectedMode === "single") {
                    var L = false;
                    D.each(N, function(S, T) {
                        var R = this.getSelectedMapKey(S);
                        if (M[R]) {
                            L ? (M[R] = false) : (L = true)
                        }
                    }, this)
                }
            },
            getSelectedMapKey: function(L) {
                return this._mode === "categories" ? L.value + "" : L.index + ""
            },
            getPieceList: function() {
                return this._pieceList
            },
            _determineMode: function() {
                var L = this.option;
                return L.pieces && L.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber"
            },
            setSelected: function(L) {
                this.option.selected = D.clone(L)
            },
            getValueState: function(M) {
                var L = B.findPieceIndex(M, this._pieceList);
                return L != null ? (this.option.selected[this.getSelectedMapKey(this._pieceList[L])] ? "inRange" : "outOfRange") : "outOfRange"
            },
            findTargetDataIndices: function(M) {
                var L = [];
                this.eachTargetSeries(function(N) {
                    var P = [];
                    var O = N.getData();
                    O.each(this.getDataDimension(O), function(S, Q) {
                        var R = B.findPieceIndex(S, this._pieceList);
                        R === M && P.push(Q)
                    }, true, this);
                    L.push({seriesId: N.id, dataIndex: P})
                }, this);
                return L
            },
            getRepresentValue: function(M) {
                var L;
                if (this.isCategory()) {
                    L = M.value
                } else {
                    if (M.value != null) {
                        L = M.value
                    } else {
                        var N = M.interval || [];
                        L = (N[0] === -Infinity && N[1] === Infinity) ? 0 : (N[0] + N[1]) / 2
                    }
                }
                return L
            },
            getVisualMeta: function(O) {
                if (this.isCategory()) {
                    return
                }
                var N = [];
                var L = [];
                var R = this;

                function S(U, V) {
                    var T = R.getRepresentValue({interval: U});
                    if (!V) {
                        V = R.getValueState(T)
                    }
                    var W = O(T, V);
                    if (U[0] === -Infinity) {
                        L[0] = W
                    } else {
                        if (U[1] === Infinity) {
                            L[1] = W
                        } else {
                            N.push({value: U[0], color: W}, {value: U[1], color: W})
                        }
                    }
                }

                var M = this._pieceList.slice();
                if (!M.length) {
                    M.push({interval: [-Infinity, Infinity]})
                } else {
                    var Q = M[0].interval[0];
                    Q !== -Infinity && M.unshift({interval: [-Infinity, Q]});
                    Q = M[M.length - 1].interval[1];
                    Q !== Infinity && M.push({interval: [Q, Infinity]})
                }
                var P = -Infinity;
                D.each(M, function(U) {
                    var T = U.interval;
                    if (T) {
                        T[0] > P && S([P, T[0]], "outOfRange");
                        S(T.slice());
                        P = T[1]
                    }
                }, this);
                return {stops: N, outerColors: L}
            }
        });
        var F = {
            splitNumber: function() {
                var S = this.option;
                var T = this._pieceList;
                var L = S.precision;
                var N = this.getExtent();
                var Q = S.splitNumber;
                Q = Math.max(parseInt(Q, 10), 1);
                S.splitNumber = Q;
                var O = (N[1] - N[0]) / Q;
                while (+O.toFixed(L) !== O && L < 5) {
                    L++
                }
                S.precision = L;
                O = +O.toFixed(L);
                var M = 0;
                if (S.minOpen) {
                    T.push({index: M++, interval: [-Infinity, N[0]], close: [0, 0]})
                }
                for (var P = N[0], R = M + Q; M < R; P += O) {
                    var U = M === Q - 1 ? N[1] : (P + O);
                    T.push({index: M++, interval: [P, U], close: [1, 1]})
                }
                if (S.maxOpen) {
                    T.push({index: M++, interval: [N[1], Infinity], close: [0, 0]})
                }
                C(T);
                D.each(T, function(V) {
                    V.text = this.formatValueText(V.interval)
                }, this)
            }, categories: function() {
                var L = this.option;
                D.each(L.categories, function(M) {
                    this._pieceList.push({text: this.formatValueText(M, true), value: M})
                }, this);
                J(L, this._pieceList)
            }, pieces: function() {
                var M = this.option;
                var L = this._pieceList;
                D.each(M.pieces, function(Y, O) {
                    if (!D.isObject(Y)) {
                        Y = {value: Y}
                    }
                    var U = {text: "", index: O};
                    if (Y.label != null) {
                        U.text = Y.label
                    }
                    if (Y.hasOwnProperty("value")) {
                        var Q = U.value = Y.value;
                        U.interval = [Q, Q];
                        U.close = [1, 1]
                    } else {
                        var T = U.interval = [];
                        var P = U.close = [0, 0];
                        var X = [1, 0, 1];
                        var N = [-Infinity, Infinity];
                        var S = [];
                        for (var W = 0; W < 2; W++) {
                            var V = [["gte", "gt", "min"], ["lte", "lt", "max"]][W];
                            for (var R = 0; R < 3 && T[W] == null; R++) {
                                T[W] = Y[V[R]];
                                P[W] = X[R];
                                S[W] = R === 2
                            }
                            T[W] == null && (T[W] = N[W])
                        }
                        S[0] && T[1] === Infinity && (P[0] = 0);
                        S[1] && T[0] === -Infinity && (P[1] = 0);
                        if (true) {
                            if (T[0] > T[1]) {
                                console.warn("Piece " + O + "is illegal: " + T + " lower bound should not greater then uppper bound.")
                            }
                        }
                        if (T[0] === T[1] && P[0] && P[1]) {
                            U.value = T[0]
                        }
                    }
                    U.visual = B.retrieveVisuals(Y);
                    L.push(U)
                }, this);
                J(M, L);
                C(L);
                D.each(L, function(O) {
                    var P = O.close;
                    var N = [["<", ""][P[1]], [">", ""][P[0]]];
                    O.text = O.text || this.formatValueText(O.value != null ? O.value : O.interval, false, N)
                }, this)
            }
        };

        function J(N, M) {
            var L = N.inverse;
            if (N.orient === "vertical" ? !L : L) {
                M.reverse()
            }
        }

        I.exports = H
    }, function(I, J, C) {
        var F = C(385);
        var B = C(4);
        var D = C(18);
        var G = C(111);
        var A = C(71);
        var H = C(386);
        var E = F.extend({
            type: "visualMap.piecewise", doRender: function() {
                var V = this.group;
                V.removeAll();
                var R = this.visualMapModel;
                var M = R.get("textGap");
                var Q = R.textStyleModel;
                var N = Q.getFont();
                var P = Q.getTextColor();
                var L = this._getItemAlign();
                var S = R.itemSize;
                var U = this._getViewData();
                var O = U.endsText;
                var K = B.retrieve(R.get("showLabel", true), !O);
                O && this._renderEndsText(V, O[0], S, K, L);
                B.each(U.viewPieceList, T, this);
                O && this._renderEndsText(V, O[1], S, K, L);
                A.box(R.get("orient"), V, R.get("itemGap"));
                this.renderBackground(V);
                this.positionGroup(V);

                function T(Z) {
                    var Y = Z.piece;
                    var X = new D.Group();
                    X.onclick = B.bind(this._onItemClick, this, Y);
                    this._enableHoverLink(X, Z.indexInModelPieceList);
                    var W = R.getRepresentValue(Y);
                    this._createItemSymbol(X, W, [0, 0, S[0], S[1]]);
                    if (K) {
                        var a = this.visualMapModel.getValueState(W);
                        X.add(new D.Text({
                            style: {
                                x: L === "right" ? -M : S[0] + M,
                                y: S[1] / 2,
                                text: Y.text,
                                textVerticalAlign: "middle",
                                textAlign: L,
                                textFont: N,
                                fill: P,
                                opacity: a === "outOfRange" ? 0.5 : 1
                            }
                        }))
                    }
                    V.add(X)
                }
            }, _enableHoverLink: function(K, M) {
                K.on("mouseover", B.bind(L, this, "highlight")).on("mouseout", B.bind(L, this, "downplay"));

                function L(O) {
                    var N = this.visualMapModel;
                    N.option.hoverLink && this.api.dispatchAction({type: O, batch: H.convertDataIndex(N.findTargetDataIndices(M))})
                }
            }, _getItemAlign: function() {
                var L = this.visualMapModel;
                var K = L.option;
                if (K.orient === "vertical") {
                    return H.getItemAlign(L, this.api, L.itemSize)
                } else {
                    var M = K.align;
                    if (!M || M === "auto") {
                        M = "left"
                    }
                    return M
                }
            }, _renderEndsText: function(L, O, P, Q, N) {
                if (!O) {
                    return
                }
                var M = new D.Group();
                var K = this.visualMapModel.textStyleModel;
                M.add(new D.Text({
                    style: {
                        x: Q ? (N === "right" ? P[0] : 0) : P[0] / 2,
                        y: P[1] / 2,
                        textVerticalAlign: "middle",
                        textAlign: Q ? N : "center",
                        text: O,
                        textFont: K.getFont(),
                        fill: K.getTextColor()
                    }
                }));
                L.add(M)
            }, _getViewData: function() {
                var L = this.visualMapModel;
                var O = B.map(L.getPieceList(), function(P, Q) {
                    return {piece: P, indexInModelPieceList: Q}
                });
                var N = L.get("text");
                var M = L.get("orient");
                var K = L.get("inverse");
                if (M === "horizontal" ? K : !K) {
                    O.reverse()
                } else {
                    if (N) {
                        N = N.slice().reverse()
                    }
                }
                return {viewPieceList: O, endsText: N}
            }, _createItemSymbol: function(K, L, M) {
                K.add(G.createSymbol(this.getControllerVisual(L, "symbol"), M[0], M[1], M[2], M[3], this.getControllerVisual(L, "color")))
            }, _onItemClick: function(L) {
                var M = this.visualMapModel;
                var K = M.option;
                var O = B.clone(K.selected);
                var N = M.getSelectedMapKey(L);
                if (K.selectedMode === "single") {
                    O[N] = true;
                    B.each(O, function(Q, P) {
                        O[P] = P === N
                    })
                } else {
                    O[N] = !O[N]
                }
                this.api.dispatchAction({type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: O})
            }
        });
        I.exports = E
    }, function(B, C, A) {
        A(392);
        A(394);
        A(1).registerPreprocessor(function(D) {
            D.markPoint = D.markPoint || {}
        })
    }, function(B, C, A) {
        B.exports = A(393).extend({
            type: "markPoint",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: "pin",
                symbolSize: 50,
                tooltip: {trigger: "item"},
                label: {normal: {show: true, position: "inside"}, emphasis: {show: true}},
                itemStyle: {normal: {borderWidth: 2}}
            }
        })
    }, function(I, K, D) {
        var A = D(5);
        var B = D(4);
        var E = D(2);
        var C = D(6);
        var J = C.addCommas;
        var G = C.encodeHTML;

        function F(L) {
            A.defaultEmphasis(L.label, A.LABEL_OPTIONS)
        }

        var H = D(1).extendComponentModel({
            type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function(L, O, M, N) {
                if (true) {
                    if (this.type === "marker") {
                        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.")
                    }
                }
                this.mergeDefaultAndTheme(L, M);
                this.mergeOption(L, M, N.createdBySelf, true)
            }, isAnimationEnabled: function() {
                if (E.node) {
                    return false
                }
                var L = this.__hostSeries;
                return this.getShallow("animation") && L && L.isAnimationEnabled()
            }, mergeOption: function(L, M, P, O) {
                var Q = this.constructor;
                var N = this.mainType + "Model";
                if (!P) {
                    M.eachSeries(function(R) {
                        var S = R.get(this.mainType);
                        var T = R[N];
                        if (!S || !S.data) {
                            R[N] = null;
                            return
                        }
                        if (!T) {
                            if (O) {
                                F(S)
                            }
                            B.each(S.data, function(U) {
                                if (U instanceof Array) {
                                    F(U[0]);
                                    F(U[1])
                                } else {
                                    F(U)
                                }
                            });
                            T = new Q(S, this, M);
                            B.extend(T, {mainType: this.mainType, seriesIndex: R.seriesIndex, name: R.name, createdBySelf: true});
                            T.__hostSeries = R
                        } else {
                            T.mergeOption(S, M, true)
                        }
                        R[N] = T
                    }, this)
                }
            }, formatTooltip: function(M) {
                var Q = this.getData();
                var P = this.getRawValue(M);
                var N = B.isArray(P) ? B.map(P, J).join(", ") : J(P);
                var O = Q.getName(M);
                var L = G(this.name);
                if (P != null || O) {
                    L += "<br />"
                }
                if (O) {
                    L += G(O);
                    if (P != null) {
                        L += " : "
                    }
                }
                if (P != null) {
                    L += G(N)
                }
                return L
            }, getData: function() {
                return this._data
            }, setData: function(L) {
                this._data = L
            }
        });
        B.mixin(H, A.dataFormatMixin);
        I.exports = H
    }, function(H, J, B) {
        var G = B(116);
        var A = B(4);
        var D = B(7);
        var I = B(98);
        var C = B(395);

        function E(M, K, N) {
            var L = K.coordinateSystem;
            M.each(function(S) {
                var P = M.getItemModel(S);
                var O;
                var Q = D.parsePercent(P.get("x"), N.getWidth());
                var R = D.parsePercent(P.get("y"), N.getHeight());
                if (!isNaN(Q) && !isNaN(R)) {
                    O = [Q, R]
                } else {
                    if (K.getMarkerPosition) {
                        O = K.getMarkerPosition(M.getValues(M.dimensions, S))
                    } else {
                        if (L) {
                            var T = M.get(L.dimensions[0], S);
                            var U = M.get(L.dimensions[1], S);
                            O = L.dataToPoint([T, U])
                        }
                    }
                }
                if (!isNaN(Q)) {
                    O[0] = Q
                }
                if (!isNaN(R)) {
                    O[1] = R
                }
                M.setItemLayout(S, O)
            })
        }

        B(396).extend({
            type: "markPoint", updateLayout: function(L, K, M) {
                K.eachSeries(function(N) {
                    var O = N.markPointModel;
                    if (O) {
                        E(O.getData(), N, M);
                        this.markerGroupMap.get(N.id).updateLayout(O)
                    }
                }, this)
            }, renderSeries: function(T, P, K, R) {
                var L = T.coordinateSystem;
                var N = T.id;
                var O = T.getData();
                var S = this.markerGroupMap;
                var Q = S.get(N) || S.set(N, new G());
                var M = F(L, T, P);
                P.setData(M);
                E(P.getData(), T, R);
                M.each(function(V) {
                    var U = M.getItemModel(V);
                    var W = U.getShallow("symbolSize");
                    if (typeof W === "function") {
                        W = W(P.getRawValue(V), P.getDataParams(V))
                    }
                    M.setItemVisual(V, {
                        symbolSize: W,
                        color: U.get("itemStyle.normal.color") || O.getVisual("color"),
                        symbol: U.getShallow("symbol")
                    })
                });
                Q.updateData(M);
                this.group.add(Q.group);
                M.eachItemGraphicEl(function(U) {
                    U.traverse(function(V) {
                        V.dataModel = P
                    })
                });
                Q.__keep = true;
                Q.group.silent = P.get("silent") || T.get("silent")
            }
        });

        function F(M, K, N) {
            var P;
            if (M) {
                P = A.map(M && M.dimensions, function(Q) {
                    var R = K.getData().getDimensionInfo(K.coordDimToDataDim(Q)[0]) || {};
                    R.name = Q;
                    return R
                })
            } else {
                P = [{name: "value", type: "float"}]
            }
            var O = new I(P, N);
            var L = A.map(N.get("data"), A.curry(C.dataTransform, K));
            if (M) {
                L = A.filter(L, A.curry(C.dataFilter, M))
            }
            O.initData(L, null, M ? C.dimValueGetter : function(Q) {
                return Q.value
            });
            return O
        }
    }, function(C, F, O) {
        var E = O(4);
        var K = O(7);
        var Q = E.indexOf;

        function D(R) {
            return !(isNaN(parseFloat(R.x)) && isNaN(parseFloat(R.y)))
        }

        function L(R) {
            return !isNaN(parseFloat(R.x)) && !isNaN(parseFloat(R.y))
        }

        function J(U, S, R) {
            var T = -1;
            do {
                T = Math.max(K.getPrecision(U.get(S, R)), T);
                U = U.stackedOn
            } while (U);
            return T
        }

        function N(Y, U, Z, W, R, a) {
            var S = [];
            var V = M(U, W, Y);
            var X = U.indicesOfNearest(W, V, true)[0];
            S[R] = U.get(Z, X, true);
            S[a] = U.get(W, X, true);
            var T = J(U, W, X);
            if (T >= 0) {
                S[a] = +S[a].toFixed(T)
            }
            return S
        }

        var B = E.curry;
        var A = {min: B(N, "min"), max: B(N, "max"), average: B(N, "average")};
        var H = function(W, b) {
            var U = W.getData();
            var T = W.coordinateSystem;
            if (b && !L(b) && !E.isArray(b.coord) && T) {
                var V = T.dimensions;
                var Z = P(b, U, T, W);
                b = E.clone(b);
                if (b.type && A[b.type] && Z.baseAxis && Z.valueAxis) {
                    var R = Q(V, Z.baseAxis.dim);
                    var a = Q(V, Z.valueAxis.dim);
                    b.coord = A[b.type](U, Z.baseDataDim, Z.valueDataDim, R, a);
                    b.value = b.coord[a]
                } else {
                    var Y = [b.xAxis != null ? b.xAxis : b.radiusAxis, b.yAxis != null ? b.yAxis : b.angleAxis];
                    for (var X = 0; X < 2; X++) {
                        if (A[Y[X]]) {
                            var S = W.coordDimToDataDim(V[X])[0];
                            Y[X] = M(U, S, Y[X])
                        }
                    }
                    b.coord = Y
                }
            }
            return b
        };
        var P = function(T, V, S, R) {
            var U = {};
            if (T.valueIndex != null || T.valueDim != null) {
                U.valueDataDim = T.valueIndex != null ? V.getDimension(T.valueIndex) : T.valueDim;
                U.valueAxis = S.getAxis(R.dataDimToCoordDim(U.valueDataDim));
                U.baseAxis = S.getOtherAxis(U.valueAxis);
                U.baseDataDim = R.coordDimToDataDim(U.baseAxis.dim)[0]
            } else {
                U.baseAxis = R.getBaseAxis();
                U.valueAxis = S.getOtherAxis(U.baseAxis);
                U.baseDataDim = R.coordDimToDataDim(U.baseAxis.dim)[0];
                U.valueDataDim = R.coordDimToDataDim(U.valueAxis.dim)[0]
            }
            return U
        };
        var I = function(R, S) {
            return (R && R.containData && S.coord && !D(S)) ? R.containData(S.coord) : true
        };
        var G = function(T, U, R, S) {
            if (S < 2) {
                return T.coord && T.coord[S]
            }
            return T.value
        };
        var M = function(V, T, R) {
            if (R === "average") {
                var U = 0;
                var S = 0;
                V.each(T, function(X, W) {
                    if (!isNaN(X)) {
                        U += X;
                        S++
                    }
                }, true);
                return U / S
            } else {
                return V.getDataExtent(T, true)[R === "max" ? 1 : 0]
            }
        };
        C.exports = {dataTransform: H, dataFilter: I, dimValueGetter: G, getAxisInfo: P, numCalculate: M}
    }, function(C, D, B) {
        var A = B(4);
        C.exports = B(1).extendComponentView({
            type: "marker", init: function() {
                this.markerGroupMap = A.createHashMap()
            }, render: function(I, G, H) {
                var E = this.markerGroupMap;
                E.each(function(J) {
                    J.__keep = false
                });
                var F = this.type + "Model";
                G.eachSeries(function(J) {
                    var K = J[F];
                    K && this.renderSeries(J, K, G, H)
                }, this);
                E.each(function(J) {
                    !J.__keep && this.group.remove(J.group)
                }, this)
            }, renderSeries: function() {
            }
        })
    }, function(B, C, A) {
        A(398);
        A(399);
        A(1).registerPreprocessor(function(D) {
            D.markLine = D.markLine || {}
        })
    }, function(B, C, A) {
        B.exports = A(393).extend({
            type: "markLine",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: ["circle", "arrow"],
                symbolSize: [8, 16],
                precision: 2,
                tooltip: {trigger: "item"},
                label: {normal: {show: true, position: "end"}, emphasis: {show: true}},
                lineStyle: {normal: {type: "dashed"}, emphasis: {width: 3}},
                animationEasing: "linear"
            }
        })
    }, function(L, N, E) {
        var D = E(4);
        var M = E(98);
        var G = E(7);
        var F = E(395);
        var A = E(210);
        var H = function(T, Q, W, c) {
            var R = T.getData();
            var Z = c.type;
            if (!D.isArray(c) && (Z === "min" || Z === "max" || Z === "average" || (c.xAxis != null || c.yAxis != null))) {
                var O;
                var V;
                var U;
                if (c.yAxis != null || c.xAxis != null) {
                    V = c.yAxis != null ? "y" : "x";
                    O = Q.getAxis(V);
                    U = D.retrieve(c.yAxis, c.xAxis)
                } else {
                    var Y = F.getAxisInfo(c, R, Q, T);
                    V = Y.valueDataDim;
                    O = Y.valueAxis;
                    U = F.numCalculate(R, V, Z)
                }
                var X = V === "x" ? 0 : 1;
                var b = 1 - X;
                var P = D.clone(c);
                var S = {};
                P.type = null;
                P.coord = [];
                S.coord = [];
                P.coord[b] = -Infinity;
                S.coord[b] = Infinity;
                var a = W.get("precision");
                if (a >= 0 && typeof U === "number") {
                    U = +U.toFixed(a)
                }
                P.coord[X] = S.coord[X] = U;
                c = [P, S, {type: Z, valueIndex: c.valueIndex, value: U}]
            }
            c = [F.dataTransform(T, c[0]), F.dataTransform(T, c[1]), D.extend({}, c[2])];
            c[2].type = c[2].type || "";
            D.merge(c[2], c[0]);
            D.merge(c[2], c[1]);
            return c
        };

        function B(O) {
            return !isNaN(O) && !isFinite(O)
        }

        function J(P, T, S, Q) {
            var O = 1 - P;
            var R = Q.dimensions[P];
            return B(T[O]) && B(S[O]) && T[P] === S[P] && Q.getAxis(R).containData(T[P])
        }

        function I(O, P) {
            if (O.type === "cartesian2d") {
                var R = P[0].coord;
                var Q = P[1].coord;
                if (R && Q && (J(1, R, Q, O) || J(0, R, Q, O))) {
                    return true
                }
            }
            return F.dataFilter(O, P[0]) && F.dataFilter(O, P[1])
        }

        function K(R, U, Z, c, a) {
            var Q = c.coordinateSystem;
            var P = R.getItemModel(U);
            var T;
            var S = G.parsePercent(P.get("x"), a.getWidth());
            var b = G.parsePercent(P.get("y"), a.getHeight());
            if (!isNaN(S) && !isNaN(b)) {
                T = [S, b]
            } else {
                if (c.getMarkerPosition) {
                    T = c.getMarkerPosition(R.getValues(R.dimensions, U))
                } else {
                    var X = Q.dimensions;
                    var Y = R.get(X[0], U);
                    var O = R.get(X[1], U);
                    T = Q.dataToPoint([Y, O])
                }
                if (Q.type === "cartesian2d") {
                    var W = Q.getAxis("x");
                    var V = Q.getAxis("y");
                    var X = Q.dimensions;
                    if (B(R.get(X[0], U))) {
                        T[0] = W.toGlobalCoord(W.getExtent()[Z ? 0 : 1])
                    } else {
                        if (B(R.get(X[1], U))) {
                            T[1] = V.toGlobalCoord(V.getExtent()[Z ? 0 : 1])
                        }
                    }
                }
                if (!isNaN(S)) {
                    T[0] = S
                }
                if (!isNaN(b)) {
                    T[1] = b
                }
            }
            R.setItemLayout(U, T)
        }

        E(396).extend({
            type: "markLine", updateLayout: function(Q, O, P) {
                O.eachSeries(function(S) {
                    var T = S.markLineModel;
                    if (T) {
                        var V = T.getData();
                        var U = T.__from;
                        var R = T.__to;
                        U.each(function(W) {
                            K(U, W, true, S, P);
                            K(R, W, false, S, P)
                        });
                        V.each(function(W) {
                            V.setItemLayout(W, [U.getItemLayout(W), R.getItemLayout(W)])
                        });
                        this.markerGroupMap.get(S.id).updateLayout()
                    }
                }, this)
            }, renderSeries: function(d, Y, P, b) {
                var Q = d.coordinateSystem;
                var T = d.id;
                var V = d.getData();
                var Z = this.markerGroupMap;
                var U = Z.get(T) || Z.set(T, new A());
                this.group.add(U.group);
                var c = C(Q, d, Y);
                var X = c.from;
                var a = c.to;
                var S = c.line;
                Y.__from = X;
                Y.__to = a;
                Y.setData(S);
                var R = Y.get("symbol");
                var O = Y.get("symbolSize");
                if (!D.isArray(R)) {
                    R = [R, R]
                }
                if (typeof O === "number") {
                    O = [O, O]
                }
                c.from.each(function(e) {
                    W(X, e, true);
                    W(a, e, false)
                });
                S.each(function(f) {
                    var e = S.getItemModel(f).get("lineStyle.normal.color");
                    S.setItemVisual(f, {color: e || X.getItemVisual(f, "color")});
                    S.setItemLayout(f, [X.getItemLayout(f), a.getItemLayout(f)]);
                    S.setItemVisual(f, {
                        "fromSymbolSize": X.getItemVisual(f, "symbolSize"),
                        "fromSymbol": X.getItemVisual(f, "symbol"),
                        "toSymbolSize": a.getItemVisual(f, "symbolSize"),
                        "toSymbol": a.getItemVisual(f, "symbol")
                    })
                });
                U.updateData(S);
                c.line.eachItemGraphicEl(function(e, f) {
                    e.traverse(function(g) {
                        g.dataModel = Y
                    })
                });

                function W(h, g, e) {
                    var f = h.getItemModel(g);
                    K(h, g, e, d, b);
                    h.setItemVisual(g, {
                        symbolSize: f.get("symbolSize") || O[e ? 0 : 1],
                        symbol: f.get("symbol", true) || R[e ? 0 : 1],
                        color: f.get("itemStyle.normal.color") || V.getVisual("color")
                    })
                }

                U.__keep = true;
                U.group.silent = Y.get("silent") || d.get("silent")
            }
        });

        function C(Q, W, T) {
            var R;
            if (Q) {
                R = D.map(Q && Q.dimensions, function(X) {
                    var Y = W.getData().getDimensionInfo(W.coordDimToDataDim(X)[0]) || {};
                    Y.name = X;
                    return Y
                })
            } else {
                R = [{name: "value", type: "float"}]
            }
            var S = new M(R, T);
            var V = new M(R, T);
            var U = new M([], T);
            var P = D.map(T.get("data"), D.curry(H, W, Q, T));
            if (Q) {
                P = D.filter(P, D.curry(I, Q))
            }
            var O = Q ? F.dimValueGetter : function(X) {
                return X.value
            };
            S.initData(D.map(P, function(X) {
                return X[0]
            }), null, O);
            V.initData(D.map(P, function(X) {
                return X[1]
            }), null, O);
            U.initData(D.map(P, function(X) {
                return X[2]
            }));
            U.hasItemOption = true;
            return {from: S, to: V, line: U}
        }
    }, function(B, C, A) {
        A(401);
        A(402);
        A(1).registerPreprocessor(function(D) {
            D.markArea = D.markArea || {}
        })
    }, function(B, C, A) {
        B.exports = A(393).extend({
            type: "markArea",
            defaultOption: {
                zlevel: 0,
                z: 1,
                tooltip: {trigger: "item"},
                animation: false,
                label: {normal: {show: true, position: "top"}, emphasis: {show: true, position: "top"}},
                itemStyle: {normal: {borderWidth: 0}}
            }
        })
    }, function(N, P, E) {
        var D = E(4);
        var O = E(98);
        var G = E(7);
        var I = E(18);
        var C = E(31);
        var F = E(395);
        var A = function(T, S, Q, Z) {
            var V = F.dataTransform(T, Z[0]);
            var U = F.dataTransform(T, Z[1]);
            var X = D.retrieve;
            var Y = V.coord;
            var W = U.coord;
            Y[0] = X(Y[0], -Infinity);
            Y[1] = X(Y[1], -Infinity);
            W[0] = X(W[0], Infinity);
            W[1] = X(W[1], Infinity);
            var R = D.mergeAll([{}, V, U]);
            R.coord = [V.coord, U.coord];
            R.x0 = V.x;
            R.y0 = V.y;
            R.x1 = U.x;
            R.y1 = U.y;
            return R
        };

        function K(Q) {
            return !isNaN(Q) && !isFinite(Q)
        }

        function B(R, U, T, S) {
            var Q = 1 - R;
            return K(U[Q]) && K(T[Q])
        }

        function M(Q, R) {
            var T = R.coord[0];
            var S = R.coord[1];
            if (Q.type === "cartesian2d") {
                if (T && S && (B(1, T, S, Q) || B(0, T, S, Q))) {
                    return true
                }
            }
            return F.dataFilter(Q, {coord: T, x: R.x0, y: R.y0}) || F.dataFilter(Q, {coord: S, x: R.x1, y: R.y1})
        }

        function H(T, W, V, d, b) {
            var S = d.coordinateSystem;
            var R = T.getItemModel(W);
            var a;
            var U = G.parsePercent(R.get(V[0]), b.getWidth());
            var c = G.parsePercent(R.get(V[1]), b.getHeight());
            if (!isNaN(U) && !isNaN(c)) {
                a = [U, c]
            } else {
                if (d.getMarkerPosition) {
                    a = d.getMarkerPosition(T.getValues(V, W))
                } else {
                    var Z = T.get(V[0], W);
                    var Q = T.get(V[1], W);
                    a = S.dataToPoint([Z, Q], true)
                }
                if (S.type === "cartesian2d") {
                    var Y = S.getAxis("x");
                    var X = S.getAxis("y");
                    var Z = T.get(V[0], W);
                    var Q = T.get(V[1], W);
                    if (K(Z)) {
                        a[0] = Y.toGlobalCoord(Y.getExtent()[V[0] === "x0" ? 0 : 1])
                    } else {
                        if (K(Q)) {
                            a[1] = X.toGlobalCoord(X.getExtent()[V[1] === "y0" ? 0 : 1])
                        }
                    }
                }
                if (!isNaN(U)) {
                    a[0] = U
                }
                if (!isNaN(c)) {
                    a[1] = c
                }
            }
            return a
        }

        var L = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
        E(396).extend({
            type: "markArea", updateLayout: function(R, Q, S) {
                Q.eachSeries(function(T) {
                    var U = T.markAreaModel;
                    if (U) {
                        var V = U.getData();
                        V.each(function(Y) {
                            var X = D.map(L, function(Z) {
                                return H(V, Y, Z, T, S)
                            });
                            V.setItemLayout(Y, X);
                            var W = V.getItemGraphicEl(Y);
                            W.setShape("points", X)
                        })
                    }
                }, this)
            }, renderSeries: function(T, Q, R, Y) {
                var S = T.coordinateSystem;
                var Z = T.name;
                var U = T.getData();
                var W = this.markerGroupMap;
                var V = W.get(Z) || W.set(Z, {group: new I.Group()});
                this.group.add(V.group);
                V.__keep = true;
                var X = J(S, T, Q);
                Q.setData(X);
                X.each(function(a) {
                    X.setItemLayout(a, D.map(L, function(b) {
                        return H(X, a, b, T, Y)
                    }));
                    X.setItemVisual(a, {color: U.getVisual("color")})
                });
                X.diff(V.__data).add(function(a) {
                    var b = new I.Polygon({shape: {points: X.getItemLayout(a)}});
                    X.setItemGraphicEl(a, b);
                    V.group.add(b)
                }).update(function(a, b) {
                    var c = V.__data.getItemGraphicEl(b);
                    I.updateProps(c, {shape: {points: X.getItemLayout(a)}}, Q, a);
                    V.group.add(c);
                    X.setItemGraphicEl(a, c)
                }).remove(function(a) {
                    var b = V.__data.getItemGraphicEl(a);
                    V.group.remove(b)
                }).execute();
                X.eachItemGraphicEl(function(f, d) {
                    var b = X.getItemModel(d);
                    var e = b.getModel("label.normal");
                    var a = b.getModel("label.emphasis");
                    var c = X.getItemVisual(d, "color");
                    f.useStyle(D.defaults(b.getModel("itemStyle.normal").getItemStyle(), {fill: C.modifyAlpha(c, 0.4), stroke: c}));
                    f.hoverStyle = b.getModel("itemStyle.normal").getItemStyle();
                    var h = X.getName(d) || "";
                    var g = c || f.style.fill;
                    if (e.getShallow("show")) {
                        I.setText(f.style, e, g);
                        f.style.text = D.retrieve(Q.getFormattedLabel(d, "normal"), h)
                    } else {
                        f.style.text = ""
                    }
                    if (a.getShallow("show")) {
                        I.setText(f.hoverStyle, a, g);
                        f.hoverStyle.text = D.retrieve(Q.getFormattedLabel(d, "emphasis"), h)
                    } else {
                        f.hoverStyle.text = ""
                    }
                    I.setHoverStyle(f, {});
                    f.dataModel = Q
                });
                V.__data = X;
                V.group.silent = Q.get("silent") || T.get("silent")
            }
        });

        function J(S, X, Q) {
            var T;
            var V;
            var W = ["x0", "y0", "x1", "y1"];
            if (S) {
                T = D.map(S && S.dimensions, function(Y) {
                    var Z = X.getData().getDimensionInfo(X.coordDimToDataDim(Y)[0]) || {};
                    Z.name = Y;
                    return Z
                });
                V = new O(D.map(W, function(Z, Y) {
                    return {name: Z, type: T[Y % 2].type}
                }), Q)
            } else {
                T = [{name: "value", type: "float"}];
                V = new O(T, Q)
            }
            var R = D.map(Q.get("data"), D.curry(A, X, S, Q));
            if (S) {
                R = D.filter(R, D.curry(M, S))
            }
            var U = S ? function(a, b, Y, Z) {
                return a.coord[Math.floor(Z / 2)][Z % 2]
            } : function(Y) {
                return Y.value
            };
            V.initData(R, null, U);
            V.hasItemOption = true;
            return V
        }
    }, function(B, D, A) {
        var C = A(1);
        C.registerPreprocessor(A(404));
        A(405);
        A(406);
        A(407);
        A(409)
    }, function(D, F, C) {
        var B = C(4);
        D.exports = function(H) {
            var I = H && H.timeline;
            if (!B.isArray(I)) {
                I = I ? [I] : []
            }
            B.each(I, function(J) {
                if (!J) {
                    return
                }
                A(J)
            })
        };

        function A(I) {
            var H = I.type;
            var J = {"number": "value", "time": "time"};
            if (J[H]) {
                I.axisType = J[H];
                delete I.type
            }
            E(I);
            if (G(I, "controlPosition")) {
                var K = I.controlStyle || (I.controlStyle = {});
                if (!G(K, "position")) {
                    K.position = I.controlPosition
                }
                if (K.position === "none" && !G(K, "show")) {
                    K.show = false;
                    delete K.position
                }
                delete I.controlPosition
            }
            B.each(I.data || [], function(L) {
                if (B.isObject(L) && !B.isArray(L)) {
                    if (!G(L, "value") && G(L, "name")) {
                        L.value = L.name
                    }
                    E(L)
                }
            })
        }

        function E(J) {
            var L = J.itemStyle || (J.itemStyle = {});
            var K = L.emphasis || (L.emphasis = {});
            var H = J.label || (J.label || {});
            var I = H.normal || (H.normal = {});
            var M = {normal: 1, emphasis: 1};
            B.each(H, function(O, N) {
                if (!M[N] && !G(I, N)) {
                    I[N] = O
                }
            });
            if (K.label && !G(H, "emphasis")) {
                H.emphasis = K.label;
                delete K.label
            }
        }

        function G(H, I) {
            return H.hasOwnProperty(I)
        }
    }, function(B, C, A) {
        A(69).registerSubTypeDefaulter("timeline", function() {
            return "slider"
        })
    }, function(C, E, B) {
        var D = B(1);
        var A = B(4);
        D.registerAction({type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate"}, function(H, G) {
            var F = G.getComponent("timeline");
            if (F && H.currentIndex != null) {
                F.setCurrentIndex(H.currentIndex);
                if (!F.get("loop", true) && F.isIndexMax()) {
                    F.setPlayState(false)
                }
            }
            G.resetOption("timeline");
            return A.defaults({currentIndex: F.option.currentIndex}, H)
        });
        D.registerAction({type: "timelinePlayChange", event: "timelinePlayChanged", update: "update"}, function(H, G) {
            var F = G.getComponent("timeline");
            if (F && H.playState != null) {
                F.setPlayState(H.playState)
            }
        })
    }, function(E, G, C) {
        var A = C(408);
        var F = C(4);
        var D = C(5);
        var B = A.extend({
            type: "timeline.slider",
            defaultOption: {
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                orient: "horizontal",
                inverse: false,
                tooltip: {trigger: "item"},
                symbol: "emptyCircle",
                symbolSize: 10,
                lineStyle: {show: true, width: 2, color: "#304654"},
                label: {
                    position: "auto",
                    normal: {show: true, interval: "auto", rotate: 0, textStyle: {color: "#304654"}},
                    emphasis: {show: true, textStyle: {color: "#c23531"}}
                },
                itemStyle: {normal: {color: "#304654", borderWidth: 1}, emphasis: {color: "#c23531"}},
                checkpointStyle: {
                    symbol: "circle",
                    symbolSize: 13,
                    color: "#c23531",
                    borderWidth: 5,
                    borderColor: "rgba(194,53,49, 0.5)",
                    animation: true,
                    animationDuration: 300,
                    animationEasing: "quinticInOut"
                },
                controlStyle: {
                    show: true,
                    showPlayBtn: true,
                    showPrevBtn: true,
                    showNextBtn: true,
                    itemSize: 22,
                    itemGap: 12,
                    position: "left",
                    playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                    stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                    nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                    prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                    normal: {color: "#304654", borderColor: "#304654", borderWidth: 1},
                    emphasis: {color: "#c23531", borderColor: "#c23531", borderWidth: 2}
                },
                data: []
            }
        });
        F.mixin(B, D.dataFormatMixin);
        E.exports = B
    }, function(F, H, D) {
        var G = D(69);
        var A = D(98);
        var C = D(4);
        var B = D(5);
        var E = G.extend({
            type: "timeline",
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: true,
                axisType: "time",
                realtime: true,
                left: "20%",
                top: null,
                right: "20%",
                bottom: 0,
                width: null,
                height: 40,
                padding: 5,
                controlPosition: "left",
                autoPlay: false,
                rewind: false,
                loop: true,
                playInterval: 2000,
                currentIndex: 0,
                itemStyle: {normal: {}, emphasis: {}},
                label: {normal: {textStyle: {color: "#000"}}, emphasis: {}},
                data: []
            },
            init: function(I, K, J) {
                this._data;
                this._names;
                this.mergeDefaultAndTheme(I, J);
                this._initData()
            },
            mergeOption: function(I) {
                E.superApply(this, "mergeOption", arguments);
                this._initData()
            },
            setCurrentIndex: function(J) {
                if (J == null) {
                    J = this.option.currentIndex
                }
                var I = this._data.count();
                if (this.option.loop) {
                    J = (J % I + I) % I
                } else {
                    J >= I && (J = I - 1);
                    J < 0 && (J = 0)
                }
                this.option.currentIndex = J
            },
            getCurrentIndex: function() {
                return this.option.currentIndex
            },
            isIndexMax: function() {
                return this.getCurrentIndex() >= this._data.count() - 1
            },
            setPlayState: function(I) {
                this.option.autoPlay = !!I
            },
            getPlayState: function() {
                return !!this.option.autoPlay
            },
            _initData: function() {
                var O = this.option;
                var L = O.data || [];
                var N = O.axisType;
                var J = this._names = [];
                if (N === "category") {
                    var M = [];
                    C.each(L, function(R, S) {
                        var P = B.getDataItemValue(R);
                        var Q;
                        if (C.isObject(R)) {
                            Q = C.clone(R);
                            Q.value = S
                        } else {
                            Q = S
                        }
                        M.push(Q);
                        if (!C.isString(P) && (P == null || isNaN(P))) {
                            P = ""
                        }
                        J.push(P + "")
                    });
                    L = M
                }
                var K = ({category: "ordinal", time: "time"})[N] || "number";
                var I = this._data = new A([{name: "value", type: K}], this);
                I.initData(L, J)
            },
            getData: function() {
                return this._data
            },
            getCategories: function() {
                if (this.get("axisType") === "category") {
                    return this._names.slice()
                }
            }
        });
        F.exports = E
    }, function(S, F, T) {
        var E = T(4);
        var K = T(18);
        var H = T(71);
        var C = T(410);
        var A = T(411);
        var M = T(111);
        var J = T(101);
        var U = T(9);
        var I = T(11);
        var R = T(7);
        var V = T(6);
        var Q = V.encodeHTML;
        var B = E.bind;
        var G = E.each;
        var N = Math.PI;
        S.exports = C.extend({
            type: "timeline.slider", init: function(W, X) {
                this.api = X;
                this._axis;
                this._viewRect;
                this._timer;
                this._currentPointer;
                this._mainGroup;
                this._labelGroup
            }, render: function(b, X, c, Y) {
                this.model = b;
                this.api = c;
                this.ecModel = X;
                this.group.removeAll();
                if (b.get("show", true)) {
                    var a = this._layout(b, c);
                    var d = this._createGroup("mainGroup");
                    var W = this._createGroup("labelGroup");
                    var Z = this._axis = this._createAxis(a, b);
                    b.formatTooltip = function(e) {
                        return Q(Z.scale.getLabel(e))
                    };
                    G(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(e) {
                        this["_render" + e](a, d, Z, b)
                    }, this);
                    this._renderAxisLabel(a, W, Z, b);
                    this._position(a, b)
                }
                this._doPlayStop()
            }, remove: function() {
                this._clearTimer();
                this.group.removeAll()
            }, dispose: function() {
                this._clearTimer()
            }, _layout: function(d, j) {
                var h = d.get("label.normal.position");
                var e = d.get("orient");
                var u = O(d, j);
                if (h == null || h === "auto") {
                    h = e === "horizontal" ? ((u.y + u.height / 2) < j.getHeight() / 2 ? "-" : "+") : ((u.x + u.width / 2) < j.getWidth() / 2 ? "+" : "-")
                } else {
                    if (isNaN(h)) {
                        h = ({horizontal: {top: "-", bottom: "+"}, vertical: {left: "-", right: "+"}})[e][h]
                    }
                }
                var W = {horizontal: "center", vertical: (h >= 0 || h === "+") ? "left" : "right"};
                var Y = {horizontal: (h >= 0 || h === "+") ? "top" : "bottom", vertical: "middle"};
                var i = {horizontal: 0, vertical: N / 2};
                var a = e === "vertical" ? u.height : u.width;
                var p = d.getModel("controlStyle");
                var f = p.get("show");
                var Z = f ? p.get("itemSize") : 0;
                var k = f ? p.get("itemGap") : 0;
                var s = Z + k;
                var g = d.get("label.normal.rotate") || 0;
                g = g * N / 180;
                var m;
                var b;
                var c;
                var n;
                var t = p.get("position", true);
                var f = p.get("show", true);
                var l = f && p.get("showPlayBtn", true);
                var q = f && p.get("showPrevBtn", true);
                var o = f && p.get("showNextBtn", true);
                var X = 0;
                var r = a;
                if (t === "left" || t === "bottom") {
                    l && (m = [0, 0], X += s);
                    q && (b = [X, 0], X += s);
                    o && (c = [r - Z, 0], r -= s)
                } else {
                    l && (m = [r - Z, 0], r -= s);
                    q && (b = [0, 0], X += s);
                    o && (c = [r - Z, 0], r -= s)
                }
                n = [X, r];
                if (d.get("inverse")) {
                    n.reverse()
                }
                return {
                    viewRect: u,
                    mainLength: a,
                    orient: e,
                    rotation: i[e],
                    labelRotation: g,
                    labelPosOpt: h,
                    labelAlign: d.get("label.normal.textStyle.align") || W[e],
                    labelBaseline: d.get("label.normal.textStyle.baseline") || Y[e],
                    playPosition: m,
                    prevBtnPosition: b,
                    nextBtnPosition: c,
                    axisExtent: n,
                    controlSize: Z,
                    controlGap: k
                }
            }, _position: function(g, b) {
                var X = this._mainGroup;
                var Y = this._labelGroup;
                var o = g.viewRect;
                if (g.orient === "vertical") {
                    var c = I.create();
                    var n = o.x;
                    var l = o.y + o.height;
                    I.translate(c, c, [-n, -l]);
                    I.rotate(c, c, -N / 2);
                    I.translate(c, c, [n, l]);
                    o = o.clone();
                    o.applyTransform(c)
                }
                var d = j(o);
                var W = j(X.getBoundingRect());
                var k = j(Y.getBoundingRect());
                var Z = X.position;
                var i = Y.position;
                i[0] = Z[0] = d[0][0];
                var e = g.labelPosOpt;
                if (isNaN(e)) {
                    var a = e === "+" ? 0 : 1;
                    h(Z, W, d, 1, a);
                    h(i, k, d, 1, 1 - a)
                } else {
                    var a = e >= 0 ? 0 : 1;
                    h(Z, W, d, 1, a);
                    i[1] = Z[1] + e
                }
                X.attr("position", Z);
                Y.attr("position", i);
                X.rotation = Y.rotation = g.rotation;
                f(X);
                f(Y);

                function f(m) {
                    var p = m.position;
                    m.origin = [d[0][0] - p[0], d[1][0] - p[1]]
                }

                function j(m) {
                    return [[m.x, m.x + m.width], [m.y, m.y + m.height]]
                }

                function h(m, p, q, r, s) {
                    m[r] += q[r][s] - p[r][s]
                }
            }, _createAxis: function(c, W) {
                var X = W.getData();
                var b = W.get("axisType");
                var a = J.createScaleByModel(W, b);
                var Y = X.getDataExtent("value");
                a.setExtent(Y[0], Y[1]);
                this._customizeScale(a, X);
                a.niceTicks();
                var Z = new A("value", a, c.axisExtent, b);
                Z.model = W;
                return Z
            }, _customizeScale: function(W, X) {
                W.getTicks = function() {
                    return X.mapArray(["value"], function(Y) {
                        return Y
                    })
                };
                W.getTicksLabels = function() {
                    return E.map(this.getTicks(), W.getLabel, W)
                }
            }, _createGroup: function(W) {
                var X = this["_" + W] = new K.Group();
                this.group.add(X);
                return X
            }, _renderAxisLine: function(a, W, Z, X) {
                var Y = Z.getExtent();
                if (!X.get("lineStyle.show")) {
                    return
                }
                W.add(new K.Line({
                    shape: {x1: Y[0], y1: 0, x2: Y[1], y2: 0},
                    style: E.extend({lineCap: "round"}, X.getModel("lineStyle").getLineStyle()),
                    silent: true,
                    z2: 1
                }))
            }, _renderAxisTick: function(b, X, a, Y) {
                var Z = Y.getData();
                var W = a.scale.getTicks();
                G(W, function(f, g) {
                    var h = a.dataToCoord(f);
                    var c = Z.getItemModel(g);
                    var e = c.getModel("itemStyle.normal");
                    var d = c.getModel("itemStyle.emphasis");
                    var j = {position: [h, 0], onclick: B(this._changeTimeline, this, g)};
                    var i = P(c, e, X, j);
                    K.setHoverStyle(i, d.getItemStyle());
                    if (c.get("tooltip")) {
                        i.dataIndex = g;
                        i.dataModel = Y
                    } else {
                        i.dataIndex = i.dataModel = null
                    }
                }, this)
            }, _renderAxisLabel: function(Z, a, W, d) {
                var b = d.getModel("label.normal");
                if (!b.get("show")) {
                    return
                }
                var Y = d.getData();
                var c = W.scale.getTicks();
                var e = J.getFormattedLabels(W, b.get("formatter"));
                var X = W.getLabelInterval();
                G(c, function(f, g) {
                    if (W.isLabelIgnored(g, X)) {
                        return
                    }
                    var i = Y.getItemModel(g);
                    var k = i.getModel("label.normal.textStyle");
                    var j = i.getModel("label.emphasis.textStyle");
                    var h = W.dataToCoord(f);
                    var l = new K.Text({
                        style: {
                            text: e[g],
                            textAlign: Z.labelAlign,
                            textVerticalAlign: Z.labelBaseline,
                            textFont: k.getFont(),
                            fill: k.getTextColor()
                        }, position: [h, 0], rotation: Z.labelRotation - Z.rotation, onclick: B(this._changeTimeline, this, g), silent: false
                    });
                    a.add(l);
                    K.setHoverStyle(l, j.getItemStyle())
                }, this)
            }, _renderControl: function(b, c, W, e) {
                var f = b.controlSize;
                var g = b.rotation;
                var Z = e.getModel("controlStyle.normal").getItemStyle();
                var h = e.getModel("controlStyle.emphasis").getItemStyle();
                var X = [0, -f / 2, f, f];
                var a = e.getPlayState();
                var d = e.get("inverse", true);
                Y(b.nextBtnPosition, "controlStyle.nextIcon", B(this._changeTimeline, this, d ? "-" : "+"));
                Y(b.prevBtnPosition, "controlStyle.prevIcon", B(this._changeTimeline, this, d ? "+" : "-"));
                Y(b.playPosition, "controlStyle." + (a ? "stopIcon" : "playIcon"), B(this._handlePlayClick, this, !a), true);

                function Y(k, n, j, m) {
                    if (!k) {
                        return
                    }
                    var i = {position: k, origin: [f / 2, 0], rotation: m ? -g : 0, rectHover: true, style: Z, onclick: j};
                    var l = D(e, n, X, i);
                    c.add(l);
                    K.setHoverStyle(l, h)
                }
            }, _renderCurrentPointer: function(a, b, W, d) {
                var Z = d.getData();
                var Y = d.getCurrentIndex();
                var e = Z.getItemModel(Y).getModel("checkpointStyle");
                var c = this;
                var X = {
                    onCreate: function(f) {
                        f.draggable = true;
                        f.drift = B(c._handlePointerDrag, c);
                        f.ondragend = B(c._handlePointerDragend, c);
                        L(f, Y, W, d, true)
                    }, onUpdate: function(f) {
                        L(f, Y, W, d)
                    }
                };
                this._currentPointer = P(e, e, this._mainGroup, {}, this._currentPointer, X)
            }, _handlePlayClick: function(W) {
                this._clearTimer();
                this.api.dispatchAction({type: "timelinePlayChange", playState: W, from: this.uid})
            }, _handlePointerDrag: function(X, Y, W) {
                this._clearTimer();
                this._pointerChangeTimeline([W.offsetX, W.offsetY])
            }, _handlePointerDragend: function(W) {
                this._pointerChangeTimeline([W.offsetX, W.offsetY], true)
            }, _pointerChangeTimeline: function(a, b) {
                var W = this._toAxisCoord(a)[0];
                var c = this._axis;
                var X = R.asc(c.getExtent().slice());
                W > X[1] && (W = X[1]);
                W < X[0] && (W = X[0]);
                this._currentPointer.position[0] = W;
                this._currentPointer.dirty();
                var Z = this._findNearestTick(W);
                var Y = this.model;
                if (b || (Z !== Y.getCurrentIndex() && Y.get("realtime"))) {
                    this._changeTimeline(Z)
                }
            }, _doPlayStop: function() {
                this._clearTimer();
                if (this.model.getPlayState()) {
                    this._timer = setTimeout(B(W, this), this.model.get("playInterval"))
                }

                function W() {
                    var X = this.model;
                    this._changeTimeline(X.getCurrentIndex() + (X.get("rewind", true) ? -1 : 1))
                }
            }, _toAxisCoord: function(W) {
                var X = this._mainGroup.getLocalTransform();
                return K.applyTransform(W, X, true)
            }, _findNearestTick: function(W) {
                var a = this.model.getData();
                var Y = Infinity;
                var X;
                var Z = this._axis;
                a.each(["value"], function(f, b) {
                    var e = Z.dataToCoord(f);
                    var c = Math.abs(e - W);
                    if (c < Y) {
                        Y = c;
                        X = b
                    }
                });
                return X
            }, _clearTimer: function() {
                if (this._timer) {
                    clearTimeout(this._timer);
                    this._timer = null
                }
            }, _changeTimeline: function(W) {
                var X = this.model.getCurrentIndex();
                if (W === "+") {
                    W = X + 1
                } else {
                    if (W === "-") {
                        W = X - 1
                    }
                }
                this.api.dispatchAction({type: "timelineChange", currentIndex: W, from: this.uid})
            }
        });

        function O(X, W) {
            return H.getLayoutRect(X.getBoxLayoutParams(), {width: W.getWidth(), height: W.getHeight()}, X.get("padding"))
        }

        function D(W, Z, Y, X) {
            var a = K.makePath(W.get(Z).replace(/^path:\/\//, ""), E.clone(X || {}), new U(Y[0], Y[1], Y[2], Y[3]), "center");
            return a
        }

        function P(i, d, e, Z, f, Y) {
            var b = d.get("color");
            if (!f) {
                var a = i.get("symbol");
                f = M.createSymbol(a, -1, -1, 2, 2, b);
                f.setStyle("strokeNoScale", true);
                e.add(f);
                Y && Y.onCreate(f)
            } else {
                f.setColor(b);
                e.add(f);
                Y && Y.onUpdate(f)
            }
            var X = d.getItemStyle(["color", "symbol", "symbolSize"]);
            f.setStyle(X);
            Z = E.merge({rectHover: true, z2: 100}, Z, true);
            var W = i.get("symbolSize");
            W = W instanceof Array ? W.slice() : [+W, +W];
            W[0] /= 2;
            W[1] /= 2;
            Z.scale = W;
            var c = i.get("symbolOffset");
            if (c) {
                var g = Z.position = Z.position || [0, 0];
                g[0] += R.parsePercent(c[0], W[0]);
                g[1] += R.parsePercent(c[1], W[1])
            }
            var h = i.get("symbolRotate");
            Z.rotation = (h || 0) * Math.PI / 180 || 0;
            f.attr(Z);
            f.updateTransform();
            return f
        }

        function L(X, Z, c, Y, W) {
            if (X.dragging) {
                return
            }
            var b = Y.getModel("checkpointStyle");
            var a = c.dataToCoord(Y.getData().get(["value"], Z));
            if (W || !b.get("animation", true)) {
                X.attr({position: [a, 0]})
            } else {
                X.stopAnimation(true);
                X.animateTo({position: [a, 0]}, b.get("animationDuration", true), b.get("animationEasing", true))
            }
        }
    }, function(C, D, B) {
        var A = B(79);
        C.exports = A.extend({type: "timeline"})
    }, function(D, G, C) {
        var A = C(4);
        var F = C(100);
        var E = C(101);
        var B = function(I, J, H, K) {
            F.call(this, I, J, H);
            this.type = K || "value";
            this._autoLabelInterval;
            this.model = null
        };
        B.prototype = {
            constructor: B, getLabelInterval: function() {
                var H = this.model;
                var J = H.getModel("label.normal");
                var I = J.get("interval");
                if (I != null && I != "auto") {
                    return I
                }
                var I = this._autoLabelInterval;
                if (!I) {
                    I = this._autoLabelInterval = E.getAxisLabelInterval(A.map(this.scale.getTicks(), this.dataToCoord, this), E.getFormattedLabels(this, J.get("formatter")), J.getModel("textStyle").getFont(), H.get("orient") === "horizontal")
                }
                return I
            }, isLabelIgnored: function(I) {
                if (this.type === "category") {
                    var H = this.getLabelInterval();
                    return ((typeof H === "function") && !H(I, this.scale.getLabel(I))) || I % (H + 1)
                }
            }
        };
        A.inherits(B, F);
        D.exports = B
    }, function(B, C, A) {
        A(413);
        A(414);
        A(415);
        A(416);
        A(417);
        A(418);
        A(423)
    }, function(D, F, C) {
        var A = C(357);
        var B = C(4);
        var E = C(1).extendComponentModel({
            type: "toolbox",
            layoutMode: {type: "box", ignoreSize: true},
            mergeDefaultAndTheme: function(G) {
                E.superApply(this, "mergeDefaultAndTheme", arguments);
                B.each(this.option.feature, function(H, I) {
                    var J = A.get(I);
                    J && B.merge(H, J.defaultOption)
                })
            },
            defaultOption: {
                show: true,
                z: 6,
                zlevel: 0,
                orient: "horizontal",
                left: "right",
                top: "top",
                backgroundColor: "transparent",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemSize: 15,
                itemGap: 8,
                showTitle: true,
                iconStyle: {normal: {borderColor: "#666", color: "none"}, emphasis: {borderColor: "#3E98C5"}}
            }
        });
        D.exports = E
    }, function(B, C, A) {
        (function(G) {
            var J = A(357);
            var D = A(4);
            var F = A(18);
            var I = A(12);
            var E = A(99);
            var K = A(325);
            var H = A(8);
            B.exports = A(1).extendComponentView({
                type: "toolbox", render: function(M, N, V, O) {
                    var T = this.group;
                    T.removeAll();
                    if (!M.get("show")) {
                        return
                    }
                    var P = +M.get("itemSize");
                    var R = M.get("feature") || {};
                    var W = this._features || (this._features = {});
                    var S = [];
                    D.each(R, function(X, Y) {
                        S.push(Y)
                    });
                    (new E(this._featureNames || [], S)).add(U).update(U).remove(D.curry(U, null)).execute();
                    this._featureNames = S;

                    function U(Y, c) {
                        var d = S[Y];
                        var b = S[c];
                        var Z = R[d];
                        var a = new I(Z, M, M.ecModel);
                        var e;
                        if (d && !b) {
                            if (L(d)) {
                                e = {model: a, onclick: a.option.onclick, featureName: d}
                            } else {
                                var X = J.get(d);
                                if (!X) {
                                    return
                                }
                                e = new X(a, N, V)
                            }
                            W[d] = e
                        } else {
                            e = W[b];
                            if (!e) {
                                return
                            }
                            e.model = a;
                            e.ecModel = N;
                            e.api = V
                        }
                        if (!d && b) {
                            e.dispose && e.dispose(N, V);
                            return
                        }
                        if (!a.get("show") || e.unusable) {
                            e.remove && e.remove(N, V);
                            return
                        }
                        Q(a, e, d);
                        a.setIconStatus = function(f, h) {
                            var g = this.option;
                            var i = this.iconPaths;
                            g.iconStatus = g.iconStatus || {};
                            g.iconStatus[f] = h;
                            i[f] && i[f].trigger(h)
                        };
                        if (e.render) {
                            e.render(a, N, V, O)
                        }
                    }

                    function Q(b, f, d) {
                        var e = b.getModel("iconStyle");
                        var Z = f.getIcons ? f.getIcons() : b.get("icon");
                        var X = b.get("title") || {};
                        if (typeof Z === "string") {
                            var a = Z;
                            var c = X;
                            Z = {};
                            X = {};
                            Z[d] = a;
                            X[d] = c
                        }
                        var Y = b.iconPaths = {};
                        D.each(Z, function(k, h) {
                            var l = e.getModel("normal").getItemStyle();
                            var g = e.getModel("emphasis").getItemStyle();
                            var j = {x: -P / 2, y: -P / 2, width: P, height: P};
                            var i = k.indexOf("image://") === 0 ? (j.image = k.slice(8), new F.Image({style: j})) : F.makePath(k.replace("path://", ""), {
                                style: l,
                                hoverStyle: g,
                                rectHover: true
                            }, j, "center");
                            F.setHoverStyle(i);
                            if (M.get("showTitle")) {
                                i.__title = X[h];
                                i.on("mouseover", function() {
                                    var m = e.getModel("emphasis").getItemStyle();
                                    i.setStyle({
                                        text: X[h],
                                        textPosition: m.textPosition || "bottom",
                                        textFill: m.fill || m.stroke || "#000",
                                        textAlign: m.textAlign || "center"
                                    })
                                }).on("mouseout", function() {
                                    i.setStyle({textFill: null})
                                })
                            }
                            i.trigger(b.get("iconStatus." + h) || "normal");
                            T.add(i);
                            i.on("click", D.bind(f.onclick, f, N, V, h));
                            Y[h] = i
                        })
                    }

                    K.layout(T, M, V);
                    K.addBackground(T, M);
                    T.eachChild(function(b) {
                        var e = b.__title;
                        var d = b.hoverStyle;
                        if (d && e) {
                            var Z = H.getBoundingRect(e, d.font);
                            var X = b.position[0] + T.position[0];
                            var c = b.position[1] + T.position[1] + P;
                            var Y = false;
                            if (c + Z.height > V.getHeight()) {
                                d.textPosition = "top";
                                Y = true
                            }
                            var a = Y ? (-5 - Z.height) : (P + 8);
                            if (X + Z.width / 2 > V.getWidth()) {
                                d.textPosition = ["100%", a];
                                d.textAlign = "right"
                            } else {
                                if (X - Z.width / 2 < 0) {
                                    d.textPosition = [0, a];
                                    d.textAlign = "left"
                                }
                            }
                        }
                    })
                }, updateView: function(O, M, P, N) {
                    D.each(this._features, function(Q) {
                        Q.updateView && Q.updateView(Q.model, M, P, N)
                    })
                }, updateLayout: function(O, M, P, N) {
                    D.each(this._features, function(Q) {
                        Q.updateLayout && Q.updateLayout(Q.model, M, P, N)
                    })
                }, remove: function(M, N) {
                    D.each(this._features, function(O) {
                        O.remove && O.remove(M, N)
                    });
                    this.group.removeAll()
                }, dispose: function(M, N) {
                    D.each(this._features, function(O) {
                        O.dispose && O.dispose(M, N)
                    })
                }
            });

            function L(M) {
                return M.indexOf("my") === 0
            }
        }.call(C, A(310)))
    }, function(D, F, B) {
        var A = B(2);

        function E(G) {
            this.model = G
        }

        E.defaultOption = {
            show: true,
            icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
            title: "",
            type: "png",
            name: "",
            excludeComponents: ["toolbox"],
            pixelRatio: 1,
            lang: [""]
        };
        E.prototype.unusable = !A.canvasSupported;
        var C = E.prototype;
        C.onclick = function(H, O) {
            var Q = this.model;
            var L = Q.get("name") || H.get("title.0.text") || "echarts";
            var G = document.createElement("a");
            var N = Q.get("type", true) || "png";
            G.download = L + "." + N;
            G.target = "_blank";
            var M = O.getConnectedDataURL({
                type: N,
                backgroundColor: Q.get("backgroundColor", true) || H.get("backgroundColor") || "#fff",
                excludeComponents: Q.get("excludeComponents"),
                pixelRatio: Q.get("pixelRatio")
            });
            G.href = M;
            if (typeof MouseEvent === "function" && !A.browser.ie && !A.browser.edge) {
                var K = new MouseEvent("click", {view: window, bubbles: true, cancelable: false});
                G.dispatchEvent(K)
            } else {
                var I = Q.get("lang");
                var P = '<body style="margin:0;"><img src="' + M + '" style="max-width:100%;" title="' + ((I && I[0]) || "") + '" /></body>';
                var J = window.open();
                J.document.write(P)
            }
        };
        B(357).register("saveAsImage", E);
        D.exports = E
    }, function(G, I, C) {
        var B = C(4);

        function E(J) {
            this.model = J
        }

        E.defaultOption = {
            show: true,
            type: [],
            icon: {
                line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
                bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
                stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
                tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
            },
            title: {line: "", bar: "", stack: "", tiled: ""},
            option: {},
            seriesIndex: {}
        };
        var F = E.prototype;
        F.getIcons = function() {
            var K = this.model;
            var L = K.get("icon");
            var J = {};
            B.each(K.get("type"), function(M) {
                if (L[M]) {
                    J[M] = L[M]
                }
            });
            return J
        };
        var D = {
            "line": function(L, K, J, M) {
                if (L === "bar") {
                    return B.merge({
                        id: K,
                        type: "line",
                        data: J.get("data"),
                        stack: J.get("stack"),
                        markPoint: J.get("markPoint"),
                        markLine: J.get("markLine")
                    }, M.get("option.line") || {}, true)
                }
            }, "bar": function(L, K, J, M) {
                if (L === "line") {
                    return B.merge({
                        id: K,
                        type: "bar",
                        data: J.get("data"),
                        stack: J.get("stack"),
                        markPoint: J.get("markPoint"),
                        markLine: J.get("markLine")
                    }, M.get("option.bar") || {}, true)
                }
            }, "stack": function(L, K, J, M) {
                if (L === "line" || L === "bar") {
                    return B.merge({id: K, stack: "__ec_magicType_stack__"}, M.get("option.stack") || {}, true)
                }
            }, "tiled": function(L, K, J, M) {
                if (L === "line" || L === "bar") {
                    return B.merge({id: K, stack: ""}, M.get("option.tiled") || {}, true)
                }
            }
        };
        var A = [["line", "bar"], ["stack", "tiled"]];
        F.onclick = function(L, P, J) {
            var N = this.model;
            var M = N.get("seriesIndex." + J);
            if (!D[J]) {
                return
            }
            var O = {series: []};
            var K = function(a) {
                var X = a.subType;
                var T = a.id;
                var Y = D[J](X, T, a, N);
                if (Y) {
                    B.defaults(Y, a.option);
                    O.series.push(Y)
                }
                var R = a.coordinateSystem;
                if (R && R.type === "cartesian2d" && (J === "line" || J === "bar")) {
                    var V = R.getAxesByScale("ordinal")[0];
                    if (V) {
                        var Z = V.dim;
                        var Q = Z + "Axis";
                        var S = L.queryComponents({mainType: Q, index: a.get(name + "Index"), id: a.get(name + "Id")})[0];
                        var U = S.componentIndex;
                        O[Q] = O[Q] || [];
                        for (var W = 0; W <= U; W++) {
                            O[Q][U] = O[Q][U] || {}
                        }
                        O[Q][U].boundaryGap = J === "bar" ? true : false
                    }
                }
            };
            B.each(A, function(Q) {
                if (B.indexOf(Q, J) >= 0) {
                    B.each(Q, function(R) {
                        N.setIconStatus(R, "normal")
                    })
                }
            });
            N.setIconStatus(J, "emphasis");
            L.eachComponent({mainType: "series", query: M == null ? null : {seriesIndex: M}}, K);
            P.dispatchAction({type: "changeMagicType", currentType: J, newOption: O})
        };
        var H = C(1);
        H.registerAction({type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate"}, function(K, J) {
            J.mergeOption(K.newOption)
        });
        C(357).register("magicType", E);
        G.exports = E
    }, function(M, D, F) {
        var C = F(4);
        var O = F(88);
        var S = new Array(60).join("-");
        var E = "\t";

        function Q(U) {
            var W = {};
            var T = [];
            var V = [];
            U.eachRawSeries(function(Y) {
                var Z = Y.coordinateSystem;
                if (Z && (Z.type === "cartesian2d" || Z.type === "polar")) {
                    var a = Z.getBaseAxis();
                    if (a.type === "category") {
                        var X = a.dim + "_" + a.index;
                        if (!W[X]) {
                            W[X] = {categoryAxis: a, valueAxis: Z.getOtherAxis(a), series: []};
                            V.push({axisDim: a.dim, axisIndex: a.index})
                        }
                        W[X].series.push(Y)
                    } else {
                        T.push(Y)
                    }
                } else {
                    T.push(Y)
                }
            });
            return {seriesGroupByCategoryAxis: W, other: T, meta: V}
        }

        function N(U) {
            var T = [];
            C.each(U, function(a, V) {
                var Z = a.categoryAxis;
                var d = a.valueAxis;
                var W = d.dim;
                var c = [" "].concat(C.map(a.series, function(g) {
                    return g.name
                }));
                var X = [Z.model.getCategories()];
                C.each(a.series, function(g) {
                    X.push(g.getRawData().mapArray(W, function(h) {
                        return h
                    }))
                });
                var f = [c.join(E)];
                for (var b = 0; b < X[0].length; b++) {
                    var e = [];
                    for (var Y = 0; Y < X.length; Y++) {
                        e.push(X[Y][b])
                    }
                    f.push(e.join(E))
                }
                T.push(f.join("\n"))
            });
            return T.join("\n\n" + S + "\n\n")
        }

        function P(T) {
            return C.map(T, function(V) {
                var X = V.getRawData();
                var U = [V.name];
                var W = [];
                X.each(X.dimensions, function() {
                    var a = arguments.length;
                    var Y = arguments[a - 1];
                    var b = X.getName(Y);
                    for (var Z = 0; Z < a - 1; Z++) {
                        W[Z] = arguments[Z]
                    }
                    U.push((b ? (b + E) : "") + W.join(E))
                });
                return U.join("\n")
            }).join("\n\n" + S + "\n\n")
        }

        function B(T) {
            var U = Q(T);
            return {
                value: C.filter([N(U.seriesGroupByCategoryAxis), P(U.other)], function(V) {
                    return V.replace(/[\n\t\s]/g, "")
                }).join("\n\n" + S + "\n\n"), meta: U.meta
            }
        }

        function G(T) {
            return T.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
        }

        function R(U) {
            var T = U.slice(0, U.indexOf("\n"));
            if (T.indexOf(E) >= 0) {
                return true
            }
        }

        var H = new RegExp("[" + E + "]+", "g");

        function I(a) {
            var V = a.split(/\n+/g);
            var U = G(V.shift()).split(H);
            var T = [];
            var Y = C.map(U, function(b) {
                return {name: b, data: []}
            });
            for (var W = 0; W < V.length; W++) {
                var Z = G(V[W]).split(H);
                T.push(Z.shift());
                for (var X = 0; X < Z.length; X++) {
                    Y[X] && (Y[X].data[W] = Z[X])
                }
            }
            return {series: Y, categories: T}
        }

        function A(W) {
            var V = W.split(/\n+/g);
            var c = G(V.shift());
            var U = [];
            for (var Y = 0; Y < V.length; Y++) {
                var b = G(V[Y]).split(H);
                var T = "";
                var X;
                var a = false;
                if (isNaN(b[0])) {
                    a = true;
                    T = b[0];
                    b = b.slice(1);
                    U[Y] = {name: T, value: []};
                    X = U[Y].value
                } else {
                    X = U[Y] = []
                }
                for (var Z = 0; Z < b.length; Z++) {
                    X.push(+b[Z])
                }
                if (X.length === 1) {
                    a ? (U[Y].value = X[0]) : (U[Y] = X[0])
                }
            }
            return {name: c, data: U}
        }

        function L(V, U) {
            var T = V.split(new RegExp("\n*" + S + "\n*", "g"));
            var W = {series: []};
            C.each(T, function(b, a) {
                if (R(b)) {
                    var Y = I(b);
                    var Z = U[a];
                    var X = Z.axisDim + "Axis";
                    if (Z) {
                        W[X] = W[X] || [];
                        W[X][Z.axisIndex] = {data: Y.categories};
                        W.series = W.series.concat(Y.series)
                    }
                } else {
                    var Y = A(b);
                    W.series.push(Y)
                }
            });
            return W
        }

        function J(T) {
            this._dom = null;
            this.model = T
        }

        J.defaultOption = {
            show: true,
            readOnly: false,
            optionToContent: null,
            contentToOption: null,
            icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
            title: "",
            lang: ["", "", ""],
            backgroundColor: "#fff",
            textColor: "#000",
            textareaColor: "#fff",
            textareaBorderColor: "#333",
            buttonColor: "#c23531",
            buttonTextColor: "#fff"
        };
        J.prototype.onclick = function(W, d) {
            var k = d.getDom();
            var V = this.model;
            if (this._dom) {
                k.removeChild(this._dom)
            }
            var e = document.createElement("div");
            e.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;";
            e.style.backgroundColor = V.get("backgroundColor") || "#fff";
            var X = document.createElement("h4");
            var g = V.get("lang") || [];
            X.innerHTML = g[0] || V.get("title");
            X.style.cssText = "margin: 10px 20px;";
            X.style.color = V.get("textColor");
            var Y = document.createElement("div");
            var i = document.createElement("textarea");
            Y.style.cssText = "display:block;width:100%;overflow:auto;";
            var m = V.get("optionToContent");
            var Z = V.get("contentToOption");
            var l = B(W);
            if (typeof m === "function") {
                var T = m(d.getOption());
                if (typeof T === "string") {
                    Y.innerHTML = T
                } else {
                    if (C.isDom(T)) {
                        Y.appendChild(T)
                    }
                }
            } else {
                Y.appendChild(i);
                i.readOnly = V.get("readOnly");
                i.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;";
                i.style.color = V.get("textColor");
                i.style.borderColor = V.get("textareaBorderColor");
                i.style.backgroundColor = V.get("textareaColor");
                i.value = l.value
            }
            var f = l.meta;
            var b = document.createElement("div");
            b.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
            var U = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
            var c = document.createElement("div");
            var j = document.createElement("div");
            U += ";background-color:" + V.get("buttonColor");
            U += ";color:" + V.get("buttonTextColor");
            var h = this;

            function a() {
                k.removeChild(e);
                h._dom = null
            }

            O.addEventListener(c, "click", a);
            O.addEventListener(j, "click", function() {
                var o;
                try {
                    if (typeof Z === "function") {
                        o = Z(Y, d.getOption())
                    } else {
                        o = L(i.value, f)
                    }
                } catch (n) {
                    a();
                    throw new Error("Data view format error " + n)
                }
                if (o) {
                    d.dispatchAction({type: "changeDataView", newOption: o})
                }
                a()
            });
            c.innerHTML = g[1];
            j.innerHTML = g[2];
            j.style.cssText = U;
            c.style.cssText = U;
            !V.get("readOnly") && b.appendChild(j);
            b.appendChild(c);
            O.addEventListener(i, "keydown", function(n) {
                if ((n.keyCode || n.which) === 9) {
                    var p = this.value;
                    var q = this.selectionStart;
                    var o = this.selectionEnd;
                    this.value = p.substring(0, q) + E + p.substring(o);
                    this.selectionStart = this.selectionEnd = q + 1;
                    O.stop(n)
                }
            });
            e.appendChild(X);
            e.appendChild(Y);
            e.appendChild(b);
            Y.style.height = (k.clientHeight - 80) + "px";
            k.appendChild(e);
            this._dom = e
        };
        J.prototype.remove = function(T, U) {
            this._dom && U.getDom().removeChild(this._dom)
        };
        J.prototype.dispose = function(T, U) {
            this.remove(T, U)
        };

        function K(T, U) {
            return C.map(T, function(W, X) {
                var V = U && U[X];
                if (C.isObject(V) && !C.isArray(V)) {
                    if (C.isObject(W) && !C.isArray(W)) {
                        W = W.value
                    }
                    return C.defaults({value: W}, V)
                } else {
                    return W
                }
            })
        }

        F(357).register("dataView", J);
        F(1).registerAction({type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate"}, function(V, U) {
            var T = [];
            C.each(V.newOption.series, function(X) {
                var W = U.getSeriesByName(X.name)[0];
                if (!W) {
                    T.push(C.extend({type: "scatter"}, X))
                } else {
                    var Y = W.get("data");
                    T.push({name: X.name, data: K(X.data, Y)})
                }
            });
            U.mergeOption(C.defaults({series: T}, V.newOption))
        });
        M.exports = J
    }, function(O, P, E) {
        var J = E(4);
        var D = E(245);
        var M = E(352);
        var N = E(419);
        var F = E(239);
        var A = J.each;
        E(420);
        var K = "\0_ec_\0toolbox-dataZoom_";

        function B(S, Q, R) {
            (this._brushController = new D(R.getZr())).on("brush", J.bind(this._onBrush, this)).mount();
            this._isZoomActive
        }

        B.defaultOption = {
            show: true,
            icon: {zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"},
            title: {zoom: "", back: ""}
        };
        var I = B.prototype;
        I.render = function(S, Q, T, R) {
            this.model = S;
            this.ecModel = Q;
            this.api = T;
            H(S, Q, this, R, T);
            G(S, Q)
        };
        I.onclick = function(R, S, Q) {
            L[Q].call(this)
        };
        I.remove = function(Q, R) {
            this._brushController.unmount()
        };
        I.dispose = function(Q, R) {
            this._brushController.dispose()
        };
        var L = {
            zoom: function() {
                var Q = !this._isZoomActive;
                this.api.dispatchAction({type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: Q})
            }, back: function() {
                this._dispatchZoomAction(N.pop(this.ecModel))
            }
        };
        I._onBrush = function(Q, R) {
            if (!R.isEnd || !Q.length) {
                return
            }
            var V = {};
            var S = this.ecModel;
            this._brushController.updateCovers([]);
            var W = new M(C(this.model.option), S, {include: ["grid"]});
            W.matchOutputRanges(Q, S, function(a, X, Y) {
                if (Y.type !== "cartesian2d") {
                    return
                }
                var Z = a.brushType;
                if (Z === "rect") {
                    T("x", Y, X[0]);
                    T("y", Y, X[1])
                } else {
                    T(({lineX: "x", lineY: "y"})[Z], Y, X)
                }
            });
            N.push(S, V);
            this._dispatchZoomAction(V);

            function T(a, Z, X) {
                var d = Z.getAxis(a);
                var c = d.model;
                var b = U(a, c, S);
                var Y = b.findRepresentativeAxisProxy(c).getMinMaxSpan();
                if (Y.minValueSpan != null || Y.maxValueSpan != null) {
                    X = F(0, X.slice(), d.scale.getExtent(), 0, Y.minValueSpan, Y.maxValueSpan)
                }
                b && (V[b.id] = {dataZoomId: b.id, startValue: X[0], endValue: X[1]})
            }

            function U(Z, Y, X) {
                var a;
                X.eachComponent({mainType: "dataZoom", subType: "select"}, function(b) {
                    var c = b.getAxisModel(Z, Y.componentIndex);
                    c && (a = b)
                });
                return a
            }
        };
        I._dispatchZoomAction = function(Q) {
            var R = [];
            A(Q, function(T, S) {
                R.push(J.clone(T))
            });
            R.length && this.api.dispatchAction({type: "dataZoom", from: this.uid, batch: R})
        };

        function C(Q) {
            var R = {};
            J.each(["xAxisIndex", "yAxisIndex"], function(S) {
                R[S] = Q[S];
                R[S] == null && (R[S] = "all");
                (R[S] === false || R[S] === "none") && (R[S] = [])
            });
            return R
        }

        function G(R, Q) {
            R.setIconStatus("back", N.count(Q) > 1 ? "emphasis" : "normal")
        }

        function H(U, S, T, Q, V) {
            var R = T._isZoomActive;
            if (Q && Q.type === "takeGlobalCursor") {
                R = Q.key === "dataZoomSelect" ? Q.dataZoomSelectActive : false
            }
            T._isZoomActive = R;
            U.setIconStatus("zoom", R ? "emphasis" : "normal");
            var W = new M(C(U.option), S, {include: ["grid"]});
            T._brushController.setPanels(W.makePanelOpts(V, function(X) {
                return (X.xAxisDeclared && !X.yAxisDeclared) ? "lineX" : (!X.xAxisDeclared && X.yAxisDeclared) ? "lineY" : "rect"
            })).enableBrush(R ? {brushType: "auto", brushStyle: {lineWidth: 0, fill: "rgba(0,0,0,0.2)"}} : false)
        }

        E(357).register("dataZoom", B);
        E(1).registerPreprocessor(function(R) {
            if (!R) {
                return
            }
            var V = R.dataZoom || (R.dataZoom = []);
            if (!J.isArray(V)) {
                R.dataZoom = V = [V]
            }
            var S = R.toolbox;
            if (S) {
                if (J.isArray(S)) {
                    S = S[0]
                }
                if (S && S.feature) {
                    var T = S.feature.dataZoom;
                    Q("xAxis", T);
                    Q("yAxis", T)
                }
            }

            function Q(Z, Y) {
                if (!Y) {
                    return
                }
                var W = Z + "Index";
                var X = Y[W];
                if (X != null && X != "all" && !J.isArray(X)) {
                    X = (X === false || X === "none") ? [] : [X]
                }
                U(Z, function(a, c) {
                    if (X != null && X != "all" && J.indexOf(X, c) === -1) {
                        return
                    }
                    var b = {type: "select", $fromToolbox: true, id: K + Z + c};
                    b[W] = c;
                    V.push(b)
                })
            }

            function U(Y, W) {
                var X = R[Y];
                if (!J.isArray(X)) {
                    X = X ? [X] : []
                }
                A(X, W)
            }
        });
        O.exports = B
    }, function(G, H, D) {
        var C = D(4);
        var A = C.each;
        var E = "\0_ec_hist_store";
        var F = {
            push: function(J, K) {
                var I = B(J);
                A(K, function(P, M) {
                    var L = I.length - 1;
                    for (; L >= 0; L--) {
                        var Q = I[L];
                        if (Q[M]) {
                            break
                        }
                    }
                    if (L < 0) {
                        var O = J.queryComponents({mainType: "dataZoom", subType: "select", id: M})[0];
                        if (O) {
                            var N = O.getPercentRange();
                            I[0][M] = {dataZoomId: M, start: N[0], end: N[1]}
                        }
                    }
                });
                I.push(K)
            }, pop: function(J) {
                var I = B(J);
                var K = I[I.length - 1];
                I.length > 1 && I.pop();
                var L = {};
                A(K, function(O, N) {
                    for (var M = I.length - 1; M >= 0; M--) {
                        var O = I[M][N];
                        if (O) {
                            L[N] = O;
                            break
                        }
                    }
                });
                return L
            }, clear: function(I) {
                I[E] = null
            }, count: function(I) {
                return B(I).length
            }
        };

        function B(J) {
            var I = J[E];
            if (!I) {
                I = J[E] = [{}]
            }
            return I
        }

        G.exports = F
    }, function(B, C, A) {
        A(364);
        A(365);
        A(368);
        A(421);
        A(422);
        A(374);
        A(375)
    }, function(C, D, A) {
        var B = A(365);
        C.exports = B.extend({type: "dataZoom.select"})
    }, function(B, C, A) {
        B.exports = A(368).extend({type: "dataZoom.select"})
    }, function(D, F, B) {
        var A = B(419);

        function E(G) {
            this.model = G
        }

        E.defaultOption = {
            show: true,
            icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
            title: ""
        };
        var C = E.prototype;
        C.onclick = function(H, I, G) {
            A.clear(H);
            I.dispatchAction({type: "restore", from: this.uid})
        };
        B(357).register("restore", E);
        B(1).registerAction({type: "restore", event: "restore", update: "prepareAndUpdate"}, function(H, G) {
            G.resetOption("recreate")
        });
        D.exports = E
    }, function(B, C, A) {
        A(425);
        A(82).registerPainter("vml", A(427))
    }, function(v, Ae, V) {
        if (!V(2).canvasSupported) {
            var W = V(10);
            var D = V(9);
            var Ab = V(36).CMD;
            var u = V(31);
            var U = V(8);
            var f = V(35);
            var P = V(21);
            var G = V(49);
            var y = V(50);
            var Ah = V(20);
            var m = V(36);
            var Af = V(66);
            var B = V(426);
            var Ac = Math.round;
            var w = Math.sqrt;
            var s = Math.abs;
            var p = Math.cos;
            var K = Math.sin;
            var n = Math.max;
            var A = W.applyTransform;
            var J = ",";
            var k = "progid:DXImageTransform.Microsoft";
            var X = 21600;
            var r = X / 2;
            var h = 100000;
            var F = 1000;
            var T = function(Z) {
                Z.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;";
                Z.coordsize = X + "," + X;
                Z.coordorigin = "0,0"
            };
            var d = function(Z) {
                return String(Z).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
            };
            var q = function(i, Z, Ai) {
                return "rgb(" + [i, Z, Ai].join(",") + ")"
            };
            var L = function(i, Z) {
                if (Z && i && Z.parentNode !== i) {
                    i.appendChild(Z)
                }
            };
            var Q = function(i, Z) {
                if (Z && i && Z.parentNode === i) {
                    i.removeChild(Z)
                }
            };
            var x = function(i, Z, Ai) {
                return (parseFloat(i) || 0) * h + (parseFloat(Z) || 0) * F + Ai
            };
            var C = function(Z, i) {
                if (typeof Z === "string") {
                    if (Z.lastIndexOf("%") >= 0) {
                        return parseFloat(Z) / 100 * i
                    }
                    return parseFloat(Z)
                }
                return Z
            };
            var j = function(Z, Aj, Ai) {
                var i = u.parse(Aj);
                Ai = +Ai;
                if (isNaN(Ai)) {
                    Ai = 1
                }
                if (i) {
                    Z.color = q(i[0], i[1], i[2]);
                    Z.opacity = Ai * i[3]
                }
            };
            var z = function(i) {
                var Z = u.parse(i);
                return [q(Z[0], Z[1], Z[2]), Z[3]]
            };
            var a = function(AJ, Ax, Aq) {
                var AM = Ax.fill;
                if (AM != null) {
                    if (AM instanceof Af) {
                        var Ay;
                        var AL = 0;
                        var At = [0, 0];
                        var AG = 0;
                        var Ai = 1;
                        var AE = Aq.getBoundingRect();
                        var An = AE.width;
                        var Ar = AE.height;
                        if (AM.type === "linear") {
                            Ay = "gradient";
                            var Ao = Aq.transform;
                            var Av = [AM.x * An, AM.y * Ar];
                            var Ap = [AM.x2 * An, AM.y2 * Ar];
                            if (Ao) {
                                A(Av, Av, Ao);
                                A(Ap, Ap, Ao)
                            }
                            var Au = Ap[0] - Av[0];
                            var AI = Ap[1] - Av[1];
                            AL = Math.atan2(Au, AI) * 180 / Math.PI;
                            if (AL < 0) {
                                AL += 360
                            }
                            if (AL < 1e-06) {
                                AL = 0
                            }
                        } else {
                            Ay = "gradientradial";
                            var Av = [AM.x * An, AM.y * Ar];
                            var Ao = Aq.transform;
                            var Al = Aq.scale;
                            var Az = An;
                            var AK = Ar;
                            At = [(Av[0] - AE.x) / Az, (Av[1] - AE.y) / AK];
                            if (Ao) {
                                A(Av, Av, Ao)
                            }
                            Az /= Al[0] * X;
                            AK /= Al[1] * X;
                            var AD = n(Az, AK);
                            AG = 2 * 0 / AD;
                            Ai = 2 * AM.r / AD - AG
                        }
                        var AB = AM.colorStops.slice();
                        AB.sort(function(i, AN) {
                            return i.offset - AN.offset
                        });
                        var Z = AB.length;
                        var Aj = [];
                        var AC = [];
                        for (var AH = 0; AH < Z; AH++) {
                            var As = AB[AH];
                            var AA = z(As.color);
                            AC.push(As.offset * Ai + AG + " " + AA[0]);
                            if (AH === 0 || AH === Z - 1) {
                                Aj.push(AA)
                            }
                        }
                        if (Z >= 2) {
                            var Aw = Aj[0][0];
                            var Am = Aj[1][0];
                            var AF = Aj[0][1] * Ax.opacity;
                            var Ak = Aj[1][1] * Ax.opacity;
                            AJ.type = Ay;
                            AJ.method = "none";
                            AJ.focus = "100%";
                            AJ.angle = AL;
                            AJ.color = Aw;
                            AJ.color2 = Am;
                            AJ.colors = AC.join(",");
                            AJ.opacity = Ak;
                            AJ.opacity2 = AF
                        }
                        if (Ay === "radial") {
                            AJ.focusposition = At.join(",")
                        }
                    } else {
                        j(AJ, AM, Ax.opacity)
                    }
                }
            };
            var Y = function(Z, i) {
                if (i.lineDash != null) {
                    Z.dashstyle = i.lineDash.join(" ")
                }
                if (i.stroke != null && !(i.stroke instanceof Af)) {
                    j(Z, i.stroke, i.opacity)
                }
            };
            var N = function(Z, Al, Aj, i) {
                var Ai = Al == "fill";
                var Ak = Z.getElementsByTagName(Al)[0];
                if (Aj[Al] != null && Aj[Al] !== "none" && (Ai || (!Ai && Aj.lineWidth))) {
                    Z[Ai ? "filled" : "stroked"] = "true";
                    if (Aj[Al] instanceof Af) {
                        Q(Z, Ak)
                    }
                    if (!Ak) {
                        Ak = B.createNode(Al)
                    }
                    Ai ? a(Ak, Aj, i) : Y(Ak, Aj);
                    L(Z, Ak)
                } else {
                    Z[Ai ? "filled" : "stroked"] = "false";
                    Q(Z, Ak)
                }
            };
            var Aa = [[], [], []];
            var t = function(AP, AR) {
                var AG = Ab.M;
                var AH = Ab.C;
                var Ak = Ab.L;
                var AJ = Ab.A;
                var Az = Ab.Q;
                var AK = [];
                var An;
                var Am;
                var Ao;
                var AQ;
                var AE;
                var AF;
                for (AQ = 0; AQ < AP.length;) {
                    Ao = AP[AQ++];
                    Am = "";
                    An = 0;
                    switch (Ao) {
                        case AG:
                            Am = " m ";
                            An = 1;
                            AE = AP[AQ++];
                            AF = AP[AQ++];
                            Aa[0][0] = AE;
                            Aa[0][1] = AF;
                            break;
                        case Ak:
                            Am = " l ";
                            An = 1;
                            AE = AP[AQ++];
                            AF = AP[AQ++];
                            Aa[0][0] = AE;
                            Aa[0][1] = AF;
                            break;
                        case Az:
                        case AH:
                            Am = " c ";
                            An = 3;
                            var Ap = AP[AQ++];
                            var Aq = AP[AQ++];
                            var Ai = AP[AQ++];
                            var Aj = AP[AQ++];
                            var AS;
                            var AT;
                            if (Ao === Az) {
                                AS = Ai;
                                AT = Aj;
                                Ai = (Ai + 2 * Ap) / 3;
                                Aj = (Aj + 2 * Aq) / 3;
                                Ap = (AE + 2 * Ap) / 3;
                                Aq = (AF + 2 * Aq) / 3
                            } else {
                                AS = AP[AQ++];
                                AT = AP[AQ++]
                            }
                            Aa[0][0] = Ap;
                            Aa[0][1] = Aq;
                            Aa[1][0] = Ai;
                            Aa[1][1] = Aj;
                            Aa[2][0] = AS;
                            Aa[2][1] = AT;
                            AE = AS;
                            AF = AT;
                            break;
                        case AJ:
                            var AM = 0;
                            var AN = 0;
                            var AC = 1;
                            var Av = 1;
                            var At = 0;
                            if (AR) {
                                AM = AR[4];
                                AN = AR[5];
                                AC = w(AR[0] * AR[0] + AR[1] * AR[1]);
                                Av = w(AR[2] * AR[2] + AR[3] * AR[3]);
                                At = Math.atan2(-AR[1] / Av, AR[0] / AC)
                            }
                            var AL = AP[AQ++];
                            var AD = AP[AQ++];
                            var AB = AP[AQ++];
                            var Au = AP[AQ++];
                            var Ay = AP[AQ++] + At;
                            var AI = AP[AQ++] + Ay + At;
                            AQ++;
                            var Al = AP[AQ++];
                            var Aw = AL + p(Ay) * AB;
                            var Ax = AD + K(Ay) * Au;
                            var Ap = AL + p(AI) * AB;
                            var Aq = AD + K(AI) * Au;
                            var Z = Al ? " wa " : " at ";
                            if (Math.abs(Aw - Ap) < 0.0001) {
                                if (Math.abs(AI - Ay) > 0.01) {
                                    if (Al) {
                                        Aw += 270 / X
                                    }
                                } else {
                                    if (Math.abs(Ax - AD) < 0.0001) {
                                        if ((Al && Aw < AL) || (!Al && Aw > AL)) {
                                            Aq -= 270 / X
                                        } else {
                                            Aq += 270 / X
                                        }
                                    } else {
                                        if ((Al && Ax < AD) || (!Al && Ax > AD)) {
                                            Ap += 270 / X
                                        } else {
                                            Ap -= 270 / X
                                        }
                                    }
                                }
                            }
                            AK.push(Z, Ac(((AL - AB) * AC + AM) * X - r), J, Ac(((AD - Au) * Av + AN) * X - r), J, Ac(((AL + AB) * AC + AM) * X - r), J, Ac(((AD + Au) * Av + AN) * X - r), J, Ac((Aw * AC + AM) * X - r), J, Ac((Ax * Av + AN) * X - r), J, Ac((Ap * AC + AM) * X - r), J, Ac((Aq * Av + AN) * X - r));
                            AE = Ap;
                            AF = Aq;
                            break;
                        case Ab.R:
                            var AA = Aa[0];
                            var As = Aa[1];
                            AA[0] = AP[AQ++];
                            AA[1] = AP[AQ++];
                            As[0] = AA[0] + AP[AQ++];
                            As[1] = AA[1] + AP[AQ++];
                            if (AR) {
                                A(AA, AA, AR);
                                A(As, As, AR)
                            }
                            AA[0] = Ac(AA[0] * X - r);
                            As[0] = Ac(As[0] * X - r);
                            AA[1] = Ac(AA[1] * X - r);
                            As[1] = Ac(As[1] * X - r);
                            AK.push(" m ", AA[0], J, AA[1], " l ", As[0], J, AA[1], " l ", As[0], J, As[1], " l ", AA[0], J, As[1]);
                            break;
                        case Ab.Z:
                            AK.push(" x ")
                    }
                    if (An > 0) {
                        AK.push(Am);
                        for (var Ar = 0; Ar < An; Ar++) {
                            var AO = Aa[Ar];
                            AR && A(AO, AO, AR);
                            AK.push(Ac(AO[0] * X - r), J, Ac(AO[1] * X - r), Ar < An - 1 ? J : "")
                        }
                    }
                }
                return AK.join("")
            };
            Ah.prototype.brushVML = function(Z) {
                var Ak = this.style;
                var i = this._vmlEl;
                if (!i) {
                    i = B.createNode("shape");
                    T(i);
                    this._vmlEl = i
                }
                N(i, "fill", Ak, this);
                N(i, "stroke", Ak, this);
                var An = this.transform;
                var Am = An != null;
                var Aj = i.getElementsByTagName("stroke")[0];
                if (Aj) {
                    var Al = Ak.lineWidth;
                    if (Am && !Ak.strokeNoScale) {
                        var Ai = An[0] * An[3] - An[1] * An[2];
                        Al *= w(s(Ai))
                    }
                    Aj.weight = Al + "px"
                }
                var Ao = this.path || (this.path = new m());
                if (this.__dirtyPath) {
                    Ao.beginPath();
                    this.buildPath(Ao, this.shape);
                    Ao.toStatic();
                    this.__dirtyPath = false
                }
                i.path = t(Ao.data, this.transform);
                i.style.zIndex = x(this.zlevel, this.z, this.z2);
                L(Z, i);
                if (Ak.text != null) {
                    this.drawRectText(Z, this.getBoundingRect())
                } else {
                    this.removeRectText(Z)
                }
            };
            Ah.prototype.onRemove = function(Z) {
                Q(Z, this._vmlEl);
                this.removeRectText(Z)
            };
            Ah.prototype.onAdd = function(Z) {
                L(Z, this._vmlEl);
                this.appendRectText(Z)
            };
            var b = function(Z) {
                return (typeof Z === "object") && Z.tagName && Z.tagName.toUpperCase() === "IMG"
            };
            G.prototype.brushVML = function(AA) {
                var AJ = this.style;
                var Ao = AJ.image;
                var Ay;
                var Ap;
                if (b(Ao)) {
                    var AG = Ao.src;
                    if (AG === this._imageSrc) {
                        Ay = this._imageWidth;
                        Ap = this._imageHeight
                    } else {
                        var AP = Ao.runtimeStyle;
                        var AQ = AP.width;
                        var Aj = AP.height;
                        AP.width = "auto";
                        AP.height = "auto";
                        Ay = Ao.width;
                        Ap = Ao.height;
                        AP.width = AQ;
                        AP.height = Aj;
                        this._imageSrc = AG;
                        this._imageWidth = Ay;
                        this._imageHeight = Ap
                    }
                    Ao = AG
                } else {
                    if (Ao === this._imageSrc) {
                        Ay = this._imageWidth;
                        Ap = this._imageHeight
                    }
                }
                if (!Ao) {
                    return
                }
                var AL = AJ.x || 0;
                var AM = AJ.y || 0;
                var Ar = AJ.width;
                var At = AJ.height;
                var Al = AJ.sWidth;
                var An = AJ.sHeight;
                var AD = AJ.sx || 0;
                var As = AJ.sy || 0;
                var Az = Al && An;
                var AI = this._vmlEl;
                if (!AI) {
                    AI = B.doc.createElement("div");
                    T(AI);
                    this._vmlEl = AI
                }
                var AO = AI.style;
                var AR = false;
                var AS;
                var AF = 1;
                var Ax = 1;
                if (this.transform) {
                    AS = this.transform;
                    AF = w(AS[0] * AS[0] + AS[1] * AS[1]);
                    Ax = w(AS[2] * AS[2] + AS[3] * AS[3]);
                    AR = AS[1] || AS[2]
                }
                if (AR) {
                    var AC = [AL, AM];
                    var Av = [AL + Ar, AM];
                    var Am = [AL, AM + At];
                    var Z = [AL + Ar, AM + At];
                    A(AC, AC, AS);
                    A(Av, Av, AS);
                    A(Am, Am, AS);
                    A(Z, Z, AS);
                    var Au = n(AC[0], Av[0], Am[0], Z[0]);
                    var AB = n(AC[1], Av[1], Am[1], Z[1]);
                    var Ai = [];
                    Ai.push("M11=", AS[0] / AF, J, "M12=", AS[2] / Ax, J, "M21=", AS[1] / AF, J, "M22=", AS[3] / Ax, J, "Dx=", Ac(AL * AF + AS[4]), J, "Dy=", Ac(AM * Ax + AS[5]));
                    AO.padding = "0 " + Ac(Au) + "px " + Ac(AB) + "px 0";
                    AO.filter = k + ".Matrix(" + Ai.join("") + ", SizingMethod=clip)"
                } else {
                    if (AS) {
                        AL = AL * AF + AS[4];
                        AM = AM * Ax + AS[5]
                    }
                    AO.filter = "";
                    AO.left = Ac(AL) + "px";
                    AO.top = Ac(AM) + "px"
                }
                var Aq = this._imageEl;
                var AN = this._cropEl;
                if (!Aq) {
                    Aq = B.doc.createElement("div");
                    this._imageEl = Aq
                }
                var Aw = Aq.style;
                if (Az) {
                    if (!(Ay && Ap)) {
                        var Ak = new Image();
                        var AH = this;
                        Ak.onload = function() {
                            Ak.onload = null;
                            Ay = Ak.width;
                            Ap = Ak.height;
                            Aw.width = Ac(AF * Ay * Ar / Al) + "px";
                            Aw.height = Ac(Ax * Ap * At / An) + "px";
                            AH._imageWidth = Ay;
                            AH._imageHeight = Ap;
                            AH._imageSrc = Ao
                        };
                        Ak.src = Ao
                    } else {
                        Aw.width = Ac(AF * Ay * Ar / Al) + "px";
                        Aw.height = Ac(Ax * Ap * At / An) + "px"
                    }
                    if (!AN) {
                        AN = B.doc.createElement("div");
                        AN.style.overflow = "hidden";
                        this._cropEl = AN
                    }
                    var AK = AN.style;
                    AK.width = Ac((Ar + AD * Ar / Al) * AF);
                    AK.height = Ac((At + As * At / An) * Ax);
                    AK.filter = k + ".Matrix(Dx=" + (-AD * Ar / Al * AF) + ",Dy=" + (-As * At / An * Ax) + ")";
                    if (!AN.parentNode) {
                        AI.appendChild(AN)
                    }
                    if (Aq.parentNode != AN) {
                        AN.appendChild(Aq)
                    }
                } else {
                    Aw.width = Ac(AF * Ar) + "px";
                    Aw.height = Ac(Ax * At) + "px";
                    AI.appendChild(Aq);
                    if (AN && AN.parentNode) {
                        AI.removeChild(AN);
                        this._cropEl = null
                    }
                }
                var AE = "";
                var i = AJ.opacity;
                if (i < 1) {
                    AE += ".Alpha(opacity=" + Ac(i * 100) + ") "
                }
                AE += k + ".AlphaImageLoader(src=" + Ao + ", SizingMethod=scale)";
                Aw.filter = AE;
                AI.style.zIndex = x(this.zlevel, this.z, this.z2);
                L(AA, AI);
                if (AJ.text != null) {
                    this.drawRectText(AA, this.getBoundingRect())
                }
            };
            G.prototype.onRemove = function(Z) {
                Q(Z, this._vmlEl);
                this._vmlEl = null;
                this._cropEl = null;
                this._imageEl = null;
                this.removeRectText(Z)
            };
            G.prototype.onAdd = function(Z) {
                L(Z, this._vmlEl);
                this.appendRectText(Z)
            };
            var l = "normal";
            var I = {};
            var O = 0;
            var M = 100;
            var E = document.createElement("div");
            var g = function(Ai) {
                var Aj = I[Ai];
                if (!Aj) {
                    if (O > M) {
                        O = 0;
                        I = {}
                    }
                    var i = E.style;
                    var Ak;
                    try {
                        i.font = Ai;
                        Ak = i.fontFamily.split(",")[0]
                    } catch (Z) {
                    }
                    Aj = {
                        style: i.fontStyle || l,
                        variant: i.fontVariant || l,
                        weight: i.fontWeight || l,
                        size: parseFloat(i.fontSize || 12) | 0,
                        family: Ak || "Microsoft YaHei"
                    };
                    I[Ai] = Aj;
                    O++
                }
                return Aj
            };
            var c;
            U.measureText = function(i, Ai) {
                var Aj = B.doc;
                if (!c) {
                    c = Aj.createElement("div");
                    c.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;";
                    B.doc.body.appendChild(c)
                }
                try {
                    c.style.font = Ai
                } catch (Z) {
                }
                c.innerHTML = "";
                c.appendChild(Aj.createTextNode(i));
                return {width: c.offsetWidth}
            };
            var o = new D();
            var H = function(Ak, An, AF, At) {
                var AE = this.style;
                var Ap = AE.text;
                Ap != null && (Ap += "");
                if (!Ap) {
                    return
                }
                var AB;
                var AC;
                var Z = AE.textAlign;
                var Aj = g(AE.textFont);
                var Am = Aj.style + " " + Aj.variant + " " + Aj.weight + " " + Aj.size + 'px "' + Aj.family + '"';
                var As = AE.textBaseline;
                var Ay = AE.textVerticalAlign;
                AF = AF || U.getBoundingRect(Ap, Am, Z, As);
                var Al = this.transform;
                if (Al && !At) {
                    o.copy(An);
                    o.applyTransform(Al);
                    An = o
                }
                if (!At) {
                    var Az = AE.textPosition;
                    var AD = AE.textDistance;
                    if (Az instanceof Array) {
                        AB = An.x + C(Az[0], An.width);
                        AC = An.y + C(Az[1], An.height);
                        Z = Z || "left";
                        As = As || "top"
                    } else {
                        var Aw = U.adjustTextPositionOnRect(Az, An, AF, AD);
                        AB = Aw.x;
                        AC = Aw.y;
                        Z = Z || Aw.textAlign;
                        As = As || Aw.textBaseline
                    }
                } else {
                    AB = An.x;
                    AC = An.y
                }
                if (Ay) {
                    switch (Ay) {
                        case"middle":
                            AC -= AF.height / 2;
                            break;
                        case"bottom":
                            AC -= AF.height;
                            break
                    }
                    As = "top"
                }
                var Av = Aj.size;
                switch (As) {
                    case"hanging":
                    case"top":
                        AC += Av / 1.75;
                        break;
                    case"middle":
                        break;
                    default:
                        AC -= Av / 2.25;
                        break
                }
                switch (Z) {
                    case"left":
                        break;
                    case"center":
                        AB -= AF.width / 2;
                        break;
                    case"right":
                        AB -= AF.width;
                        break
                }
                var AA = B.createNode;
                var Ao = this._textVmlEl;
                var Ax;
                var i;
                var Ar;
                if (!Ao) {
                    Ao = AA("line");
                    Ax = AA("path");
                    i = AA("textpath");
                    Ar = AA("skew");
                    i.style["v-text-align"] = "left";
                    T(Ao);
                    Ax.textpathok = true;
                    i.on = true;
                    Ao.from = "0 0";
                    Ao.to = "1000 0.05";
                    L(Ao, Ar);
                    L(Ao, Ax);
                    L(Ao, i);
                    this._textVmlEl = Ao
                } else {
                    Ar = Ao.firstChild;
                    Ax = Ar.nextSibling;
                    i = Ax.nextSibling
                }
                var Au = [AB, AC];
                var Ai = Ao.style;
                if (Al && At) {
                    A(Au, Au, Al);
                    Ar.on = true;
                    Ar.matrix = Al[0].toFixed(3) + J + Al[2].toFixed(3) + J + Al[1].toFixed(3) + J + Al[3].toFixed(3) + ",0,0";
                    Ar.offset = (Ac(Au[0]) || 0) + "," + (Ac(Au[1]) || 0);
                    Ar.origin = "0 0";
                    Ai.left = "0px";
                    Ai.top = "0px"
                } else {
                    Ar.on = false;
                    Ai.left = Ac(AB) + "px";
                    Ai.top = Ac(AC) + "px"
                }
                i.string = d(Ap);
                try {
                    i.style.font = Am
                } catch (Aq) {
                }
                N(Ao, "fill", {fill: At ? AE.fill : AE.textFill, opacity: AE.opacity}, this);
                N(Ao, "stroke", {stroke: At ? AE.stroke : AE.textStroke, opacity: AE.opacity, lineDash: AE.lineDash}, this);
                Ao.style.zIndex = x(this.zlevel, this.z, this.z2);
                L(Ak, Ao)
            };
            var e = function(Z) {
                Q(Z, this._textVmlEl);
                this._textVmlEl = null
            };
            var Ag = function(Z) {
                L(Z, this._textVmlEl)
            };
            var R = [f, P, G, Ah, y];
            for (var Ad = 0; Ad < R.length; Ad++) {
                var S = R[Ad].prototype;
                S.drawRectText = H;
                S.removeRectText = e;
                S.appendRectText = Ag
            }
            y.prototype.brushVML = function(i) {
                var Z = this.style;
                if (Z.text != null) {
                    this.drawRectText(i, {x: Z.x || 0, y: Z.y || 0, width: 0, height: 0}, this.getBoundingRect(), true)
                } else {
                    this.removeRectText(i)
                }
            };
            y.prototype.onRemove = function(Z) {
                this.removeRectText(Z)
            };
            y.prototype.onAdd = function(Z) {
                this.appendRectText(Z)
            }
        }
    }, function(I, J, C) {
        if (!C(2).canvasSupported) {
            var F = "urn:schemas-microsoft-com:vml";
            var B;
            var G = window;
            var E = G.document;
            var H = false;
            try {
                !E.namespaces.zrvml && E.namespaces.add("zrvml", F);
                B = function(K) {
                    return E.createElement("<zrvml:" + K + ' class="zrvml">')
                }
            } catch (A) {
                B = function(K) {
                    return E.createElement("<" + K + ' xmlns="' + F + '" class="zrvml">')
                }
            }
            var D = function() {
                if (H) {
                    return
                }
                H = true;
                var K = E.styleSheets;
                if (K.length < 31) {
                    E.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)")
                } else {
                    K[0].addRule(".zrvml", "behavior:url(#default#VML)")
                }
            };
            I.exports = {doc: E, initVML: D, createNode: B}
        }
    }, function(J, K, D) {
        var B = D(33);
        var A = D(426);

        function C(L) {
            return parseInt(L, 10)
        }

        function I(N, L) {
            A.initVML();
            this.root = N;
            this.storage = L;
            var O = document.createElement("div");
            var P = document.createElement("div");
            O.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;";
            P.style.cssText = "position:absolute;left:0;top:0;";
            N.appendChild(O);
            this._vmlRoot = P;
            this._vmlViewport = O;
            this.resize();
            var Q = L.delFromStorage;
            var M = L.addToStorage;
            L.delFromStorage = function(R) {
                Q.call(L, R);
                if (R) {
                    R.onRemove && R.onRemove(P)
                }
            };
            L.addToStorage = function(R) {
                R.onAdd && R.onAdd(P);
                M.call(L, R)
            };
            this._firstPaint = true
        }

        I.prototype = {
            constructor: I, getViewportRoot: function() {
                return this._vmlViewport
            }, refresh: function() {
                var L = this.storage.getDisplayList(true, true);
                this._paintList(L)
            }, _paintList: function(N) {
                var O = this._vmlRoot;
                for (var M = 0; M < N.length; M++) {
                    var L = N[M];
                    if (L.invisible || L.ignore) {
                        if (!L.__alreadyNotVisible) {
                            L.onRemove(O)
                        }
                        L.__alreadyNotVisible = true
                    } else {
                        if (L.__alreadyNotVisible) {
                            L.onAdd(O)
                        }
                        L.__alreadyNotVisible = false;
                        if (L.__dirty) {
                            L.beforeBrush && L.beforeBrush();
                            (L.brushVML || L.brush).call(L, O);
                            L.afterBrush && L.afterBrush()
                        }
                    }
                    L.__dirty = false
                }
                if (this._firstPaint) {
                    this._vmlViewport.appendChild(O);
                    this._firstPaint = false
                }
            }, resize: function(N, L) {
                var N = N == null ? this._getWidth() : N;
                var L = L == null ? this._getHeight() : L;
                if (this._width != N || this._height != L) {
                    this._width = N;
                    this._height = L;
                    var M = this._vmlViewport.style;
                    M.width = N + "px";
                    M.height = L + "px"
                }
            }, dispose: function() {
                this.root.innerHTML = "";
                this._vmlRoot = this._vmlViewport = this.storage = null
            }, getWidth: function() {
                return this._width
            }, getHeight: function() {
                return this._height
            }, clear: function() {
                if (this._vmlViewport) {
                    this.root.removeChild(this._vmlViewport)
                }
            }, _getWidth: function() {
                var L = this.root;
                var M = L.currentStyle;
                return ((L.clientWidth || C(M.width)) - C(M.paddingLeft) - C(M.paddingRight)) | 0
            }, _getHeight: function() {
                var L = this.root;
                var M = L.currentStyle;
                return ((L.clientHeight || C(M.height)) - C(M.paddingTop) - C(M.paddingBottom)) | 0
            }
        };

        function F(L) {
            return function() {
                B('In IE8.0 VML mode painter not support method "' + L + '"')
            }
        }

        var G = ["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"];
        for (var E = 0; E < G.length; E++) {
            var H = G[E];
            I.prototype[H] = F(H)
        }
        J.exports = I
    }])
});